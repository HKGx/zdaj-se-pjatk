{
  "title": "Systemy Baz Danych (SBD)",
  "id": "sbd",
  "data": [
    {
      "question": "Instrukcja SELECT służy do:",
      "id": 641,
      "comments": null,
      "answers": [
        {
          "answer": "sprowadzania rekordów z bazy danych",
          "correct": true
        },
        {
          "answer": "wstawiania rekordów do bazy danych",
          "correct": false
        },
        {
          "answer": "usuwania rekordów z bazy danych",
          "correct": false
        },
        {
          "answer": "aktualizacji rekordów w bazie danych",
          "correct": false
        }
      ]
    },
    {
      "question": "Instrukcja INSERT służy do:",
      "id": 642,
      "comments": null,
      "answers": [
        {
          "answer": "sprowadzania rekordów z bazy danych",
          "correct": false
        },
        {
          "answer": "wstawiania rekordów do bazy danych",
          "correct": true
        },
        {
          "answer": "usuwania rekordów z bazy danych",
          "correct": false
        },
        {
          "answer": "aktualizacji rekordów w bazie danych",
          "correct": false
        }
      ]
    },
    {
      "question": "Instrukcja DELETE służy do:",
      "id": 643,
      "comments": null,
      "answers": [
        {
          "answer": "sprowadzania rekordów z bazy danych",
          "correct": false
        },
        {
          "answer": "wstawiania rekordów do bazy danych",
          "correct": false
        },
        {
          "answer": "usuwania rekordów z bazy danych",
          "correct": true
        },
        {
          "answer": "aktualizacji rekordów w bazie danych",
          "correct": false
        }
      ]
    },
    {
      "question": "Instrukcja UPDATE służy do:",
      "id": 644,
      "comments": null,
      "answers": [
        {
          "answer": "sprowadzania rekordów z bazy danych",
          "correct": false
        },
        {
          "answer": "wstawiania rekordów do bazy danych",
          "correct": false
        },
        {
          "answer": "usuwania rekordów z bazy danych",
          "correct": false
        },
        {
          "answer": "aktualizacji rekordów w bazie danych",
          "correct": true
        }
      ]
    },
    {
      "question": "INDEKS w bazie danych przyśpiesza:",
      "id": 645,
      "comments": [
        {
          "author": "~anon@89.64.*.*",
          "comment": "Nie przyspiesza również delete? np. DELETE FROM emp WHERE empno = 12;",
          "date": "01-02-2019 21:45:30"
        },
        {
          "author": "~JM@188.65.*.*",
          "comment": "wykłady milczą w temacie, ale internety potwierdzają, że są scenariusze gdzie indeks przyspiesza delete",
          "date": "11-02-2019 13:27:07"
        }
      ],
      "answers": [
        {
          "answer": "wyszukiwania rekordów w bazie danych",
          "correct": true
        },
        {
          "answer": "wstawiania rekordów do bazy danych",
          "correct": false
        },
        {
          "answer": "usuwania rekordów z bazy danych",
          "correct": false
        },
        {
          "answer": "autoryzację użytkowników w bazie danych",
          "correct": false
        }
      ]
    },
    {
      "question": "Instrukcja COMMIT służy do:",
      "id": 646,
      "comments": null,
      "answers": [
        {
          "answer": "wycofywania zmian w bazie danych",
          "correct": false
        },
        {
          "answer": "wstawiania rekordów do bazy danych",
          "correct": false
        },
        {
          "answer": "zatwierdzania zmian w bazie danych",
          "correct": true
        },
        {
          "answer": "aktualizacji rekordów w bazie danych",
          "correct": false
        }
      ]
    },
    {
      "question": "Instrukcja ROLLBACK służy do:",
      "id": 647,
      "comments": null,
      "answers": [
        {
          "answer": "wycofywania zmian w bazie danych",
          "correct": true
        },
        {
          "answer": "zatwierdzania zmian w bazie danych",
          "correct": false
        },
        {
          "answer": "usuwania rekordów z bazy danych",
          "correct": false
        },
        {
          "answer": "aktualizacji rekordów w bazie danych",
          "correct": false
        }
      ]
    },
    {
      "question": "Instrukcja GRANT służy do:",
      "id": 648,
      "comments": null,
      "answers": [
        {
          "answer": "przyznawania uprawnień w bazie danych",
          "correct": true
        },
        {
          "answer": "zatwierdzania zmian w bazie danych",
          "correct": false
        },
        {
          "answer": "odbierania uprawnień w bazie danych",
          "correct": false
        },
        {
          "answer": "aktualizacji rekordów w bazie danych",
          "correct": false
        }
      ]
    },
    {
      "question": "Instrukcja REVOKE służy do:",
      "id": 649,
      "comments": null,
      "answers": [
        {
          "answer": "przyznawania uprawnień w bazie danych",
          "correct": false
        },
        {
          "answer": "zatwierdzania zmian w bazie danych",
          "correct": false
        },
        {
          "answer": "odbierania uprawnień w bazie danych",
          "correct": true
        },
        {
          "answer": "wycofywania zmian w bazie danych",
          "correct": false
        }
      ]
    },
    {
      "question": "Instrukcja ALTER TABLE służy do:",
      "id": 650,
      "comments": [
        {
          "author": "~mefmund@31.174.*.*",
          "comment": "Czy to jest dobra odpowiedz bo na www.w3schools.com znalazlem taki opis:\nThe ALTER TABLE statement is used to add, delete, or modify columns in an existing table.\nPewnosci nie mam wiec prosze o sprawdzenie... ",
          "date": "29-06-2014 14:35:05"
        },
        {
          "author": "~anon@89.79.*.*",
          "comment": "Tak, dodawanie/usuwanie/modyfikacja kolumn == zmiana schematu tabelii.",
          "date": "29-06-2014 16:29:49"
        },
        {
          "author": "~mefmund@5.173.*.*",
          "comment": "Nie doczytalem kluczowego slowa columns... ;P Sorry za zamieszanie. ;]",
          "date": "29-06-2014 19:12:10"
        }
      ],
      "answers": [
        {
          "answer": "tworzenia tabeli",
          "correct": false
        },
        {
          "answer": "usuwania tabeli",
          "correct": false
        },
        {
          "answer": "zmiany schematu tabeli",
          "correct": true
        },
        {
          "answer": "aktualizacji indeksów założonych na tabeli",
          "correct": false
        }
      ]
    },
    {
      "question": "Jaka jest wartość wyrażenia Null=Null:",
      "id": 651,
      "comments": [
        {
          "author": "~anon@89.74.*.*",
          "comment": "a chyba Null=Null nie jest False? (z googla)",
          "date": "22-01-2017 12:45:48"
        },
        {
          "author": "~sbd@83.6.*.*",
          "comment": "nie, zgodnie z wykladem:\n\"Ponieważ wszystkie porównania na danych, w których argumentem jest NULL dają w wyniku NULL, konieczne było wprowadzenie operatora, pozwalającego stwierdzić, czy w danej komórce znajduje się (lub nie) pseudowartość NULL. Jest to operator IS NULL (IS NOT NULL).\"",
          "date": "22-01-2017 21:39:59"
        }
      ],
      "answers": [
        {
          "answer": "jest nieokreślone",
          "correct": false
        },
        {
          "answer": "True",
          "correct": false
        },
        {
          "answer": "False",
          "correct": false
        },
        {
          "answer": "Null",
          "correct": true
        }
      ]
    },
    {
      "question": "Jaka jest wartość wyrażenia True OR Null:",
      "id": 652,
      "comments": null,
      "answers": [
        {
          "answer": "jest nieokreślone",
          "correct": false
        },
        {
          "answer": "True",
          "correct": true
        },
        {
          "answer": "False",
          "correct": false
        },
        {
          "answer": "Null",
          "correct": false
        }
      ]
    },
    {
      "question": "Jaka jest wartość wyrażenia False OR Null:",
      "id": 653,
      "comments": null,
      "answers": [
        {
          "answer": "jest nieokreślone",
          "correct": false
        },
        {
          "answer": "True",
          "correct": false
        },
        {
          "answer": "False",
          "correct": false
        },
        {
          "answer": "Null",
          "correct": true
        }
      ]
    },
    {
      "question": "Jaka jest wartość wyrażenia False AND Null:",
      "id": 654,
      "comments": null,
      "answers": [
        {
          "answer": "jest nieokreślone",
          "correct": false
        },
        {
          "answer": "True",
          "correct": false
        },
        {
          "answer": "False",
          "correct": true
        },
        {
          "answer": "Null",
          "correct": false
        }
      ]
    },
    {
      "question": "Jaka jest wartość wyrażenia True AND Null:",
      "id": 655,
      "comments": null,
      "answers": [
        {
          "answer": "jest nieokreślone",
          "correct": false
        },
        {
          "answer": "True",
          "correct": false
        },
        {
          "answer": "False",
          "correct": false
        },
        {
          "answer": "Null",
          "correct": true
        }
      ]
    },
    {
      "question": "Jaka jest wartość wyrażenia NOT Null:",
      "id": 656,
      "comments": null,
      "answers": [
        {
          "answer": "jest nieokreślone",
          "correct": false
        },
        {
          "answer": "True",
          "correct": false
        },
        {
          "answer": "False",
          "correct": false
        },
        {
          "answer": "Null",
          "correct": true
        }
      ]
    },
    {
      "question": "Co będzie wynikiem realizacji instrukcji SELECT * FROM Emp WHERE EmpNo=EmpNo OR EmpNo=NULL",
      "id": 657,
      "comments": [
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Nie ma tu poprawnych odpowiedzi. \"Relacja Emp\" nie jest poprawna odpowiedzią. Załóżmy, że EmpNo będzie NULL. Wtedy sprawdzany warunek będzie następujący: \"NULL = NULL OR NULL = NULL\". Warunek \"NULL = NULL\" daje jako rezultat NULL. Czyli nasz warunek z zadania będzie wtedy brzmiał \"NULL OR NULL\" co również daje NULL. Aby dany wiersz w SELECT został wyświetlony, warunek w WHERE musi zwrócić TRUE. To oznacza, że wynikiem realizacji omawianej instrukcji będą wszystkie wiersze, które w polu EmpNo nie posiadają wartości NULL.\nAby zapytanie zwróciło relację Emp, zamiast \"EmpNo = NULL\" powinno być \"Empno IS NULL\".\n\nWięcej o operatorach w SQL tutaj: http://edu.pjwstk.edu.pl/wyklady/sbd/scb/rW0.htm",
          "date": "06-02-2013 20:15:00"
        },
        {
          "author": "~TęgaPała@178.183.*.*",
          "comment": "Chyba wszystkie grupy miały na ćwiczeniach tabelę emp. Na pewno jest w wykładach. Atrubut empno jest tam kluczem głównym, więc nie może przyjmować wartości null.",
          "date": "06-02-2013 20:27:09"
        },
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Pytanie to pytanie. W pytaniu nie ma nic, że to klucz główny.",
          "date": "06-02-2013 22:32:47"
        },
        {
          "author": "~anon@212.2.*.*",
          "comment": "Dokładnie, nie jest tak, że instrukcja jest niepoprawna, bo nie można porównać czegoś z nullem zwykłym operatore?\n",
          "date": "13-02-2019 16:32:05"
        },
        {
          "author": "~darcoola@162.158.*.*",
          "comment": "EmpNo = NULL da zawsze NULL\nEmpNo = EmpNo da TRUE, chyba że jest NULL wtedy NULL\nMamy więc TRUE OR NULL (czyli TRUE) albo NULL OR NULL (czyli NULL)\nDlatego zapytanie zwróci wszystkie wiersze, które nie mają wartości NULL w polu EmpNo - więc zapytanie zwróci relację (tabelę) Emp, ale tylko przy założeniu NOTNULL w kolumnie EmpNo - pytanie nie jest precyzyjne.",
          "date": "20-06-2019 14:18:31"
        },
        {
          "author": "~Tomisław Apoloniusz Curuś Bachleda Farrel (jak ten piecyk z dmuchawką)@212.75.*.*",
          "comment": "SQL Server nie protestuje. W przypadku zapytania z OR zwróci całość, a w przypadku AND będzie pusta relacja",
          "date": "09-07-2020 20:22:40"
        }
      ],
      "answers": [
        {
          "answer": "relacja Emp",
          "correct": true
        },
        {
          "answer": "relacja pusta",
          "correct": false
        },
        {
          "answer": "instrukcja jest niepoprawna",
          "correct": false
        }
      ]
    },
    {
      "question": "Co będzie wynikiem realizacji instrukcji SELECT * FROM Emp WHERE EmpNo=EmpNo AND NULL=EmpNo",
      "id": 658,
      "comments": null,
      "answers": [
        {
          "answer": "relacja Emp",
          "correct": false
        },
        {
          "answer": "relacja pusta",
          "correct": true
        },
        {
          "answer": "instrukcja jest niepoprawna",
          "correct": false
        }
      ]
    },
    {
      "question": "Relacja R ma atrybut a. Jaka liczba może być wynikiem wykonania instrukcji SELECT Count(*) FROM R WHERE a=a",
      "id": 659,
      "comments": [
        {
          "author": "~hmi@217.96.*.*",
          "comment": "dwie złączone odpowiedzi",
          "date": "30-08-2012 10:48:16"
        },
        {
          "author": "mykhi",
          "comment": "poprawiłem.",
          "date": "02-02-2013 21:13:51"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "Mialem te pytanie na tescie na eduxie internetowym i inne odpowiedzi prawidlowe dalo mi czyli wlasnie wszystkie oprocz tego z tym ze zawsze tyle jaka jest liczebnosc relacji R",
          "date": "05-02-2013 08:31:05"
        },
        {
          "author": "~anon@178.235.*.*",
          "comment": "przed chwilą pani Chądzyńska w odpowiedzi na maila napisała mi że poprawne odpowiedzi to 0 i 1, odpowiedź D nie, ponieważ liczby ujemne są również liczbami całkowitymi a nigdy ich nie otrzymamy ",
          "date": "05-02-2013 21:06:57"
        },
        {
          "author": "~TęgaPała@178.183.*.*",
          "comment": "Odpowiedź: \"zawsze tyle jaka jest liczebność relacji R\" jest niepoprawna w przypadku gdy atrybut a może przyjmować wartość null. Na pewno poprawne są pierwsze dwie odpowiedzi.",
          "date": "05-02-2013 22:14:30"
        },
        {
          "author": "mykhi",
          "comment": "porpawiam.",
          "date": "06-02-2013 00:38:21"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "Jest to dosc ciekawa sytuacja bo nic nie jest napisane jakie wartosci moze przyjmowac 'a'. Samo zastosowanie zapytania w bazie zwraca count rowny licznosci relacji R. Zatem przy tym pytaniu mozna mocno deliberowac z wykladowca.",
          "date": "26-06-2013 23:44:39"
        },
        {
          "author": "~anon@80.50.*.*",
          "comment": "count(*) podaje ilość rekordów relacji nawet wtedy kiedy wszystkie pola mają wartość null. Inaczej zachowuje się count (nazwaKolumny) - wtedy nie zliczane są wartości mające wartość null",
          "date": "23-06-2014 18:37:24"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "~anon@80.50.*.* - Nie masz racji kolego.",
          "date": "07-09-2014 11:12:33"
        },
        {
          "author": "~anon@89.76.*.*",
          "comment": "w tescie na edux prawidłowe odpowiedzi to 0 1 i dowolna liczba calkowita\n",
          "date": "29-01-2015 19:08:02"
        },
        {
          "author": "~anon@89.76.*.*",
          "comment": "Jednal prawidłowe odpowiedzi to 0 1 i UWAGA na teści dodaje odpowiedz dowolna liczba naturalna :) za miast calkowita To wtedy i tą odpowiedz sie zaznacza ^)",
          "date": "29-01-2015 19:13:38"
        },
        {
          "author": "~anon@5.79.*.*",
          "comment": "Atrybut o wartosci ujemnej w bazie danych aha.... I to powtwierdził wykładowca....\n",
          "date": "27-08-2018 19:04:32"
        },
        {
          "author": "~anon@162.158.*.*",
          "comment": "Należy wziąć pod uwagę, że SELECT zwróci wartość jeśli w WHERE będzie TRUE, a dla 'a' będącego NULL w warunku WHERE będzie NULL (NULL = NULL da NULL), dlatego odpowiedź na to pytanie to na pewno dowolna liczba NATURALNA (NIE całkowita), ale odpowiedź c) nie może być poprawna.",
          "date": "20-06-2019 15:24:46"
        }
      ],
      "answers": [
        {
          "answer": "0",
          "correct": true
        },
        {
          "answer": "1",
          "correct": true
        },
        {
          "answer": "zawsze tyle jaka jest liczebność relacji R.",
          "correct": false
        },
        {
          "answer": "dowolna liczba całkowita",
          "correct": false
        }
      ]
    },
    {
      "question": "Relacja R ma atrybut a. Jaka liczba może być wynikiem wykonania instrukcji SELECT Count(*) FROM R WHERE a<a <img=\"\" src=\"question.png\" height=\"16\" width=\"16\" onclick=\"window.open('?comment=660','komentarze','width=560,height=360')\">      </a>",
      "id": null,
      "comments": null,
      "answers": [
        {
          "answer": "zawsze 0",
          "correct": true
        },
        {
          "answer": "1dowolna liczba całkowita",
          "correct": false
        },
        {
          "answer": "tyle jaka jest liczebność relacji R.",
          "correct": false
        }
      ]
    },
    {
      "question": "Encji odpowiada w relacyjnej bazie danych:",
      "id": 661,
      "comments": null,
      "answers": [
        {
          "answer": "wiersz w tabeli",
          "correct": false
        },
        {
          "answer": "kolumna w tabeli",
          "correct": false
        },
        {
          "answer": "tabela",
          "correct": true
        },
        {
          "answer": "klucz obcy",
          "correct": false
        }
      ]
    },
    {
      "question": "Związkowi jednoznacznemu odpowiada w relacyjnej bazie danych:",
      "id": 662,
      "comments": [
        {
          "author": "~mimo@89.77.*.*",
          "comment": "że what?",
          "date": "06-09-2013 21:54:48"
        },
        {
          "author": "~anon@89.70.*.*",
          "comment": "Ciekawa koncepcja, a to klucz obcy nie jest równoważny kolumnie?",
          "date": "09-08-2017 21:15:20"
        }
      ],
      "answers": [
        {
          "answer": "kolumna w tabeli",
          "correct": false
        },
        {
          "answer": "klucz obcy",
          "correct": true
        },
        {
          "answer": "indeks w tabeli",
          "correct": false
        },
        {
          "answer": "wartość NULL",
          "correct": false
        }
      ]
    },
    {
      "question": "Związkowi wieloznacznemu odpowiada w relacyjnej bazie danych:",
      "id": 663,
      "comments": null,
      "answers": [
        {
          "answer": "klucz obcy",
          "correct": false
        },
        {
          "answer": "tabela",
          "correct": true
        },
        {
          "answer": "kolumna w tabeli",
          "correct": false
        },
        {
          "answer": "wiersz w tabeli",
          "correct": false
        }
      ]
    },
    {
      "question": "Atrybutowi w relacyjnej bazie danych odpowiada:",
      "id": 664,
      "comments": null,
      "answers": [
        {
          "answer": "kolumna w tabeli",
          "correct": true
        },
        {
          "answer": "wiersz w tabeli",
          "correct": false
        },
        {
          "answer": "tabela",
          "correct": false
        },
        {
          "answer": "indeks w tabeli",
          "correct": false
        }
      ]
    },
    {
      "question": "Jednoznacznemu identyfikatorowi odpowiada w relacyjnej bazie danych:",
      "id": 665,
      "comments": null,
      "answers": [
        {
          "answer": "kolumna w tabeli",
          "correct": false
        },
        {
          "answer": "indeks w tabeli",
          "correct": false
        },
        {
          "answer": "klucz obcy",
          "correct": false
        },
        {
          "answer": "klucz główny",
          "correct": true
        }
      ]
    },
    {
      "question": "Spójność referencyjna dotyczy faktu:",
      "id": 666,
      "comments": null,
      "answers": [
        {
          "answer": "wartością klucza obcego może być null lub wartość odpowiadającego mu klucza głównego",
          "correct": true
        },
        {
          "answer": "wartości w kolumnie nie powtarzają się",
          "correct": false
        },
        {
          "answer": "wartości w kolumnie nie mogą zależeć ani od części klucza ani nawet przechodnio od klucza",
          "correct": false
        },
        {
          "answer": "w każdej tabeli powinien istnieć dokładnie jeden klucz",
          "correct": false
        }
      ]
    },
    {
      "question": "III postać normalna dotyczy faktu:",
      "id": 667,
      "comments": null,
      "answers": [
        {
          "answer": "wartością klucza obcego może być null lub wartość odpowiadającego mu klucza głównego",
          "correct": false
        },
        {
          "answer": "wartości w kolumnie nie powtarzają się",
          "correct": false
        },
        {
          "answer": "wartości w kolumnie niekluczowej nie mogą zależeć ani od części klucza ani nawet przechodnio od klucza",
          "correct": true
        },
        {
          "answer": "w każdej tabeli powinien istnieć dokładnie jeden klucz",
          "correct": false
        }
      ]
    },
    {
      "question": "Które ze sformułowań są prawdziwe w modelu relacyjnym:",
      "id": 668,
      "comments": null,
      "answers": [
        {
          "answer": "wartości w kolumnie są przechowywane w kolejności posortowanej",
          "correct": false
        },
        {
          "answer": "wiersze nie powtarzają się",
          "correct": true
        },
        {
          "answer": "kolejność kolumn jest nieistotna",
          "correct": true
        },
        {
          "answer": "wartości w kolumnie nie powtarzają się",
          "correct": false
        }
      ]
    },
    {
      "question": "Które ze sformułowań są prawdziwe w modelu relacyjnym:",
      "id": 669,
      "comments": null,
      "answers": [
        {
          "answer": "wiersze nie mają tożsamości obiektowej",
          "correct": true
        },
        {
          "answer": "związek jednoznaczny reprezentuje się przy pomocy klucza obcego",
          "correct": true
        },
        {
          "answer": "związek wieloznaczny reprezentuje się przy pomocy klucza obcego",
          "correct": false
        },
        {
          "answer": "klucze obce muszą być typu całkowitego",
          "correct": false
        }
      ]
    },
    {
      "question": "Które ze sformułowań są prawdziwe w modelu relacyjnym:",
      "id": 670,
      "comments": [
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Dla klucza głównego jest automatycznie zakładany indeks. Wykłady mówią: \"gdy klucz wyszukiwania zawiera klucz główny, indeks nazywa się indeksem głównym\". Jednak nigdzie się nie doczytałem, że indeks główny jest również indeksem jednoznacznym.\n\nŹródło: http://edu.pjwstk.edu.pl/wyklady/sbd/scb/rW9.htm",
          "date": "06-02-2013 23:07:22"
        },
        {
          "author": "~whatever@83.6.*.*",
          "comment": "indeks główny jest ZAWSZE jednoznaczny",
          "date": "06-02-2013 23:54:45"
        },
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Mógłbyś pokazać jakieś źródło, w którym jest tak napisane?",
          "date": "07-02-2013 00:01:35"
        },
        {
          "author": "~whatever@83.6.*.*",
          "comment": "http://pl.wikipedia.org/wiki/Klucz_główny",
          "date": "07-02-2013 00:05:42"
        },
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Nie ma tam wzmianki, że INDEKS główny jest jednoznacznym.",
          "date": "07-02-2013 00:22:56"
        },
        {
          "author": "~Radek@89.78.*.*",
          "comment": "Klucz jednoznaczny (nazywany też kluczem alternatywnym lub w skrócie kluczem) ma tę samą własność co klucz główny przy czym klucz główny jest tylko jeden, kluczy jednoznacznych w tabeli może być więcej niż jeden. (z wykładu)\nWynika z tego że klucz główny jest kluczem jednoznacznym, ale wracając do pytanie, to dla klucza jednoznacznego nie zakłada się indeksów, no chyba że ten klucz jest kluczem głównym.",
          "date": "07-09-2014 08:44:19"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "Radku, cytat z wykładu:\n\nPrzy definiowaniu klucza obcego nie można się odwoływać ani do synonimu tabeli, ani do tabeli znajdującej się w innej (odległej) bazie danych. Samo jego zdefiniowanie nie powoduje automatycznie utworzenia indeksu, jak w przypadku klucza głównego i jednoznacznego.\n\nTzn, że jak widać zaznaczone odpowiedzi są ok.",
          "date": "07-09-2014 10:06:20"
        }
      ],
      "answers": [
        {
          "answer": "tabela jest konkretną reprezentacją relacji",
          "correct": true
        },
        {
          "answer": "dla klucza jednoznacznego jest automatycznie zakładany indeks",
          "correct": true
        },
        {
          "answer": "dla klucza obcego jest automatycznie zakładany indeks",
          "correct": false
        },
        {
          "answer": "dla klucza głównego jest automatycznie zakładany indeks jednoznaczny",
          "correct": true
        }
      ]
    },
    {
      "question": "Które ze sformułowań są prawdziwe w modelu relacyjnym:",
      "id": 671,
      "comments": [
        {
          "author": "~Beliar91@89.72.*.*",
          "comment": "Przecież wartości klucza głównego w modelu relacyjnym nie mogą się powtarzać xD (czyli jak dla mnie 2 i 3 poprawne)",
          "date": "05-02-2012 21:20:38"
        },
        {
          "author": "~hmi@159.205.*.*",
          "comment": "popieram, moim zdaniem poprawne są 2 i 3 odpowiedź",
          "date": "30-08-2012 23:14:06"
        },
        {
          "author": "~anon@89.68.*.*",
          "comment": "j/w",
          "date": "04-02-2013 15:18:30"
        },
        {
          "author": "mykhi",
          "comment": "poprawiłem.",
          "date": "04-02-2013 15:19:53"
        }
      ],
      "answers": [
        {
          "answer": "klucz obcy nie może być częścią klucza główego",
          "correct": false
        },
        {
          "answer": "klucz główny nie może być częścią klucza obcego",
          "correct": true
        },
        {
          "answer": "wartości klucza głównego nie mogą się powtarzać",
          "correct": true
        },
        {
          "answer": "wartości klucza obcego nie mogą się powtarzać",
          "correct": false
        }
      ]
    },
    {
      "question": "Zależność złączeniowa jest uogólnieniem zależności wielowartościowej w następującym sensie:",
      "id": 672,
      "comments": null,
      "answers": [
        {
          "answer": "dotyczy rozbicia tabeli na dokładnie dwie tabele,",
          "correct": false
        },
        {
          "answer": "dotyczy rozbicia tabeli na dokładnie trzy tabele,",
          "correct": false
        },
        {
          "answer": "dotyczy rozbicia tabeli na więcej niż dwie tabele,",
          "correct": true
        },
        {
          "answer": "dotyczy rozbicia tabeli na co najmniej dwie tabele,",
          "correct": false
        }
      ]
    },
    {
      "question": "Postać normalna Boyce'a-Codda dotyczy faktu:",
      "id": 673,
      "comments": null,
      "answers": [
        {
          "answer": "wartością klucza obcego może być null lub wartość odpowiadającego mu klucza głównego",
          "correct": false
        },
        {
          "answer": "każda nietrywialna zależność funkcyjna jest zależnością od nadklucza,",
          "correct": true
        },
        {
          "answer": "wartości w kolumnie niekluczowej nie mogą zależeć ani od części klucza ani nawet przechodnio od klucza",
          "correct": false
        },
        {
          "answer": "w każdej tabeli powinien istnieć dokładnie jeden klucz",
          "correct": false
        }
      ]
    },
    {
      "question": "Które z poniższych stwierdzeń są prawdziwe:",
      "id": 674,
      "comments": null,
      "answers": [
        {
          "answer": "jedyną poprawną, nietrywialną zależnością funkcyjną jest zależność do klucza,",
          "correct": true
        },
        {
          "answer": "należy starać się użyć najmniejszej możliwej liczby tabel,",
          "correct": false
        },
        {
          "answer": "w tabeli nie powinno być żadnych niekontrolowanych redundancji,",
          "correct": true
        },
        {
          "answer": "należy wszystkie związki jednoznaczne zastąpić związkami jednojednoznacznymi.",
          "correct": false
        }
      ]
    },
    {
      "question": "Które z poniższych stwierdzeń są prawdziwe:",
      "id": 675,
      "comments": null,
      "answers": [
        {
          "answer": "każdy fakt przechowywany w bazie danych powinien być w niej wyrażany tylko na jeden sposób,",
          "correct": true
        },
        {
          "answer": "należy starać się użyć najmniejszej możliwej liczby tabel,",
          "correct": false
        },
        {
          "answer": "należy skonsultować z użytkownikiem poprawność skonstruowanego modelu danych,",
          "correct": true
        },
        {
          "answer": "należy spytać się użytkownika czy schemat tabel jest w III postaci normalnej.",
          "correct": false
        }
      ]
    },
    {
      "question": "Dany jest schemat relacyjny R={Miasto, Ulica, Kod}, F = {Miasto,Ulica-&gt;Kod; Kod-&gt;Miasto}. W której postaci normalnej jest ten schemat:",
      "id": 676,
      "comments": [
        {
          "author": "~antykij@89.70.*.*",
          "comment": "IMO schemat nie jest w BCNF i w 3NF",
          "date": "26-06-2013 20:22:38"
        },
        {
          "author": "~flopy@83.12.*.*",
          "comment": "IMO też nie jest 3NF, pola nie są zależne bezpośrednio od klucza. BTW nie wiadomo któe to klucz :)",
          "date": "29-08-2013 16:36:42"
        },
        {
          "author": "~m_r_k@80.50.*.*",
          "comment": "Nie jest w BCNF, ale jest w 3NF - podany przykład jest w książce Relacyjne bazy danych.",
          "date": "26-06-2014 17:00:03"
        },
        {
          "author": "~joł@89.70.*.*",
          "comment": "Z tego co wiem, to w 2 postaci musi byc klucz głowny,a tu go nie widze",
          "date": "09-08-2017 21:57:22"
        },
        {
          "author": "~joł@89.70.*.*",
          "comment": "Znalazłem w wykładach ten przykład i klucze są takie: {Miasto, Ulica} oraz {Kod, Ulica}. Odpowiedzi to: A,B,C",
          "date": "19-08-2017 21:13:55"
        },
        {
          "author": "~anon@79.184.*.*",
          "comment": "Ma ktoś jakieś dobre źródła do nauki tego?",
          "date": "06-02-2018 20:32:17"
        }
      ],
      "answers": [
        {
          "answer": "I postać normalna;",
          "correct": true
        },
        {
          "answer": "II postać normalna,",
          "correct": true
        },
        {
          "answer": "III postać normalna,",
          "correct": true
        },
        {
          "answer": "postać normalna Boyce'a-Codda.",
          "correct": false
        }
      ]
    },
    {
      "question": "Dany jest schemat relacyjny R={Miasto, Ulica, Kod, Poczta}, F = {Miasto,Ulica-&gt;Kod; Kod-&gt;Miasto; Kod-&gt;Poczta}. W której postaci normalnej jest ten schemat:",
      "id": 677,
      "comments": [
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Czy aby na pewno tylko w I postaci jest ten schemat? Kluczem jest {Miasto, Ulica} -> Kod -> Poczta. Poczta jest pośrednio zależna od od klucza, więc jest w 2NF, ale nie jest w 3NF. Tak ja to rozumiem. Jeśli jest inaczej, prośba o wytłumaczenie.",
          "date": "02-02-2013 15:17:07"
        },
        {
          "author": "~flopy@83.12.*.*",
          "comment": "popieram Wąsky'ego",
          "date": "03-09-2013 16:22:37"
        },
        {
          "author": "~anon@78.88.*.*",
          "comment": "na 100% I i II ",
          "date": "28-06-2014 14:46:44"
        },
        {
          "author": "mykhi",
          "comment": "ok, zmieniam z I na I i II",
          "date": "28-06-2014 17:20:30"
        },
        {
          "author": "~ktoś@5.173.*.*",
          "comment": "A to nie jest przypadkiem tak, że kluczami mogą być zarówno {Miasto, Ulica} jak i {Kod, Ulica}? Wtedy mielibyśmy zależność częściową od klucza przy relacji {Kod->Miasto}, co sprawia, że ten schemat nie jest jednak w II postaci normalnej.",
          "date": "30-01-2020 10:16:29"
        }
      ],
      "answers": [
        {
          "answer": "I postać normalna;",
          "correct": true
        },
        {
          "answer": "II postać normalna,",
          "correct": true
        },
        {
          "answer": "III postać normalna,",
          "correct": false
        },
        {
          "answer": "postać normalna Boyce'a-Codda.",
          "correct": false
        }
      ]
    },
    {
      "question": "Dany jest schemat relacyjny R={Miasto, Ulica, Kod, Poczta}, F = {Miasto,Ulica-&gt;Kod; Kod-&gt;Poczta}. W której postaci normalnej jest ten schemat:",
      "id": 678,
      "comments": [
        {
          "author": "~anon@81.15.*.*",
          "comment": "błąd: https://edux.pjwstk.edu.pl/Lessond.aspx?id=13838&sid=976\n\nzależność Kod -> Poczta nie jest zależnością żadnego typu 1, 2, 3, ponieważ nie jest trywialna...\n",
          "date": "29-01-2016 18:50:58"
        },
        {
          "author": "~anon@81.15.*.*",
          "comment": "sorry, dobrze jest.",
          "date": "29-01-2016 18:52:17"
        },
        {
          "author": "~anon@81.15.*.*",
          "comment": "sorry, dobrze jest.",
          "date": "29-01-2016 18:52:17"
        },
        {
          "author": "~anon@81.15.*.*",
          "comment": "sorry, dobrze jest.",
          "date": "29-01-2016 18:52:18"
        },
        {
          "author": "~anon@81.15.*.*",
          "comment": "sorry, dobrze jest.",
          "date": "29-01-2016 18:52:19"
        },
        {
          "author": "~anon@81.15.*.*",
          "comment": "sorry, dobrze jest.",
          "date": "29-01-2016 18:52:19"
        }
      ],
      "answers": [
        {
          "answer": "I postać normalna;",
          "correct": true
        },
        {
          "answer": "II postać normalna,",
          "correct": true
        },
        {
          "answer": "III postać normalna,",
          "correct": false
        },
        {
          "answer": "postać normalna Boyce'a-Codda.",
          "correct": false
        }
      ]
    },
    {
      "question": "Dany jest schemat relacyjny R={Miasto, Ulica, Kod}, F = {Miasto,Ulica-&gt;Kod}. W której postaci normalnej jest ten schemat:",
      "id": 679,
      "comments": [
        {
          "author": "~anon@89.74.*.*",
          "comment": "ja bym nie dał D, bo zarówno Miasto jak i Ulica mogą być kluczem, trzeba na dweie tabele to zrobić",
          "date": "22-01-2017 23:16:42"
        },
        {
          "author": "~anon@89.64.*.*",
          "comment": "+up",
          "date": "02-02-2019 22:33:01"
        },
        {
          "author": "~anon@5.173.*.*",
          "comment": "Miasto i Ulica tworzą razem klucz. Bez jednego nie da się określić drugiego, a razem pozwalają określić Kod. Odpowiedzi są prawidłowe.",
          "date": "30-01-2020 10:20:57"
        }
      ],
      "answers": [
        {
          "answer": "I postać normalna;",
          "correct": true
        },
        {
          "answer": "II postać normalna,",
          "correct": true
        },
        {
          "answer": "III postać normalna,",
          "correct": true
        },
        {
          "answer": "postać normalna Boyce'a-Codda.",
          "correct": true
        }
      ]
    },
    {
      "question": "Dany jest schemat relacyjny R={Ulica, Kod, Sklep}, F = {Ulica-&gt;Kod; Sklep-&gt;Ulica}. W której postaci normalnej jest ten schemat:",
      "id": 680,
      "comments": null,
      "answers": [
        {
          "answer": "I postać normalna;",
          "correct": true
        },
        {
          "answer": "II postać normalna,",
          "correct": true
        },
        {
          "answer": "III postać normalna,",
          "correct": false
        },
        {
          "answer": "postać normalna Boyce'a-Codda.",
          "correct": false
        }
      ]
    },
    {
      "question": "Dany jest schemat relacyjny R={Ulica, Kod, Sklep}, F = {Ulica-&gt;Kod; Ulica, Numer -&gt;Sklep}. W której postaci normalnej jest ten schemat:",
      "id": 681,
      "comments": [
        {
          "author": "~Anon@5.173.*.*",
          "comment": "Wszystkie są błędne bo numeru nie ma w relacji",
          "date": "08-02-2019 00:28:23"
        },
        {
          "author": "~anon@212.2.*.*",
          "comment": "A to nie jest lietrówka? numer nie jest kodem?",
          "date": "13-02-2019 16:08:08"
        },
        {
          "author": "~polakrodak@79.184.*.*",
          "comment": "Uważam, że tutaj nic nie będzie. Dlaczego? W teście z przedmiotu RBD również jest to pytanie, tylko z odpowiedziami czy jest w 3 postaci normalnej i BC postaci. Jest tam zaznaczone, że nie. Ewentualnie zawsze można dopytać prowadzącej czy nei wkradł się bład i powinno tutaj być Numer. Oczywiście jak traficie, że będzie w waszej sali bo ostatnio to wszyscy mieli na 12 do jednej sali XDDD Otworzyła w końcu dwie dodatkowe ale i tak beka. Organizacja gówniana",
          "date": "16-02-2019 19:35:32"
        }
      ],
      "answers": [
        {
          "answer": "I postać normalna;",
          "correct": true
        },
        {
          "answer": "II postać normalna,",
          "correct": false
        },
        {
          "answer": "III postać normalna,",
          "correct": false
        },
        {
          "answer": "postać normalna Boyce'a-Codda.",
          "correct": false
        }
      ]
    },
    {
      "question": "Dany jest schemat relacyjny R={Student,Adres,Akademik}, F = {Student-&gt;Adres; Akademik-&gt;Adres;          Student-&gt;Akademik}. W której postaci normalnej jest ten schemat:",
      "id": 682,
      "comments": null,
      "answers": [
        {
          "answer": "I postać normalna;",
          "correct": true
        },
        {
          "answer": "II postać normalna,",
          "correct": true
        },
        {
          "answer": "III postać normalna,",
          "correct": false
        },
        {
          "answer": "postać normalna Boyce'a-Codda.",
          "correct": false
        }
      ]
    },
    {
      "question": "Dany jest schemat relacyjny R={Student,Uczelnia,Adres,Klub}, F = {Student-&gt;Uczelnia; Klub-&gt;Adres}. W której postaci normalnej jest ten schemat:",
      "id": 683,
      "comments": [
        {
          "author": "~anon@89.64.*.*",
          "comment": "oj wydaję mi się że wszystkie są poprawne",
          "date": "03-02-2019 17:52:59"
        },
        {
          "author": "~anon@5.173.*.*",
          "comment": "To źle Ci się wydaje. Kluczem jest para {Student, Klub}, ale że są zależności częściowe (z lewej strony funkcji jest tylko część klucza), to nie jest spełniona nawet zasada II postaci normalnej.",
          "date": "30-01-2020 10:26:34"
        }
      ],
      "answers": [
        {
          "answer": "I postać normalna;",
          "correct": true
        },
        {
          "answer": "II postać normalna,",
          "correct": false
        },
        {
          "answer": "III postać normalna,",
          "correct": false
        },
        {
          "answer": "postać normalna Boyce'a-Codda.",
          "correct": false
        }
      ]
    },
    {
      "question": "Dany jest schemat relacyjny R={Student,Uczelnia,Adres,Klub}, F = {Student-&gt;Uczelnia; Klub-&gt;Adres;Uczelnia-&gt;Adres}. W której postaci normalnej jest ten schemat:",
      "id": 684,
      "comments": null,
      "answers": [
        {
          "answer": "I postać normalna;",
          "correct": true
        },
        {
          "answer": "II postać normalna,",
          "correct": false
        },
        {
          "answer": "III postać normalna,",
          "correct": false
        },
        {
          "answer": "postać normalna Boyce'a-Codda.",
          "correct": false
        }
      ]
    },
    {
      "question": "Dany jest schemat relacyjny R={Student,Uczelnia,Adres,Akademik}, F = {Student, Uczelnia-&gt;Klub; Klub-&gt;Adres}. W której postaci normalnej jest ten schemat:",
      "id": 685,
      "comments": [
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Pytanie jest błędne. W R pojawia się Akademik, a w F Klub. Gdy w F podmienimy Klub na Akademik, wtedy odpowiedzi są prawidłowe.",
          "date": "02-02-2013 16:08:57"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "Masz racje Wąsky, ale wydaje mi się, że intencja jest jasna :P",
          "date": "06-09-2014 14:34:57"
        }
      ],
      "answers": [
        {
          "answer": "I postać normalna;",
          "correct": true
        },
        {
          "answer": "II postać normalna,",
          "correct": true
        },
        {
          "answer": "III postać normalna,",
          "correct": false
        },
        {
          "answer": "postać normalna Boyce'a-Codda.",
          "correct": false
        }
      ]
    },
    {
      "question": "Studenci mają pomysły. Każdy pomysł dotyczy pewnej rzeczy. Każdy pomysł przychodzi do głowy dokładnie jednemu studentowi. Student może się podzielić pomysłem z kolegami-studentami. Który ze schematów jest najodpowiedniejszy z punktu widzenia zasad projektowania baz danych:",
      "id": 686,
      "comments": null,
      "answers": [
        {
          "answer": "Studenci(id_studenta, imię, nazwisko, adres, id_pomysłu)<br>Pomysły(id_pomysłu, rzecz, opis)<br>Koledzy(id_kolegi, imię, nazwisko, id_studenta, id_pomysłu)",
          "correct": false
        },
        {
          "answer": "Studenci(id_studenta, imię, nazwisko, adres, id_kolegi)<br>Pomysły(id_pomysłu, rzecz, opis, id_studenta)<br>Koledzy(id_kolegi, imię, nazwisko, id_studenta, id_pomysłu)",
          "correct": false
        },
        {
          "answer": "Studenci(id_studenta, imię, nazwisko, adres)<br>Pomysły(id_pomysłu, rzecz, opis, id_studenta)<br>Koledzy(id_pomysłu, id_kolegi)",
          "correct": true
        },
        {
          "answer": "Studenci(id_studenta, imię, nazwisko, adres)<br>Pomysły(id_pomysłu, rzecz, opis, id_studenta, id_kolegi)",
          "correct": false
        }
      ]
    },
    {
      "question": "Studenci lubią się, są sobie obojętni lub nie znoszą się (nie ma innej możliwości). Który ze schematów jest najodpowiedniejszy z punktu widzenia zasad projektowania baz danych :",
      "id": 687,
      "comments": [
        {
          "author": "~alex@89.67.*.*",
          "comment": "Studenci lubią się, są sobie obojętni lub nie znoszą się -  z tego wychodzi ze poprawna tylko 3 odpowiedz, a nie czwarta",
          "date": "06-09-2014 14:03:26"
        },
        {
          "author": "~Adas@79.188.*.*",
          "comment": "Ja tak myślę: jeżeli musi być jedno z trzech, a nie ma ani 1, ani 2, to musi być 3. Brak informacji w tym wypadku też jest informacją.",
          "date": "06-09-2014 14:20:46"
        }
      ],
      "answers": [
        {
          "answer": "Studenci(id_studenta, imię, nazwisko)<br>Koledzy(id_kolegi, imię, nazwisko, id_studenta, id_stosunku_do)<br>Stosunek(id_stosunku_do, stosunek_do)",
          "correct": false
        },
        {
          "answer": "Studenci(id_studenta, imię, nazwisko)<br>Koledzy(id_kolegi, imię, nazwisko, id_studenta, stosunek_do)",
          "correct": false
        },
        {
          "answer": "Studenci(id_studenta, imię, nazwisko)<br>Lubi(id_studenta, id_kolegi)<br>Nie_znosi(id_studenta, id_kolegi)<br>Obojętny(id_studenta, id_kolegi)",
          "correct": false
        },
        {
          "answer": "Studenci(id_studenta, imię, nazwisko)<br>Lubi(id_studenta, id_kolegi)<br>Nie_znosi(id_studenta, id_kolegi)",
          "correct": true
        }
      ]
    },
    {
      "question": "W domach mieszkają zwierzęta domowe. Niektóre zwierzęta zjadają się wzajemnie. Domy mogą być położone obok siebie. Jaki schemat zgodny z zasadami projektowania schematów baz danych jest najodpowiedniejszy dla organizacji zajmującej się ochroną zwierząt:",
      "id": 688,
      "comments": null,
      "answers": [
        {
          "answer": "Domy(id_domu, adres, id_zwierzę)<br>Zwierzęta(id_zwierzę, rodzaj, id_zw_zjadane)",
          "correct": false
        },
        {
          "answer": "Domy(id_domu, adres) <br>Zwierzęta(id_zwierzę, id_rodzaju, id_domu) <br>Rodzaje(id_rodzaju, rodzaj)<br>Obok_siebie(id_domu1, id_domu2) <br>Zjada(id_rodz_je, id_rodz_zjadane)",
          "correct": true
        },
        {
          "answer": "Domy(id_domu, adres)<br>Zwierzęta(id_zwierzę, id_rodzaju, id_domu) <br>Rodzaje(id_rodzaju, rodzaj)<br>Sąsiedzi(id_zwierzę1, id_zwierzę2)<br>Zjada(id_rodz_je, id_rodz_zjadane)",
          "correct": false
        },
        {
          "answer": "Domy(id_domu, adres, id_zwierzę, rodzaj)<br>Obok_siebie(id_domu1, id_domu2)<br>Zjada(id_zw_je, id_zw_zjadane)",
          "correct": false
        }
      ]
    },
    {
      "question": "W filmach grają aktorzy. Każdy film ma dokładnie jednego reżysera i jednego lub więcej scenarzystę. Który z poniższych schematów jest najodpowiedniejszy z punktu widzenia zasad projektowania baz danych:",
      "id": 689,
      "comments": [
        {
          "author": "~daniel@31.11.*.*",
          "comment": "wydaje mi się że powinna być odpowiedź A, bo po co nam Osoby, skoro nie sa nigdzie uzywane?",
          "date": "29-06-2014 16:39:46"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "imho B jest złą odpowiedzią - każdy aktor i scenarzysta mogą być uczestnikami tylko jednego filmu?\n\n\"A\" jest źle bo Film ma reżysera opisanego kolumną \"reżyser\" która poprawnie go nie opisuje.\n\nJak dla mnie C jest najbliżej bycia poprawną odpowiedzią, gdyby kolumna \"rola\" byłą wyniesiona do oddzielnej tabeli słownikowej.",
          "date": "06-09-2014 15:20:10"
        },
        {
          "author": "~anon@88.156.*.*",
          "comment": "@UP Dokładnie to samo pomyślałem",
          "date": "28-01-2016 23:27:30"
        },
        {
          "author": "mykhi",
          "comment": "zmieniam z B na A",
          "date": "29-01-2016 09:05:14"
        },
        {
          "author": "~anon@83.6.*.*",
          "comment": "Moim zdaniem B było poprawne, bo teraz jest redundancja nazwiska aktora. Będzie różne id_aktora dla tego samego aktora tyko w różnych filmach.",
          "date": "08-02-2016 02:46:15"
        }
      ],
      "answers": [
        {
          "answer": "Filmy(id_filmu, tytuł, reżyser, gaża_reżysera)<br>Aktorzy(id_aktora, nazwisko,rola, id_filmu, gaża)<br>Scenarzyści(id_scenarzysty, nazwisko, id_filmu, gaża)",
          "correct": true
        },
        {
          "answer": "Filmy(id_filmu, tytuł, id_reżysera, gaża_reżysera)<br>Osoby(id_osoby, nazwisko)<br>Aktorzy(id_aktora, id_filmu, rola, gaża)<br>Scenarzyści(id_scenarzysty, id_filmu, gaża)",
          "correct": false
        },
        {
          "answer": "Filmy(id_filmu, tytuł, id_reżysera)<br>Osoby(id_osoby, nazwisko)<br>Zespół(id_osoby, id_filmu, rola, gaża)",
          "correct": false
        },
        {
          "answer": "Zespół(tytuł_filmu, nazwisko_osoby, rola, gaża)",
          "correct": false
        }
      ]
    },
    {
      "question": "Politycy należą do partii politycznych (czasami je zmieniają, czasami dokonują ich podziału). Partie polityczne, przed wyborami, tworzą koalicje wyborcze.  Który z poniższych schematów jest najodpowiedniejszy z punktu widzenia zasad projektowania baz danych:",
      "id": 690,
      "comments": null,
      "answers": [
        {
          "answer": "Politycy(id_polityka, imię, nazwisko)<br>Partie(id_partii, nazwa, od, do)<br>Koalicje(id_koalicji,  data_wyborów)<br>Członkowie(id_partii, id_osoby, od, do)<br>W_koalicji(id_partii, id_koalicji, od, do)",
          "correct": true
        },
        {
          "answer": "Osoby(id_osoby, imię, nazwisko, id_partii)<br>Partie(id_partii, nazwa, id_koalicji)<br>Politycy(id_osoby, id_partii, od, do)<br>Koalicje(id_koalicji, data_wyborów)",
          "correct": false
        },
        {
          "answer": "Partie(id_partii, nazwa, koalicja, polityk, od, do)",
          "correct": false
        },
        {
          "answer": "Politycy(id_polityka, imię, nazwisko, id_partii, od, do)<br>Partie(id_partii, nazwa, od, do)<br>Koalicje(id_koalicji,  data_wyborów)<br>W_koalicji(id_partii, id_koalicji, od, do)",
          "correct": false
        }
      ]
    },
    {
      "question": "Studenci planują, czym chcieliby się zajmować w swojej przyszłej pracy zawodowej i jakie stanowiska chcieliby pełnić. Który z poniższych schematów jest najodpowiedniejszy z punktu widzenia zasad projektowania baz danych:",
      "id": 691,
      "comments": [
        {
          "author": "~joł@89.70.*.*",
          "comment": "Jeżeli B jest poprawna, to jak odróżnię jakiego zajęcia tyczy się dane stanowisko, jeśli student poda kilka zajęć i stanowisk?",
          "date": "20-08-2017 21:46:37"
        },
        {
          "author": "~anon@195.8.*.*",
          "comment": "No własnie może określić że chce być sprzedawcą (stanowisko) w branży turystycznej lub motoryzacyjnej (zajęcie), odwrotnie może też stwierdzić ze chce być kierownikiem lub właścicielem w branży motoryzacyjnej.",
          "date": "10-02-2020 11:29:42"
        }
      ],
      "answers": [
        {
          "answer": "Studenci(id_studenta, imię, nazwisko)<br>Zajęcia(id_zajęcia, nazwa)<br>Stanowiska(id_stanowiska, nazwa)<br>Kto_co(id_studenta, id_stanowiska, id_zajęcia)",
          "correct": false
        },
        {
          "answer": "Studenci(id_studenta, imię, nazwisko, rok)<br>Zajęcia(id_zajęcia, nazwa)<br>Stanowiska(id_stanowiska, nazwa)<br>Jakie_zajęcie(id_studenta, id_zajęcia)<br>Jakie_stanowisko(id_studenta, id_stanowiska)",
          "correct": true
        },
        {
          "answer": "Studenci(imię, nazwisko, rok, zajęcie, stanowisko)",
          "correct": false
        },
        {
          "answer": "Studenci(id_studenta, imię, nazwisko,rok)<br>Kto_co(id_studenta, stanowisko, zajęcie)",
          "correct": false
        }
      ]
    },
    {
      "question": "W PJWSTK ma powstać baza danych zbierająca informacje o umiejętnościach przydatnych w pracy zawodowej, o przedmiotach, które uczą tych umiejętności oraz o książkach, w których umiejętności są opisane. Który z poniższych schematów jest najodpowiedniejszy z punktu widzenia zasad projektowania baz danych:",
      "id": 692,
      "comments": [
        {
          "author": "~morawa@178.36.*.*",
          "comment": "Poprawna odpowieź to chyba : \nPrzedmioty(id_przedmiotu, nazwa, semestr)\nKsiążki(ISBN, tytuł, autorzy)\nUmiejętności(id_umiejętności, id_przedmiotu, nazwa, opis, ISBN, od_strony, do_strony)\n?",
          "date": "04-02-2013 19:20:08"
        },
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Nie. Gdyby poprawna była odpowiedź 2, to by oznaczało, że dana umiejętność może być opisana tylko w jednej książce.",
          "date": "04-02-2013 20:02:13"
        }
      ],
      "answers": [
        {
          "answer": "Umiejętności(umiejętność, przedmiot, książka)",
          "correct": false
        },
        {
          "answer": "Przedmioty(id_przedmiotu, nazwa, semestr)<br>Książki(ISBN, tytuł, autorzy)<br>Umiejętności(id_umiejętności, id_przedmiotu, nazwa, opis, ISBN, od_strony, do_strony)",
          "correct": false
        },
        {
          "answer": "Przedmioty(id_przedmiotu, nazwa, semestr)<br>Książki(ISBN, tytuł, sygnatura)<br>Umiejętności(id_umiejętności, nazwa, opis)<br>Gdzie(id_umiejętności, ISBN, od_strony, do_strony)<br>Na(id_umiejętności, id_przedmiotu)",
          "correct": true
        },
        {
          "answer": "Przedmioty(id_przedmiotu, nazwa, semestr)<br>Egzemplarze_książek(sygnatura, tytuł, autorzy, nr_półki)<br>Umiejętności(id_umiejętności, nazwa, opis)<br>Gdzie(id_umiejętności, sygnatura, od_strony, do_strony)",
          "correct": false
        }
      ]
    },
    {
      "question": "W PJWSTK powstaje baza danych z informacjami, jakie oprogramowanie jest zainstalowane w poszczególnych salach - z myślą o prowadzeniu w nich ćwiczeń z odpowiednich przedmiotów. Który z poniższych schematów jest najodpowiedniejszy z punktu widzenia zasad projektowania baz danych:",
      "id": 693,
      "comments": [
        {
          "author": "~kelu@84.10.*.*",
          "comment": "W poprawnej odpowiedzi brakuje mi trochę tabeli z Salami, co sądzicie? ten id_sali nie odnosi się do niczego w sumie",
          "date": "06-09-2014 13:51:22"
        },
        {
          "author": "~Adas@79.188.*.*",
          "comment": "Mmm... \"Salami\".\nJa sądzę, że numer sali w zupełności wystarczy do określenia jej i nie widzę potrzeby robienia jeszcze jednej tabeli. Przy zmianach też nie wydaje mi się, żeby prowadziło to do jakichś niespójności.\nSłowem, sala 105 to sala 105.",
          "date": "06-09-2014 14:05:16"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "Zasadniczo zgadzam się, ale co jeśli sala zmieni numer? Wtedy można zapomnieć o aktualizacji wszystkich numerów przykładowo",
          "date": "06-09-2014 15:01:25"
        },
        {
          "author": "~anon@31.0.*.*",
          "comment": "Ja bym powiedział że 4. poprawne",
          "date": "08-02-2019 01:37:00"
        },
        {
          "author": "~noah@89.64.*.*",
          "comment": "jak dla mnie 4 poprawnie. 2 odpowiedzi prowadzi to do problemu opisanego w komentarzu wyżej. Podczas zmiany numeru sali możemy przeoczyć jakiś rekord. A tak to zmieniamy w jednej tabeli nazwa/numer sali i po kłopocie.",
          "date": "10-02-2019 09:58:55"
        }
      ],
      "answers": [
        {
          "answer": "Sale(numer_sali, nazwa_programu, wersja, ile_instalacji)<br>Programy(nazwa_programu, wersja, nazwa_przedmiotu)",
          "correct": false
        },
        {
          "answer": "Programy(id_programu, firma, nazwa, wersja)<br>Przedmioty(id_przedmiotu, nazwa)<br>Sale_programy(nr_sali, id_programu,  ile_instalacji)<br>Przedmioty_programy(id_przedmiotu, id_programu)",
          "correct": true
        },
        {
          "answer": "Programy(id_programu, firma, nazwa, wersja, nazwa_przedmiotu)<br>Sale_programy(nr_sali, id_programu, wersja, ile_instalacji)",
          "correct": false
        },
        {
          "answer": "Sale(id_sali, numer, ile_komputerów)<br>Programy(id_programu, firma, nazwa, wersja)<br>Przedmioty(id_przedmiotu, nazwa)<br>Sale_programy(id_sali, id_programu, wersja, ile_instalacji)<br>Przedmioty_programy(id_przedmiotu, id_programu, wersja)",
          "correct": false
        }
      ]
    },
    {
      "question": "Który ze schematów bazy danych dla biblioteki jest najodpowiedniejszy z punktu widzenia zasad projektowania baz danych. Baza powinna przechowywać informacje o klientach, książkach i wypożyczeniach (wielkie litery oznaczają klucz główny):",
      "id": 694,
      "comments": [
        {
          "author": "~nick@83.5.*.*",
          "comment": "Przecież wszystkie odpowiedzi są takie same",
          "date": "01-02-2013 17:33:26"
        },
        {
          "author": "mykhi",
          "comment": "nie są... masz w pytaniu: wielkie litery oznaczają klucz główny",
          "date": "01-02-2013 21:02:59"
        },
        {
          "author": "~piotr@89.79.*.*",
          "comment": "Żadna. Z punktu widzenia projektowania baz danych nie daje się kluczy złożonych a już w szczególności kiedy jednym z elementów takiego klucza jest pole typu \"date\". W tabeli Wypożyczenie powinien być po prostu Id_wypożyczenia jak klucz główny i 2 klucze obce do Klienta i Książki.",
          "date": "03-02-2013 14:06:05"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "Piotrze, masz racje, że mogłaby być taka odpowiedź jaką proponujesz, ale nie masz racji, że z punktu widzenia projektowania baz danych nie daje się kluczy złożonych. Właśnie pole date gwarantuje nam tutaj najodpowiedniejszy schemat bazy danych. Było to wielokrotnie wałkowane na wykładach i zajęciach, a nawet na rozmowach kwalifikacyjnych spotkałem się z takim schematem i jest on jak najbardziej poprawny i właściwy.",
          "date": "07-09-2014 10:12:32"
        },
        {
          "author": "~joł@89.70.*.*",
          "comment": "A czy może ktoś wyjaśnić czemu nie D?\nJeśli student jednak zdecyduje się, że jednak chce książkę, to pani powie, żeby przyszedł jutro, bo baza danych tego nie ogarnie?",
          "date": "23-08-2017 22:32:45"
        },
        {
          "author": "~petenshi@37.47.*.*",
          "comment": "^Up ostatnie odpada z prostego powodu, student mógłby wypożyczyć dokładnie tą samą książkę w różne dni jednocześnie przy jednej dacie zwrotu, albo wypożyczyć tą samą książkę kilka razy w różne dni i musieć oddać ją jednego dnia.",
          "date": "31-01-2018 19:39:33"
        },
        {
          "author": "~dorota.m@178.42.*.*",
          "comment": "ostatnie jest dobrze, @petenshi nie wprowadzaj w blad\n",
          "date": "31-01-2018 21:17:16"
        },
        {
          "author": "~mistrz sql@159.205.*.*",
          "comment": "ostatnie jest chyba dobrze bo zależność funkcyjna odpowiada kluczowi głównemu\n",
          "date": "31-01-2018 21:58:16"
        },
        {
          "author": "~sql100@89.64.*.*",
          "comment": "@penetshi czytałeś w ogóle wykłady? d jest prawidłowe",
          "date": "31-01-2018 22:27:18"
        },
        {
          "author": "~Rajard@188.146.*.*",
          "comment": "Nie jest prawidłowe z jednego prostego powodu. Na logikę Data zwrotu pierwotnie ma wartość null póki książka nie wróci do biblioteki, ergo nie może być kluczem głównym.",
          "date": "07-02-2018 12:03:32"
        },
        {
          "author": "~kogut@109.206.*.*",
          "comment": "nie rozumiem, przeciez klucz glowny w tabeli moze byc tylko jeden , ???",
          "date": "05-07-2018 21:35:22"
        },
        {
          "author": "~viper@89.73.*.*",
          "comment": "@kogut tak, ale może być kluczem złożonym",
          "date": "06-07-2018 21:25:21"
        },
        {
          "author": "~anon@109.241.*.*",
          "comment": "Tym tokiem myślenia data wypozyczenia nie powina byc w kluczu złozonym bo ksiązka mogła nigdy nie byc wypozyczona :)\n***********************\ncyt. \"Nie jest prawidłowe z jednego prostego powodu. Na logikę Data zwrotu pierwotnie ma wartość null póki książka nie wróci do biblioteki, ergo nie może być kluczem głównym.|",
          "date": "31-08-2018 00:33:56"
        },
        {
          "author": "~OCB@5.173.*.*",
          "comment": "A wiec?",
          "date": "07-02-2019 18:19:21"
        },
        {
          "author": "~anon@46.112.*.*",
          "comment": "A więc C jest prawdą, gdyż jeżeli ksziążka nie jest wypożyczana - ona po prostu nigdy nie będzie dodana do tabeli \"Wypożyczenie\". I jak dobrze zauważyli koledzy, data_zwrotu zależy od faktycznej daty, a nie teoretycznej",
          "date": "07-02-2019 22:23:00"
        }
      ],
      "answers": [
        {
          "answer": "Klient(ID_KLIENTA, imię, nazwisko, adres)<br>Książka(ID_KSIąŻKI, tytuł, autor)<br>Wypożyczenie(ID_KLIENTA, id_książki, data_wypożyczenia, data_zwrotu)",
          "correct": false
        },
        {
          "answer": "Klient(ID_KLIENTA, imię, nazwisko, adres)<br>Książka(ID_KSIąŻKI, tytuł, autor)<br>Wypożyczenie(ID_KLIENTA, ID_KSIąŻKI, data_wypożyczenia, data_zwrotu)",
          "correct": false
        },
        {
          "answer": "Klient(ID_KLIENTA, imię, nazwisko, adres)<br>Książka(ID_KSIąŻKI, tytuł, autor)<br>Wypożyczenie(ID_KLIENTA, ID_KSIąŻKI, DATA_WYPOŻYCZENIA, data_zwrotu)",
          "correct": true
        },
        {
          "answer": "Klient(ID_KLIENTA, imię, nazwisko, adres)<br>Książka(ID_KSIąŻKI, tytuł, autor)<br>Wypożyczenie(ID_KLIENTA, ID_KSIąŻKI, DATA_WYPOŻYCZENIA, DATA_ZWROTU)",
          "correct": false
        }
      ]
    },
    {
      "question": "Potrzebna jest baza danych do ewidencji studentów i ich ocen. Który ze schematów bazy danych jest najodpowiedniejszy z punktu widzenia zasad projektowania baz danych:",
      "id": 695,
      "comments": [
        {
          "author": "~niepewny@178.42.*.*",
          "comment": "Na pewno dobrze ? Wydaje mi się że w Encji STUDENT powinno być ID_Oceny, a nie w OCENIE id_studenta. ",
          "date": "29-01-2016 16:17:04"
        },
        {
          "author": "~anon@81.15.*.*",
          "comment": "zgadzam się z przedmówcą czemu w ocenie miała by się pojawić wartość idStudenta. Nie ma to kompletnego sensu. Jak dla mnie to III jest poprawne. ",
          "date": "30-01-2016 17:20:41"
        },
        {
          "author": "~abc@178.235.*.*",
          "comment": "Gdyby w tabeli Student było by ID_Oceny to każdy student mógłby mieć tylko jedną Ocenę.",
          "date": "22-01-2017 22:19:13"
        }
      ],
      "answers": [
        {
          "answer": "Student(id_studenta, imię, nazwisko)<br>Ocena(id_oceny, ocena, data_wystawienia, nazwa_przedmiotu)",
          "correct": false
        },
        {
          "answer": "Student(id_studenta, imię, nazwisko)<br>Ocena(id_oceny, ocena, data_wystawienia, id_przedmiotu, id_studenta)<br>Przedmiot(id_przedmiotu, nazwa)",
          "correct": true
        },
        {
          "answer": "Student(id_studenta, imię, nazwisko, id_oceny)<br>Ocena(id_oceny, ocena, data_wystawienia, id_przedmiotu)<br>Przedmiot(id_przedmiotu, nazwa)",
          "correct": false
        },
        {
          "answer": "Student(id_studenta, imię, nazwisko, ocena)<br>Przedmiot(id_przedmiotu, nazwa, id_studenta)",
          "correct": false
        }
      ]
    },
    {
      "question": "Wiedząc, że tabela TEST ma następującą strukturę:\n<br><br><span>&nbsp; id &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; number(5)</span><br><span>&nbsp; pole1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;varchar2(30)</span><br><span>&nbsp; pole2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;varchar2(30)</span><br><br><span>Zaznacz, które z poniższych wyrażeń są poprawnymi składniowo instrukcjami języka SQL:</span>",
      "id": 1907,
      "comments": [
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Odpowiedź pierwsza jest niepoprawna. Odpowiedź druga jest poprawna, zakładając, że używamy tabeli Emp przedstawionej na wykładach/ćwiczeniach (czyli że empno to NUMBER, ENAME, JOB to VARCHAR2).",
          "date": "06-02-2013 23:44:51"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "no tak mi na tescie bo mialem takie pytanie zaznaczylo ze jest poprawna",
          "date": "06-02-2013 23:51:48"
        },
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Przepraszam, mój błąd. Aktualne odpowiedzi SĄ poprawne.",
          "date": "06-02-2013 23:52:51"
        }
      ],
      "answers": [
        {
          "answer": "INSERT INTO TEST(ID,POLE1,POLE2) SELECT EMPNO,ENAME,JOB FROM EMP;",
          "correct": true
        },
        {
          "answer": "INSERT INTO TEST(ID,POLE1,POLE2) VALUES(SELECT EMPNO,ENAME,JOB FROM EMP);",
          "correct": false
        },
        {
          "answer": "INSERT INTO TEST VALUES(12345, 'KOWALSKI');",
          "correct": false
        }
      ]
    },
    {
      "question": "Chcesz usunąć z bazy wyzwalacz TRG_TEST. Które polecenie zastosujesz?",
      "id": 1906,
      "comments": null,
      "answers": [
        {
          "answer": "DELETE FROM USER_TRIGGERS WHERE TRIGGER_NAME = 'TRG_TEST';",
          "correct": false
        },
        {
          "answer": "DELETE TRIGGER TRG_TEST;",
          "correct": false
        },
        {
          "answer": "REMOVE TRIGGER TRG_TEST;",
          "correct": false
        },
        {
          "answer": "DROP TRIGGER TRG_TEST;",
          "correct": true
        }
      ]
    },
    {
      "question": "Dana jest tabela Osoby(Imie, Nazwisko, Zarobki). Które z następujących instrukcji są składniowo poprawnymi instrukcjami SQL w Oracle:",
      "id": 1905,
      "comments": [
        {
          "author": "mykhi",
          "comment": "turbo kombo złączenia 6 pytań. sprawdźcie czy teraz jest dobrze. no i jak to wygląda jak sie zrobi test (4 przypadkowe odpowiedzi? wszystkie? zawsze pierwsze 4?) bo nie pamiętam jak to zakodowałem!",
          "date": "04-02-2013 23:57:04"
        },
        {
          "author": "~anon@89.68.*.*",
          "comment": "INSERT INTO Osoby SELECT * FROM Osoby WHERE USER = 'KOWALSKI'; to tez jest poprawne skladniowo, sqldev nie protestuje\n\ntak samo: DELETE FROM Osoby WHERE 'JANKOWSKI'='KOWALSKI';",
          "date": "05-02-2013 00:05:24"
        },
        {
          "author": "mykhi",
          "comment": "poprawiłem!",
          "date": "05-02-2013 00:07:34"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "mialem jeszcze i to bylo prawidlowe taka odpowiedz:\nSELECT Osoby.Nazwisko, Osoby.Imie, Osoby.Zarobki FROM Osoby WHERE Osoby.Zarobki >1000",
          "date": "05-02-2013 08:27:47"
        },
        {
          "author": "mykhi",
          "comment": "dodałem.",
          "date": "05-02-2013 10:56:52"
        },
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "SELECT Osoby.Nazwisko, Osoby.Imie, Osoby.Zarobki FROM Osoby GROUP BY Osoby.Nazwisko; - to jest poprawna odpowiedź. Sprawdzone.",
          "date": "06-02-2013 16:01:56"
        },
        {
          "author": "mykhi",
          "comment": "poprawiłem.",
          "date": "06-02-2013 21:51:35"
        },
        {
          "author": "~anon@81.18.*.*",
          "comment": "INSERT INTO Osoby SELECT * FROM Osoby WHERE USER = 'KOWALSKI';\nDELETE FROM Osoby WHERE USER='KOWALSKI';\n\ndlaczego to jest poprawne? czym jest USER ?\n\nps. w tym pytaniu wyswietlone sa wszystkie odpowiedzi, nie tylko 4 przypadkowe.",
          "date": "30-06-2013 12:44:58"
        },
        {
          "author": "~Mezar@87.206.*.*",
          "comment": "SELECT Osoby.Nazwisko, Osoby.Imie, Osoby.Zarobki FROM Osoby GROUP BY Osoby.Nazwisko;\nTo Polecenie wywali błąd: \nORA-00979: to nie jest wyrażenie GROUP BY \nWąsky się pomylił",
          "date": "01-07-2013 01:17:36"
        },
        {
          "author": "~anon@78.133.*.*",
          "comment": "Popieram Mezara, ta odpowiedź jest zdecydowanie błędna, bo wszystkie atrybuty, które znajdują się na liście SELECT muszą pojawić się w klauzuli GROUP BY (i/lub ewentualnie w funkcji agregującej, jeśli występuje), a tu tak nie jest, sqldev wyrzuci błąd.",
          "date": "27-01-2014 16:51:23"
        },
        {
          "author": "mykhi",
          "comment": "Wąsky, ty świnio! Poprawiam.",
          "date": "27-01-2014 17:40:04"
        },
        {
          "author": "~Wąsky@212.180.*.*",
          "comment": "To ja odpowiem tak:\nNa tej stronce można online wykonywać zapytania SQL:\n\nhttp://www.w3schools.com/sql/trysql.asp?filename=trysql_select_all\n\nZmodyfikujmy nasze zapytanie z GROUP BY tak, by dało się wywołać na bazce z powyższego linku:\n\nSELECT Employees.FirstName, Employees.LastName, Employees.EmployeeID FROM Employees GROUP BY Employees.LastName\n\nŻaden błąd się nie wywołuje, wszystko jest poprawnie. Może to jest różnica pomiędzy SQL a Oracle SQL i w przypadku Oracle SQL faktycznie wyrzuci błąd... Tego nie wiem i nie jestem w stanie już sprawdzić.",
          "date": "29-01-2016 13:10:47"
        },
        {
          "author": "~heheszky@194.169.*.*",
          "comment": "WHENEVER .. to mnie rozjebalo :D",
          "date": "31-01-2016 12:41:46"
        },
        {
          "author": "~hejkanaklejka@34.99.*.*",
          "comment": "Whenever, wherever",
          "date": "09-02-2020 21:18:55"
        }
      ],
      "answers": [
        {
          "answer": "UPDATE Osoby WHERE Nazwisko='KOWALSKI';",
          "correct": false
        },
        {
          "answer": "UPDATE Osoby SET Nazwisko=USER;",
          "correct": true
        },
        {
          "answer": "SELECT Osoby.Nazwisko, Osoby.Imie, Osoby.Zarobki WHERE Osoby.Zarobki &gt;1000;",
          "correct": false
        },
        {
          "answer": "SELECT Osoby.Nazwisko, Osoby.Imie, Osoby.Zarobki ORDER BY Osoby.Zarobki;",
          "correct": false
        },
        {
          "answer": "SELECT Osoby.Nazwisko, Osoby.Imie, Osoby.Zarobki HAVING Osoby.Zarobki&gt;1000;",
          "correct": false
        },
        {
          "answer": "SELECT Osoby.Nazwisko, Osoby.Imie, Osoby.Zarobki FROM Osoby HAVING Osoby.Zarobki&gt;1000;",
          "correct": false
        },
        {
          "answer": "SELECT Osoby.Nazwisko, Osoby.Imie, Osoby.Zarobki FROM Osoby GROUP BY Osoby.Nazwisko;",
          "correct": false
        },
        {
          "answer": "INSERT INTO Osoby VALUES ('Jan', 'Kowalski', 2000) WHERE USER = 'KOWALSKI';",
          "correct": false
        },
        {
          "answer": "INSERT INTO Osoby SELECT * FROM Osoby WHERE USER = 'KOWALSKI';",
          "correct": true
        },
        {
          "answer": "INSERT INTO Osoby SELECT * FROM Osoby WHERE Nazwisko = 'KOWALSKI';",
          "correct": true
        },
        {
          "answer": "INSERT INTO Osoby SELECT Nazwisko, Imie FROM Osoby WHERE USER = 'KOWALSKI';",
          "correct": false
        },
        {
          "answer": "DELETE FROM Osoby WHERE USER='KOWALSKI';",
          "correct": true
        },
        {
          "answer": "DELETE FROM Osoby WHERE 'JANKOWSKI'='KOWALSKI';",
          "correct": true
        },
        {
          "answer": "DELETE FROM Osoby WHENEVER Osoby.Zarobki&lt;1000;",
          "correct": false
        },
        {
          "answer": "SELECT Osoby.Nazwisko, Osoby.Imie, Osoby.Zarobki FROM Osoby WHERE Osoby.Zarobki &gt;1000",
          "correct": true
        }
      ]
    },
    {
      "question": "Dane są dwie tabele Osoby(Imie, Nazwisko, Zarobki, Id_działu) oraz Działy(Id_działu, Nazwa). Które z następujących instrukcji są poprawnymi instrukcjami SQL w Oracle:",
      "id": 701,
      "comments": null,
      "answers": [
        {
          "answer": "SELECT Osoby.Nazwisko, Osoby.Imie, Osoby.Id_działu WHERE Działy.Nazwa='PRAWNY';",
          "correct": false
        },
        {
          "answer": "INSERT INTO Osoby(Imie, Nazwisko,Zarobki) VALUES ('Jan', 'Kowalski', 2000);",
          "correct": true
        },
        {
          "answer": "DELETE FROM Osoby WHERE Id_działu=(SELECT Id_działu FROM Działy WHERE Nazwa='BUFET');",
          "correct": true
        },
        {
          "answer": "UPDATE Osoby DELETE Nazwisko=USER;",
          "correct": false
        }
      ]
    },
    {
      "question": "Dane są dwie tabele Osoby(Imie, Nazwisko, Zarobki, Id_działu) oraz Działy(Id_działu, Nazwa). Które z następujących instrukcji są poprawnymi instrukcjami SQL w Oracle:",
      "id": 702,
      "comments": [
        {
          "author": "~lm@83.18.*.*",
          "comment": "Pierwsze nie powinno być poprawne?",
          "date": "06-02-2013 21:32:05"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "Ponawiam pytanie, pierwsza też jest poprawna. ",
          "date": "06-02-2013 21:34:55"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam.",
          "date": "06-02-2013 21:48:39"
        },
        {
          "author": "~gawa@194.181.*.*",
          "comment": "Moim zdaniem pierwsze nie jest poprawne, bo trzeba grupować po wszystkim co znajduje się w select czyli powinno być też po Działy.Nazwa",
          "date": "25-06-2013 08:14:12"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "dokladnie, trzeba grupowac po tym co jest w select. pierwsze jest niepoprawne",
          "date": "26-06-2013 23:52:01"
        },
        {
          "author": "mykhi",
          "comment": "ok, odpoprawiam.",
          "date": "30-06-2013 16:40:10"
        },
        {
          "author": "~anon@95.49.*.*",
          "comment": "No ale ostatnie na pewno nie jest poprawne, bo niby, który wiersz zmieniamy? Nie ma warunku WHERE. ",
          "date": "01-09-2013 22:47:53"
        },
        {
          "author": "~mimo@89.77.*.*",
          "comment": "pierwsze jest poprawne na 100%, ostatnie też",
          "date": "06-09-2013 22:30:39"
        },
        {
          "author": "~emo9@89.73.*.*",
          "comment": "anon - zmieniamy KAŻDY w takim przypadku",
          "date": "07-09-2013 20:53:46"
        },
        {
          "author": "~ehhhhhh@162.158.*.*",
          "comment": "pierwsze nie jest poprawne. Jak używa się groupy by to należy zamieścić w nim wszystkie kolumny znajdujące się w select",
          "date": "29-06-2019 19:42:48"
        }
      ],
      "answers": [
        {
          "answer": "SELECT Osoby.Nazwisko, Działy.Nazwa FROM Osoby, Działy WHERE Osoby.Id_działu=Działy.Id_działu GROUP BY Osoby.Nazwisko;",
          "correct": false
        },
        {
          "answer": "INSERT INTO Osoby VALUES ('Jan', 'Kowalski', 2000) WHERE Osoby.Id_działu = 23;",
          "correct": false
        },
        {
          "answer": "DELETE FROM Osoby, Działy WHERE Osoby.Nazwisko='KOWALSKI' AND Działy.Nazwa='KASA';",
          "correct": false
        },
        {
          "answer": "UPDATE Osoby SET Id_działu=NULL;",
          "correct": true
        }
      ]
    },
    {
      "question": "Dane są dwie tabele Osoby(Imie, Nazwisko, Zarobki, Id_działu) oraz Działy(Id_działu, Nazwa). Które z następujących instrukcji są poprawnymi instrukcjami SQL w Oracle:",
      "id": 703,
      "comments": [
        {
          "author": "~ja@89.75.*.*",
          "comment": "Po WHERE nie można użyć COUNT, dokładny błąd to \\\"funkcja grupowa nie jest tutaj dozwolona\\\"",
          "date": "05-02-2012 15:24:48"
        },
        {
          "author": "~anon@89.68.*.*",
          "comment": "dokladnie, przetestowane sqldeveloperem \"group function is not allowed here\"",
          "date": "04-02-2013 23:57:50"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam.",
          "date": "04-02-2013 23:58:40"
        }
      ],
      "answers": [
        {
          "answer": "SELECT Osoby.Nazwisko, COUNT(Działy.Nazwa) FROM Osoby, Działy WHERE Osoby.Id_działu=Działy.Id_działu GROUP BY Osoby.Nazwisko;",
          "correct": true
        },
        {
          "answer": "INSERT INTO Osoby VALUES ('Jan', 'Kowalski', 2000) WHERE Osoby.Id_działu = 23;",
          "correct": false
        },
        {
          "answer": "DELETE FROM Osoby, Działy WHERE Osoby.Nazwisko='KOWALSKI' AND Działy.Nazwa='KASA' AND Osoby.Id_działu=Działy.Id_działu;",
          "correct": false
        },
        {
          "answer": "UPDATE Osoby SET Id_działu=NULL WHERE COUNT(*)&lt;5;",
          "correct": false
        }
      ]
    },
    {
      "question": "Dane są dwie tabele Osoby(Imie, Nazwisko, Zarobki, Id_działu) oraz Działy(Id_działu, Nazwa). Które z następujących instrukcji są poprawnymi instrukcjami SQL w Oracle:",
      "id": 704,
      "comments": [
        {
          "author": "~gawa@89.73.*.*",
          "comment": "pierwsze też jest poprawne",
          "date": "28-06-2013 18:21:04"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "nie jest poprawne, przy having count (id_dzialu) zapytanie nie bedzie wiedzialo czy chodzi o id_dzialu osoby czy id_dzialu Działy. ",
          "date": "29-06-2013 16:30:49"
        }
      ],
      "answers": [
        {
          "answer": "SELECT Osoby.Nazwisko, COUNT(Działy.Nazwa) FROM Osoby, Działy WHERE Osoby.Id_działu=Działy.Id_działu GROUP BY Osoby.Nazwisko HAVING COUNT(Id_działu)&lt;2;",
          "correct": false
        },
        {
          "answer": "INSERT INTO Osoby VALUES ('Jan', 'Kowalski', 2000) WHERE Osoby.Id_działu = 23;",
          "correct": false
        },
        {
          "answer": "DELETE FROM Osoby, Działy WHERE Osoby.Nazwisko='KOWALSKI' AND Działy.Nazwa='KASA' AND Osoby.Id_działu=Działy.Id_działu;",
          "correct": false
        },
        {
          "answer": "UPDATE Osoby SET Id_działu=NULL WHERE 5&gt;(SELECT COUNT(*) FROM Działy);",
          "correct": true
        }
      ]
    },
    {
      "question": "Dane są dwie tabele Osoby(Imie, Nazwisko, Zarobki, Id_działu) oraz Działy(Id_działu, Nazwa). Które z następujących instrukcji są poprawnymi instrukcjami SQL w Oracle:",
      "id": 705,
      "comments": [
        {
          "author": "~Beliar91@89.72.*.*",
          "comment": "Można zrobić inserta na 3 polach mimo iż są 4 (klucz obcy może być null), czyli jak dla mnie odp. 2 i 4.",
          "date": "05-02-2012 21:53:22"
        },
        {
          "author": "~anon@89.75.*.*",
          "comment": "Nope, błąd niewystarczająca liczba wartości. Musisz wymienić kolumny, bo bez tego domyślnie przyjęte jest, że są wszystkie w kolejności ich utworzenia.",
          "date": "05-02-2012 22:03:23"
        }
      ],
      "answers": [
        {
          "answer": "SELECT Osoby.Nazwisko, Działy.Nazwa FROM Osoby, Działy WHERE Osoby.Id_działu=Działy.Id_działu GROUP BY Osoby.Nazwisko HAVING COUNT(Działy.Id_działu)&lt;2;",
          "correct": false
        },
        {
          "answer": "INSERT INTO Osoby VALUES ('Jan', 'Kowalski', 2000);",
          "correct": false
        },
        {
          "answer": "DELETE FROM Osoby WHERE Osoby.Nazwisko='KOWALSKI' AND Działy.Id_działu=22;",
          "correct": false
        },
        {
          "answer": "UPDATE Osoby SET Id_działu=NULL WHERE 5&gt;(SELECT COUNT(*) FROM Działy);",
          "correct": true
        }
      ]
    },
    {
      "question": "Dana jest tabela Osoby(imie, nazwisko, zarobki). Które z następujących instrukcji są poprawnymi instrukcjami SQL w Oracle:",
      "id": 706,
      "comments": null,
      "answers": [
        {
          "answer": "SELECT  imie, nazwisko, zarobki FROM osoby UNION SELECT imie, nazwisko FROM osoby;",
          "correct": false
        },
        {
          "answer": "SELECT AVG(zarobki) FROM osoby;",
          "correct": true
        },
        {
          "answer": "SELECT imie, nazwisko FROM osoby WHERE zarobki = MAX(zarobki);",
          "correct": false
        },
        {
          "answer": "SELECT imie, nazwisko FROM osoby HAVING zarobki = MAX(zarobki);",
          "correct": false
        }
      ]
    },
    {
      "question": "Dana jest tabela Osoby(imie, nazwisko, zarobki, id_dzialu). Które z następujących instrukcji są poprawnymi instrukcjami SQL w Oracle:",
      "id": 707,
      "comments": [
        {
          "author": "~ziom@85.222.*.*",
          "comment": "odpowiedz d nie jest poprawna poniewaz do wykonania avg(zarobki) musimy uzyc group by którego tam nie mam",
          "date": "01-02-2015 10:26:56"
        },
        {
          "author": "~anon@37.152.*.*",
          "comment": "D jest poprawne. Group By musiał byś użyć w przypadku, gdy w selekcie byłaby jeszcze inna kolumna nie objęta funkcją agregującą.",
          "date": "01-02-2015 11:16:57"
        }
      ],
      "answers": [
        {
          "answer": "SELECT imie, nazwisko, AVG(zarobki) FROM Osoby GROUP BY id_dzialu;",
          "correct": false
        },
        {
          "answer": "SELECT id_dzialu, AVG(zarobki) FROM Osoby GROUP BY id_dzialu;",
          "correct": true
        },
        {
          "answer": "SELECT id_dzialu, AVG(zarobki) FROM Osoby GROUP BY id_dzialu WHERE AVG(zarobki) &gt; 1000;",
          "correct": false
        },
        {
          "answer": "SELECT AVG(zarobki) from Osoby WHERE zarobki &gt; 1000;",
          "correct": true
        }
      ]
    },
    {
      "question": "Dana jest tabela Osoby(imie, nazwisko, zarobki). Które z następujących instrukcji są poprawnymi instrukcjami SQL w Oracle:",
      "id": 708,
      "comments": null,
      "answers": [
        {
          "answer": "INSERT INTO Osoby (imie, nazwisko, zarobki) VALUES ('Jan', 'Kowalski', 1000);",
          "correct": true
        },
        {
          "answer": "INSERT INTO Osoby VALUES ('Jan', 'Kowalski');",
          "correct": false
        },
        {
          "answer": "DELETE FROM Osoby WHERE Nazwisko LIKE 'Kowalski';",
          "correct": true
        },
        {
          "answer": "UPDATE Osoby.Nazwisko = 'Kowalski';",
          "correct": false
        }
      ]
    },
    {
      "question": "Wskazać poprawne zapytanie SQL znajdujące pracowników zarabiających minimalną pensję na ich stanowiskach pracy.",
      "id": 709,
      "comments": [
        {
          "author": "~anon@89.67.*.*",
          "comment": "Ja jeszcze mialem taka poprawna odpowiedz do tego pytania : \nSELECT ename, job, sal FROM emp e WHERE sal = (SELECT MIN(sal)FROM emp WHERE job = e.job);",
          "date": "05-02-2013 09:20:41"
        },
        {
          "author": "mykhi",
          "comment": "dodałem.",
          "date": "05-02-2013 11:05:47"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "Czy aby zapytanie z operatorem IN jest prawidlowe?\n\nWzorzec jest taki\n\nSELECT column_name \nFROM derived_table \nWHERE column_name [NOT] IN ('value1', 'value2', ... ,'value_n')\n\nI gdy chce wykonac zapytanie z dwoma wartosciami z where np where(sal,job) otrzymuje blad skladniowy przy \",\"",
          "date": "27-06-2013 16:58:16"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "jest poprawne na oracle.",
          "date": "28-06-2013 12:01:49"
        },
        {
          "author": "~anon@81.18.*.*",
          "comment": "powtórzona odpowiedź:\nSELECT ename, job, sal FROM emp e WHERE sal = (SELECT MIN(sal) FROM emp WHERE job = e.job);",
          "date": "30-06-2013 12:47:22"
        },
        {
          "author": "mykhi",
          "comment": "fix'd",
          "date": "30-06-2013 16:44:27"
        }
      ],
      "answers": [
        {
          "answer": "SELECT ename, job, sal FROM emp e WHERE sal = (SELECT MIN(sal)FROM emp WHERE job = e.job);",
          "correct": true
        },
        {
          "answer": "SELECT ename, job, sal FROM emp WHERE( sal,job) in (SELECT MIN(sal),job FROM emp GROUP BY job );",
          "correct": true
        },
        {
          "answer": "SELECT ename, job, sal FROM emp  WHERE sal = (SELECT MIN(sal)FROM emp GROUP BY job );",
          "correct": false
        },
        {
          "answer": "SELECT ename, job, MIN(sal) FROM emp GROUP BY job;",
          "correct": false
        },
        {
          "answer": "",
          "correct": false
        }
      ]
    },
    {
      "question": "Wskazać poprawne zapytanie SQL znajdujące dla każdego departamentu ostatnio zatrudnionych pracowników.",
      "id": 710,
      "comments": [
        {
          "author": "~Mezar@87.206.*.*",
          "comment": "WHERE (hiredate,) Tutaj jest błąd w drugiej odpowiedzi. Przecinka w nawiasie nie powinno być. A jeżeli jest to odp jest nie prawidłowa",
          "date": "30-06-2013 23:57:07"
        },
        {
          "author": "~anon@94.254.*.*",
          "comment": "No i czy tabela w podzapytaniu nie powinna zostać jakos nazwana i odwoływana przez tą nazwę? ",
          "date": "29-01-2016 17:35:00"
        }
      ],
      "answers": [
        {
          "answer": "SELECT deptno, ename, hiredate FROM emp WHERE (hiredate, deptno) IN (SELECT MAX(hiredate), deptno FROM emp GROUP BY deptno);",
          "correct": true
        },
        {
          "answer": "SELECT deptno, ename, hiredate FROM emp e WHERE (hiredate,) = (SELECT MAX(hiredate) FROM emp WHERE  deptno=e.deptno GROUP BY deptno);",
          "correct": true
        },
        {
          "answer": "SELECT deptno, ename, hiredate FROM emp WHERE hiredate = (SELECT MAX(hiredate) FROM emp GROUP BY deptno);",
          "correct": false
        },
        {
          "answer": "SELECT deptno, ename, MAX(hiredate)  FROM emp GROUP BY deptno;",
          "correct": false
        }
      ]
    },
    {
      "question": "Wskazać poprawne zapytanie SQL znajdujące pracowników o najniższych zarobkach w ich działach.",
      "id": 711,
      "comments": [
        {
          "author": "~gawa@89.73.*.*",
          "comment": "3 też jest prawidłowe",
          "date": "28-06-2013 19:34:52"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "Potwierdzam.",
          "date": "29-06-2013 16:29:04"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam.",
          "date": "30-06-2013 16:45:35"
        },
        {
          "author": "~mimo@89.77.*.*",
          "comment": "3 nie jest poprawne. Np:\nDział A:\npracownik a zarabia 1000\npracownik b zarabia 2000\nDział B:\npracownik c zarabia 500\npracownik d zarabia 1000\n\nZapytanie: \"SELECT MIN(sal)FROM emp GROUP BY deptno\" wybiera z bazy pensje: 500 i 1000.\nCzyli całe zapytanie wypisze nie dwóch pracowników tylko 3: a, c oraz d. Tak więc trzecie nie jest prawidłowe.\n",
          "date": "05-09-2013 19:09:10"
        },
        {
          "author": "mykhi",
          "comment": "odprawiam.",
          "date": "05-09-2013 19:10:29"
        },
        {
          "author": "~anon@162.158.*.*",
          "comment": "w oraclu i ssms odpowiedzi a,b,c są poprawne",
          "date": "29-06-2019 20:57:19"
        },
        {
          "author": "~anon@89.66.*.*",
          "comment": "ja zauważyłem taką różnicę, iż odpowiedź c znajduje również przypadki gdzie pracownik nie ma przypisanego działu (tj. NULL), więc dostajemy ekstra informację, która wcale nas tutaj nie interesowała -> szukani są pracownicy o najniższych pensjach w danych działach, a nie w całym zbiorze pracowników",
          "date": "25-08-2019 03:32:46"
        }
      ],
      "answers": [
        {
          "answer": "SELECT ename, sal, deptno FROM emp WHERE (sal, deptno) IN (SELECT MIN(sal), deptno FROM empGROUP BY deptno);",
          "correct": true
        },
        {
          "answer": "SELECT ename, deptno, sal FROM emp e WHERE sal = (SELECT MIN(sal)FROM emp WHERE deptno = e. deptno);",
          "correct": true
        },
        {
          "answer": "SELECT ename, sal, deptno FROM emp WHERE sal IN (SELECT MIN(sal)FROM emp GROUP BY deptno)",
          "correct": false
        },
        {
          "answer": "SELECT ename MIN(sal), deptno FROM emp GROUP BY deptno)",
          "correct": false
        }
      ]
    },
    {
      "question": "Wskazać poprawne zapytanie SQL znajdujące pracowników, których zarobki są wyższe od pensji każdego pracownika z departamentu 30.",
      "id": 712,
      "comments": [
        {
          "author": "~anon@89.68.*.*",
          "comment": "odpowiedz SELECT ename, sal, job, deptno FROM emp WHERE sal> ALL (SELECT DISTINCT sal FROM emp WHERE deptno = 30); takze jest poprawna, daje takie same wyniki jak SELECT ename, sal, job, deptno FROM emp WHERE sal> (SELECT Max( sal) FROM emp WHERE deptno = 30); sprawdzone w sqldeveloperze",
          "date": "05-02-2013 15:46:00"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam.",
          "date": "05-02-2013 15:46:38"
        }
      ],
      "answers": [
        {
          "answer": "SELECT ename, sal, job, deptno FROM emp WHERE sal&gt; ALL (SELECT DISTINCT sal FROM emp WHERE deptno = 30);",
          "correct": true
        },
        {
          "answer": "SELECT ename, sal, job, deptno FROM emp WHERE sal&gt; (SELECT Max( sal) FROM emp WHERE deptno = 30);",
          "correct": true
        },
        {
          "answer": "SELECT ename, sal, job, deptno FROM emp WHERE sal&gt; ANY (SELECT DISTINCT sal FROM emp WHERE deptno = 30);",
          "correct": false
        },
        {
          "answer": "SELECT ename, sal, job, deptno FROM emp WHERE sal&gt; (SELECT Min( sal) FROM emp WHERE deptno = 30);",
          "correct": false
        }
      ]
    },
    {
      "question": "Wskazać poprawne zapytanie SQL znajdujące stanowiska pracy występujące w działach 10 lub 20.",
      "id": 713,
      "comments": [
        {
          "author": "~sng@95.41.*.*",
          "comment": "Tutaj poprawną jest tylko zapytanie z UNION SELECT",
          "date": "05-02-2012 20:14:02"
        },
        {
          "author": "~MSiwak@77.255.*.*",
          "comment": "Jak dla mnie oba są dobrze...",
          "date": "05-02-2012 20:34:25"
        },
        {
          "author": "~anon@89.75.*.*",
          "comment": "Zgadza się oba, ze wzgledu na distinct, bez niego chyba nie byłaby to prawda.",
          "date": "05-02-2012 20:39:17"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "Union zwraca 10 lub 20 bez pokrywania sie zbiorow ( bez osob ktore sa w 10 i 20 jednoczesnie) zas or zwraca zarowno tych co sa w 10, 20 jak i 10 i 20. Moim zdaniem OR jest prawidlowe bo pytanie jest o osoby z dzialu 10 lub 20, to gdy nalezy ktos do obu dzialow to nie spelnia warunkow? Moim zdaniem spelnia bo jest w jednym z wymienionych dzialow. Nic nie jest napisane o tym ze ma byc wylacznie w 10 albo 20",
          "date": "27-06-2013 18:10:54"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "~anon@89.67.*.* - UNION właśnie zwraca z pokrywaniem się zbiorów. z jakiego powodu uważasz że tak nie jest?",
          "date": "07-09-2014 10:17:37"
        }
      ],
      "answers": [
        {
          "answer": "SELECT DISTINCT job FROM emp WHERE deptno = 10 OR deptno = 20",
          "correct": true
        },
        {
          "answer": "SELECT DISTINCT job FROM emp WHERE deptno = 10 UNION SELECT DISTINCT job FROM emp WHERE deptno = 20",
          "correct": true
        },
        {
          "answer": "SELECT DISTINCT job FROM emp WHERE deptno = 10 AND deptno = 20",
          "correct": false
        },
        {
          "answer": "SELECT DISTINCT job FROM emp WHERE deptno = 10 INTERSECT SELECT DISTINCT job FROM emp WHERE deptno = 20",
          "correct": false
        }
      ]
    },
    {
      "question": "Wskazać poprawne zapytanie SQL znajdujące stanowiska pracy występujące zarówno  w dziale 10 jak i w dziale 20.",
      "id": 714,
      "comments": [
        {
          "author": "~MSiwak@77.255.*.*",
          "comment": "SELECT DISTINCT job FROM emp WHERE deptno = 10 AND deptno = 20 to na pewno nie jest poprawne deptno nie może być zarazem 10 i 20. \nSELECT DISTINCT job FROM emp WHERE deptno = 10 OR deptno = 20 to jest raczej dobrze",
          "date": "05-02-2012 18:46:07"
        },
        {
          "author": "~ja@89.75.*.*",
          "comment": "Nope, poprawne jest tylko z intersectem. Jesli dostaniesz przypadek, gdzie w 10 jest tylko job A a w 20 tylko job B to ci zwróci {A, B}, a powinno pusty, bo nie ma stanowiska które wystapi i tu i tu. Trzeba zastosować przecięcie zbiorów.",
          "date": "05-02-2012 19:38:01"
        },
        {
          "author": "~MSiwak@77.255.*.*",
          "comment": "Fakt",
          "date": "05-02-2012 20:03:28"
        },
        {
          "author": "~anon@89.68.*.*",
          "comment": "dokladnie poprawna jest tylko ta z intersectem",
          "date": "05-02-2013 15:51:11"
        },
        {
          "author": "mykhi",
          "comment": "poprawiłem.",
          "date": "05-02-2013 15:53:59"
        }
      ],
      "answers": [
        {
          "answer": "SELECT DISTINCT job FROM emp WHERE deptno = 10 INTERSECT SELECT DISTINCT job FROM emp WHERE deptno = 20",
          "correct": true
        },
        {
          "answer": "SELECT DISTINCT job FROM emp WHERE deptno = 10 OR deptno = 20",
          "correct": false
        },
        {
          "answer": "SELECT DISTINCT job FROM emp WHERE deptno = 10 UNION SELECT DISTINCT job FROM emp WHERE deptno = 20",
          "correct": false
        },
        {
          "answer": "SELECT DISTINCT job FROM emp WHERE deptno = 10 AND deptno = 20",
          "correct": false
        }
      ]
    },
    {
      "question": "Wskazać poprawne zapytanie SQL znajdujące pracowników, którzy zarabiają mniej od swoich kierowników.",
      "id": 715,
      "comments": null,
      "answers": [
        {
          "answer": "SELECT e.ename prac_name, e.sal prac_sal, m.ename kier_name, m.sal kier_sal FROM emp e, emp m WHERE e.mgr = m.empno AND e.sal &lt; m.sal",
          "correct": true
        },
        {
          "answer": "SELECT e.ename prac_name, e.sal prac_sal, m.ename kier_name, m.sal kier_sal FROM emp e, emp m WHERE e.mgr = m.empno AND m.sal &lt; e.sal",
          "correct": false
        },
        {
          "answer": "SELECT e.ename prac_name, e.sal prac_sal, m.ename kier_name, m.sal kier_sal FROM emp e, emp m WHERE e.mgr = m.mgr AND e.sal &lt; m.sal",
          "correct": false
        },
        {
          "answer": "SELECT e.ename prac_name, e.sal prac_sal, m.ename kier_name, m.sal kier_sal FROM emp e, emp m WHERE e.mgr = m.mgr AND m.sal &lt; e.sal",
          "correct": false
        }
      ]
    },
    {
      "question": "Wskazać poprawne zapytanie SQL znajdujące średnie zarobki tylko tych departamentów, które zatrudniają więcej niż trzech pracowników.",
      "id": 716,
      "comments": [
        {
          "author": "~gawa@194.181.*.*",
          "comment": "2 też jest poprawna jeśli mówimy tu o bazie Oracle",
          "date": "25-06-2013 14:38:54"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "dokladnie w oracle having moze byc przed group by mimo ze jest to niezalecane ( ale nie jest nieprawidlowe )",
          "date": "28-06-2013 12:08:24"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam.",
          "date": "30-06-2013 17:23:41"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "Jeszcze miałem taką odpowiedź:\n\n* SELECT deptno, job, AVG(sal) FROM emp GROUP BY deptno HAVING COUNT(*) > 3; (niepoprawna)",
          "date": "07-09-2014 17:38:21"
        },
        {
          "author": "~anon@78.11.*.*",
          "comment": "przeciez w 2 mamy przecinek",
          "date": "01-07-2015 20:02:25"
        },
        {
          "author": "~joł@89.70.*.*",
          "comment": "Ciekawe w jaki sposób ma działać to drugie z tym średnikiem przed group by.",
          "date": "27-08-2017 19:31:07"
        },
        {
          "author": "~anon@89.64.*.*",
          "comment": "czyli jak bedzie?",
          "date": "30-01-2018 23:26:16"
        },
        {
          "author": "~anon@212.2.*.*",
          "comment": "2 nie jest poprawna",
          "date": "30-08-2018 20:09:12"
        },
        {
          "author": "~Won Tyr@89.64.*.*",
          "comment": "właśnie sprawdziłem w oraclu i jest to uważane za błąd\n",
          "date": "29-01-2019 16:04:11"
        },
        {
          "author": "~anon@162.158.*.*",
          "comment": "podbijam, mykhi, usuń średnik, albo usuń z poprawnych\n",
          "date": "29-06-2019 13:02:20"
        }
      ],
      "answers": [
        {
          "answer": "SELECT deptno, AVG(sal) FROM emp GROUP BY deptno HAVING COUNT (*) &gt; 3;",
          "correct": true
        },
        {
          "answer": "SELECT deptno, AVG(sal) FROM emp HAVING COUNT (*) &gt; 3;GROUP BY deptno ;",
          "correct": true
        },
        {
          "answer": "SELECT deptno, AVG(sal) FROM emp GROUP BY deptno WHERE COUNT (*) &gt; 3;",
          "correct": false
        },
        {
          "answer": "SELECT deptno, AVG(sal) FROM emp WHERE COUNT (*) &gt; 3;GROUP BY deptno ;",
          "correct": false
        }
      ]
    },
    {
      "question": "Wskazać poprawne zapytanie SQL znajdujące stanowiska, na których średni zarobek wynosi 3000 lub więcej.",
      "id": 717,
      "comments": [
        {
          "author": "~gawa@194.181.*.*",
          "comment": "tak jak w poprzednim przykładzie, 2 też jest poprawna jeśli mówimy o bazie Oracle, a takie jest założenie na egzaminie",
          "date": "25-06-2013 14:42:03"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "Potwierdzam.",
          "date": "29-06-2013 16:31:35"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam.",
          "date": "30-06-2013 17:24:11"
        },
        {
          "author": "~step@94.254.*.*",
          "comment": "info od boga mówi mi że jest a tylko\nSELECT job, AVG(sal) FROM emp GROUP BY job HAVING AVG (sal) > =3000;",
          "date": "13-02-2017 20:37:26"
        },
        {
          "author": "~Kogug@109.206.*.*",
          "comment": "\"ale w systemie ORACLE jest jeden wyjątek: kolejność klauzul HAVING i GROUP BY jest dowolna.\"",
          "date": "01-07-2018 17:29:54"
        }
      ],
      "answers": [
        {
          "answer": "SELECT job, AVG(sal) FROM emp GROUP BY job HAVING AVG (sal) &gt; =3000;",
          "correct": true
        },
        {
          "answer": "SELECT job, AVG(sal) FROM emp HAVING AVG (sal) &gt; =3000GROUP BY job;",
          "correct": true
        },
        {
          "answer": "SELECT job, AVG(sal) FROM emp GROUP BY job WHERE AVG (sal) &gt; =3000;",
          "correct": false
        },
        {
          "answer": "SELECT job, AVG(sal) FROM emp WHERE AVG (sal) &gt; =3000 GROUP BY job;",
          "correct": false
        }
      ]
    },
    {
      "question": "Wskazać poprawne zapytanie SQL znajdujące departamenty zatrudniające powyżej trzech pracowników",
      "id": 718,
      "comments": [
        {
          "author": "~gawa@194.181.*.*",
          "comment": "tak jak w poprzednim przykładzie, 2 też jest poprawna jeśli mówimy o bazie Oracle, a takie jest założenie na egzaminie",
          "date": "25-06-2013 14:49:42"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "Definition:\nThe Oracle PL/SQL HAVING clause is used to filter or restrict the groups formed by the GROUP_BY clause. It follows the GROUP_BY clause in the SELECT statement. The HAVING clause can also precede the GROUP_BY clause, but this isn't logical and is not recommended. All grouping is performed (and group functions executed) prior to evaluating the HAVING clause.\n\nDifference between WHERE and HAVING\nThe WHERE clause will filter or limit rows as they are selected from the table, but before grouping is done. The HAVING clause will filter rows after the grouping.\n\nExample Syntax:\n\nSELECT <column list>, <group by function>\n\nFROM <table name>\n\nWHERE <conditions>\n\nGROUP_BY <column list>\n\nHAVING <group by function condition>\n\nWycialem z dokumentacji oracla zatem tylko jedna odpowiedz jest prawidlowa",
          "date": "26-06-2013 21:17:56"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "Sorki obydwie sa poprawne bo HAVING moze poprzedzac group by ale jest to tylko nielogiczne i niezalecane ;)",
          "date": "27-06-2013 18:12:31"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam.",
          "date": "30-06-2013 16:52:59"
        }
      ],
      "answers": [
        {
          "answer": "SELECT deptno, COUNT(*) FROM emp GROUP BY deptno HAVING COUNT (*) &gt; 3;",
          "correct": true
        },
        {
          "answer": "SELECT deptno, COUNT(*) FROM emp HAVING COUNT (*) &gt; 3 GROUP BY deptno;",
          "correct": true
        },
        {
          "answer": "SELECT deptno, COUNT(*) FROM emp GROUP BY deptno WHERE COUNT (*) &gt; 3;",
          "correct": false
        },
        {
          "answer": "SELECT deptno, COUNT(*) FROM emp WHERE COUNT (*) &gt; 3 GROUP BY deptno;",
          "correct": false
        }
      ]
    },
    {
      "question": "Wskazać poprawne zapytanie SQL znajdujące ilość pracowników w dziale mającym siedzibę w DALLAS.",
      "id": 719,
      "comments": [
        {
          "author": "~anon@89.68.*.*",
          "comment": "SELECT COUNT (*) FROM emp, dept WHERE dept.loc = 'DALLAS' AND emp.deptno = dept.deptno GROUP BY dept,deptno; sqldeveloper wyrzuca column ambiguously defined przy group by deptno, wiec obstawiam ze jest niepoprawna",
          "date": "05-02-2013 16:18:06"
        },
        {
          "author": "~TęgaPała@178.183.*.*",
          "comment": "Popieram. dept jest tabelą, a możemy grupować po kolumnach.",
          "date": "06-02-2013 15:01:36"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam.",
          "date": "06-02-2013 21:56:01"
        },
        {
          "author": "~anon@89.75.*.*",
          "comment": "Kurde, jak nie wiecie to nie poprawiajcie pls, bo wprowadzacie w blad. \n\nodp nr1 jest poprawna tylko jest literowka a specjalny blad(aczkolwiek watpie) \nGroup by dept,deptno a powinno byc dept.deptno, chyba ze to nie literowka. \nZapytanie dziala i zwraca taki sam wynik jak odpowiedz nr2. Prosze o poprawienie",
          "date": "08-02-2014 18:47:36"
        },
        {
          "author": "~roff@89.75.*.*",
          "comment": "Fatalnie sformatowala mi sie wypowiedz. Chodzilo oczywiscie o to, ze prawdopodobnie jest to literowka, a nie specjalnie zle zapisane zapytanie. \n\nNalezy poprawic: \nodp nr1 jest poprawna - sprawdzone w sql developerze\nliterowke - group by dept,deptno zamienic na group by dept.deptno",
          "date": "08-02-2014 18:49:27"
        },
        {
          "author": "~anon@79.185.*.*",
          "comment": "jak to jest literówka to faktycznie powino być poprawne. a tak z innej beczki mogą być dwie kolumny w group by czy nie bo juz mi sie pieprzy?? ",
          "date": "08-02-2014 18:55:04"
        },
        {
          "author": "mykhi",
          "comment": "poprawione",
          "date": "09-02-2014 10:03:02"
        },
        {
          "author": "~anon@109.241.*.*",
          "comment": "\tSELECT COUNT (*) FROM emp WHERE deptno = (SELECT deptno FROM dept WHERE .loc = 'DALLAS')\t- Niepoprawne.\n\n\tSELECT COUNT (*) FROM emp WHERE deptno = (SELECT deptno FROM dept WHERE loc = 'DALLAS') - Poprawne\n\nJezeli .loc to select sie nie wykona jezeli loc to sie wykona. Kwestia czy to tylko blad przy wpisywaniu czy podkercona pilka.\t",
          "date": "05-07-2018 11:20:01"
        }
      ],
      "answers": [
        {
          "answer": "SELECT COUNT (*) FROM emp, dept WHERE dept.loc = 'DALLAS' AND emp.deptno = dept.deptno GROUP BY dept.deptno;",
          "correct": true
        },
        {
          "answer": "SELECT COUNT (*) FROM emp WHERE deptno =  (SELECT deptno FROM  dept WHERE .loc = 'DALLAS')",
          "correct": true
        },
        {
          "answer": "SELECT COUNT (*) FROM emp, dept WHERE dept.loc = 'DALLAS' GROUP BY dept.deptno;",
          "correct": false
        },
        {
          "answer": "SELECT COUNT (*) FROM emp, dept WHERE emp.deptno = dept.deptno GROUP BY dept,deptno HAVING dept.loc = 'DALLAS';",
          "correct": false
        }
      ]
    },
    {
      "question": "Wskazać poprawne zapytanie SQL znajdujące średni zarobek pracowników z drugiej klasy zarobkowej.",
      "id": 720,
      "comments": [
        {
          "author": "~anon@89.68.*.*",
          "comment": "wszystkie odpowiedzi w sqldeveloperze zwracaja mi taki sam sredni zarobek(biorac pod uwage ze te kropki po where to literowka), zatem wydaje mi sie ze wszystkie beda poprawne?",
          "date": "07-02-2013 00:36:17"
        },
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Ze względu na to, że tych kropek jest dość wiele, strzelam że to właśnie jest podchwytliwość w tym pytaniu i tak może być na egz.",
          "date": "07-02-2013 01:03:31"
        },
        {
          "author": "~anon@178.36.*.*",
          "comment": "Idac tym tropem w pytaniu 68 odpowiedz\nSELECT deptno, ename, hiredate FROM emp e WHERE (hiredate,) = (SELECT MAX(hiredate) FROM emp WHERE deptno=e.deptno GROUP BY deptno);\ntez nie jest poprawna, bo po hiredate jest ','.",
          "date": "07-02-2013 01:14:31"
        },
        {
          "author": "~gawa@89.73.*.*",
          "comment": "kropki i przecinki nie mają znaczenia w tych pytaniach, pytałem się ",
          "date": "25-06-2013 15:50:46"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "wszystkie poprawne, daja ten sam wynik sprawdzane na sql developerze",
          "date": "27-06-2013 17:49:59"
        },
        {
          "author": "mykhi",
          "comment": "ok zaznaczam wszystkie (wcześniej tylko odp. 3)",
          "date": "30-06-2013 16:58:39"
        },
        {
          "author": "~mimo@89.77.*.*",
          "comment": "ale to właśnie odp. 3 jest zła przecież - ponieważ w tej odpowiedzi on wylicza średnią pensję wszystkich pracowników (ze wszystkich klas zarobkowych), którzy mają zarobek wyższy niż najniższy z klasy 2 i niższy niż najwyższy z klasy 2. Mam rację? ",
          "date": "05-09-2013 21:24:28"
        },
        {
          "author": "~anon@81.18.*.*",
          "comment": "@up dokładnie tak wylicza, ale takie są chyba założenia klasy zarobkowej - jesteś w drugiej klasie zarobkowej jeśli Twoje zarobki mieszczą się przedziale danej klasy. więc faktycznie wyliczana jest średnia zarobków wszystkich pracowników, którzy są 2. klasie zarobkowej",
          "date": "07-09-2013 16:12:24"
        },
        {
          "author": "~mimo@89.77.*.*",
          "comment": "na zdrowy rozsądek tak powinno być, ale ogólnie gdyby zmienić 'klasa zarobkowa' na 'grupa pracowników' to byłoby już błędem. Ok, nwm, niech będzie :)",
          "date": "07-09-2013 16:33:28"
        },
        {
          "author": "~m_r_k@95.49.*.*",
          "comment": "BETWEEN zawiera także krańce przedziałów, więc nie jest równoważne przedziałowi określonemu za pomocą ostrych nierówności >< (więc dla danych gdzie znajdą się zarobki równe granicy przedziału odpowiedzi będą różne), ale czy ma to znaczenie dla poprawności odpowiedzi jest sprawą dyskusyjną.",
          "date": "28-06-2014 21:43:42"
        },
        {
          "author": "~joł@89.70.*.*",
          "comment": "Moim zdaniem 2 i 3 jest niepoprawne właśnie z tego powodu, który zauważył m_r_k, bo tak na zdrowy rozum, to właśnie to może sprawdzać to pytanie- czy wiemy co dokładnie robi between",
          "date": "27-08-2017 20:32:54"
        }
      ],
      "answers": [
        {
          "answer": "SELECT AVG(sal ) FROM emp, salgrade WHERE.grade = 2 AND sal BETWEEN losal AND hisal GROUP BY.grade",
          "correct": true
        },
        {
          "answer": "SELECT AVG(sal ) FROM emp, salgrade WHERE.grade = 2 AND sal &gt; losal AND sal &lt; hisal GROUP BY.grade",
          "correct": true
        },
        {
          "answer": "SELECT AVG(sal ) FROM emp, WHERE  sal &gt; (SELECT losal FROM salgrade WHERE.grade = 2) AND sal &lt; (SELECT hisal FROM salgrade WHERE.grade = 2)",
          "correct": true
        },
        {
          "answer": "SELECT AVG(sal ) FROM emp, salgrade WHERE.grade = 2 AND sal BETWEEN losal AND hisal ;",
          "correct": true
        }
      ]
    },
    {
      "question": "Wskazać poprawne zapytanie SQL znajdujące trzech najlepiej zarabiających pracowników w firmie - ich nazwiska i pensje.",
      "id": 721,
      "comments": null,
      "answers": [
        {
          "answer": "SELECT ename, sal FROM emp e WHERE 3 &gt; (SELECT count (*) FROM emp WHERE e.sal &lt; sal);",
          "correct": true
        },
        {
          "answer": "SELECT ename, sal FROM emp e WHERE count(*)&lt;3",
          "correct": false
        },
        {
          "answer": "SELECT ename, sal FROM emp e GROUP BY.deptno  HAVING count(*)&lt;3",
          "correct": false
        }
      ]
    },
    {
      "question": "W bloku PL/SQL występują:",
      "id": 722,
      "comments": [
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Sekcja wyjątków również występuje w boku PL/SQL. Uzasadnienie tutaj: http://edu.pjwstk.edu.pl/wyklady/sbd/scb/w5.htm",
          "date": "02-02-2013 17:46:39"
        },
        {
          "author": "mykhi",
          "comment": "ok poprawiam.",
          "date": "02-02-2013 17:50:48"
        }
      ],
      "answers": [
        {
          "answer": "deklaracje klas,",
          "correct": false
        },
        {
          "answer": "sekcja wyjątków,",
          "correct": true
        },
        {
          "answer": "instrukcje SQL,",
          "correct": true
        },
        {
          "answer": "instrukcje SQL*Plus.",
          "correct": false
        }
      ]
    },
    {
      "question": "Wśród instrukcji występujących w bloku PL/SQL mogą się znaleźć:",
      "id": 723,
      "comments": [
        {
          "author": "~Kamil@95.49.*.*",
          "comment": "Odpowiedź B (deklaracje zmiennych), to błąd na 100%. Wlasnie robie przykladowy test na eduxie i widze prawidłowe odpowiedzi i ta odpowiedz nie jest zaznaczona w poprawnych.",
          "date": "26-01-2014 19:50:07"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam",
          "date": "26-01-2014 20:01:40"
        },
        {
          "author": "~SJ@78.133.*.*",
          "comment": "Wykład piąty, akapit 5.1:\n\"Odpowiednikiem konstrukcji bloku (i programu) występujących w językach programowania jest w PL/SQL blok PL/SQL nazywany też blokiem anonimowym. Ma on następującą składnię:\n \nDECLARE\n   deklaracje obiektów PL/SQL jak zmienne, stałe, wyjątki, procedury, funkcje\nBEGIN\n   ciąg instrukcji do wykonania\nEXCEPTION\n   obsługa wyjątków (błędów)\nEND;\n \nDeklaracje i obsługa wyjątków są opcjonalne. Bloki mogą być zagnieżdżone. Jedynymi instrukcjami języka SQL, które mogą się pojawić w bloku PL/SQL, są instrukcje SELECT, INSERT, UPDATE, DELETE, COMMIT i ROLLBACK\"\n\nZ tego jasno wynika, że jednak deklaracje zmiennych są możliwe w bloku PL/SQL.",
          "date": "28-01-2014 16:24:37"
        },
        {
          "author": "~Kamil@83.6.*.*",
          "comment": "Aj, kurde, racja. W EDUXie jest wskazanie, że między BEGIN a END... Deklaracje zmiennych są zatem poprawne, a ja idę klęczeć na grochu...",
          "date": "28-01-2014 18:48:35"
        },
        {
          "author": "mykhi",
          "comment": "to klęcz a ja poprawię.",
          "date": "28-01-2014 18:49:57"
        }
      ],
      "answers": [
        {
          "answer": "instrukcje SQL*Plus,",
          "correct": false
        },
        {
          "answer": "deklaracje zmiennych,",
          "correct": true
        },
        {
          "answer": "instrukcja CREATE TABLE,",
          "correct": false
        },
        {
          "answer": "instrukcja COMMIT.",
          "correct": true
        }
      ]
    },
    {
      "question": "Wśród instrukcji występujących w bloku PL/SQL mogą się znaleźć:",
      "id": 724,
      "comments": [
        {
          "author": "~anon@178.36.*.*",
          "comment": "'Jedynymi instrukcjami języka SQL, które mogą się pojawić w bloku PL/SQL, są instrukcje SELECT, INSERT, UPDATE, DELETE, COMMIT i ROLLBACK.'\n\nhttp://edu.pjwstk.edu.pl/wyklady/sbd/scb/w5.htm",
          "date": "07-02-2013 02:12:23"
        },
        {
          "author": "~anon@178.36.*.*",
          "comment": "Moj blad. instrukcja DBMS_OUTPUT.PUT_LINE moze wystapic.",
          "date": "07-02-2013 02:13:20"
        },
        {
          "author": "~anon@109.241.*.*",
          "comment": "Tutaj nie jest napisane, że instrukcje SQL tylko wśród instrukcji a instrukcja DBMS_OUTPUT.PUT_LINE('Początek transakcji') jest instrukcja.",
          "date": "05-07-2018 11:58:11"
        },
        {
          "author": "~anon@109.241.*.*",
          "comment": "Jezli by było pytanie Wśród instrukcji SQL wsytępujących w bloku PL/SQL mogą się znależć: to tak, ale nie jest doprecyzowane.",
          "date": "05-07-2018 12:01:45"
        },
        {
          "author": "~ess@89.230.*.*",
          "comment": "instrukcja SET SERVEROUTPUT ON to chyba tez jest prawidlowe?",
          "date": "27-01-2020 22:05:31"
        },
        {
          "author": "~anon@37.47.*.*",
          "comment": "wydaje mi sie ze SET SERVEROUTPUT ON wystepuje poza blokiem PL/SQL",
          "date": "04-02-2020 19:16:47"
        }
      ],
      "answers": [
        {
          "answer": "instrukcja SET SERVEROUTPUT ON,",
          "correct": false
        },
        {
          "answer": "instrukcja CREATE TABLE,",
          "correct": false
        },
        {
          "answer": "instrukcja DBMS_OUTPUT.PUT_LINE('Początek transakcji'),",
          "correct": true
        },
        {
          "answer": "instrukcja ROLLBACK.",
          "correct": true
        }
      ]
    },
    {
      "question": "Wśród instrukcji występujących w bloku PL/SQL mogą się znaleźć:",
      "id": 725,
      "comments": [
        {
          "author": "~anon@83.6.*.*",
          "comment": "A czy \"instrukcja SELECT Table_Name FROM User_Tables,\"  nie moze sie znalezc jak np. deklarujemy kursor?",
          "date": "07-02-2013 01:03:16"
        },
        {
          "author": "~anon@178.36.*.*",
          "comment": "Nie.\n'Jedynymi instrukcjami języka SQL, które mogą się pojawić w bloku PL/SQL, są instrukcje SELECT, INSERT, UPDATE, DELETE, COMMIT i ROLLBACK.'\n\nhttp://edu.pjwstk.edu.pl/wyklady/sbd/scb/w5.htm",
          "date": "07-02-2013 01:48:21"
        },
        {
          "author": "~anon@178.36.*.*",
          "comment": "Nie, nie tylko wychodzi na to ze tak.",
          "date": "07-02-2013 01:51:05"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "haha a po polsku, to \"SELECT Table_Name FROM User_Tables\" to poprawna odpowiedź, czy nie? Bo w końcu jest to select\n",
          "date": "07-02-2013 01:52:48"
        },
        {
          "author": "~anon@178.36.*.*",
          "comment": "Select moze byc, tylko, ze tu akurat jest zle uzyte.\nPowinno byc SELECT column_name FROM table_name i bylo by OK.\n(tak mi sie wydaje ze w tym tkwi blad)",
          "date": "07-02-2013 01:57:18"
        },
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "SELECT w bloku PL/SQL musi mieć słowo INTO po wyrażeniu. Dlatego odpowiedź numer 3 jest niepoprawna. W podanym wyżej wykładzie jest dokładny opis składni SELECT w blokach PL/SQL.",
          "date": "07-02-2013 02:10:39"
        },
        {
          "author": "~anon@83.6.*.*",
          "comment": "no ale, jakbym sobie nazwał tak kolumny i tabele to byloby poprawnie... trzeba bedzie sie klocic :)",
          "date": "07-02-2013 02:12:02"
        },
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Nie byłoby poprawnie, bo mówimy o SELECT w bloku PL/SQL a nie zwykłym SELECT! Ten SELECT nie byłby poprawny!\nGdyby to nie był blok PL/SQL to wywołanie tego SELECTA zwróciłoby ci nazwy wszystkich tabel, których jesteś właścicielem.",
          "date": "07-02-2013 02:16:24"
        }
      ],
      "answers": [
        {
          "answer": "instrukcja warunkowa,",
          "correct": true
        },
        {
          "answer": "instrukcja CREATE TABLE,",
          "correct": false
        },
        {
          "answer": "instrukcja SELECT Table_Name FROM User_Tables,",
          "correct": false
        },
        {
          "answer": "instrukcja ROLLBACK.",
          "correct": true
        }
      ]
    },
    {
      "question": "Wśród instrukcji występujących w bloku PL/SQL mogą się znaleźć:",
      "id": 726,
      "comments": [
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Deklaracja wyjątków również może się znaleźć w bloku PL/SQL. Szczegóły w dziale \"Wyjątki definiowane przez programistę\" pod tym linkiem: http://edu.pjwstk.edu.pl/wyklady/sbd/scb/rW5.htm",
          "date": "02-02-2013 17:56:30"
        },
        {
          "author": "mykhi",
          "comment": "dodano.",
          "date": "02-02-2013 17:59:00"
        },
        {
          "author": "~anon@87.205.*.*",
          "comment": "A co jest nie tak z \"SELECT * FROM Osoby?\"",
          "date": "06-02-2013 23:13:35"
        },
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "W bloku PL/SQL SELECT ma inną składnię niż w SQL. Składnia jest następująca:\n\nSELECT wyrażenie, wyrażenie,...\nINTO zmienna, zmienna,...\nFROM tabela, tabela,...\n[WHERE ...][GROUP BY ...][HAVING ...][FOR UPDATE OF ...];\n\nŹródło: http://edu.pjwstk.edu.pl/wyklady/sbd/scb/w5.htm",
          "date": "06-02-2013 23:24:27"
        }
      ],
      "answers": [
        {
          "answer": "podniesienie wyjątku,",
          "correct": true
        },
        {
          "answer": "deklaracje wyjątków,",
          "correct": true
        },
        {
          "answer": "instrukcja SELECT * FROM Osoby,",
          "correct": false
        },
        {
          "answer": "instrukcja ROLLBACK.",
          "correct": true
        }
      ]
    },
    {
      "question": "Kursor w PL/SQL jest to:",
      "id": 727,
      "comments": [
        {
          "author": "~morawa@178.36.*.*",
          "comment": "A nie przypadkiem : obszar roboczy używany do wykonania instrukcji SQL,",
          "date": "04-02-2013 19:31:26"
        },
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Raczej żadna odpowiedź nie jest prawidłowa. Według wykładów (http://edu.pjwstk.edu.pl/wyklady/sbd/scb/rW5.htm) kursor to \"struktura danych umożliwiająca sprowadzanie z bazy danych kolejnych wierszy wyniku zapytania\".",
          "date": "04-02-2013 19:46:31"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "poprawna odpowiedz to na pewno ta z obszarem roboczym bo tak mialem na tescie ze prawidlowe a to ze nazwana instrukcja sql to nie wiem bo akurat przy tym pytaniu tej odpowiedzi do wyboru nie mialem",
          "date": "05-02-2013 09:18:13"
        },
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "http://www.drzewo-wiedzy.pl/?page=artykul&id=140 - Tutaj napisane, że jest to faktycznie obszar roboczy.",
          "date": "07-02-2013 00:32:32"
        },
        {
          "author": "~anon@178.36.*.*",
          "comment": "http://edu.pjwstk.edu.pl/wyklady/sbd/scb/w5.htm\n\n5.5 - \"Do tego celu jest potrzebny obiekt PL/SQL o nazwie kursor, który stanowi bufor, do którego są zapisywane, kolejno sprowadzane z bazy danych, wiersze wynikowe zapytania.\"",
          "date": "07-02-2013 01:06:38"
        },
        {
          "author": "~anon@178.36.*.*",
          "comment": "Kursor (ang. cursor) jest konstruktorem PL/SQL umożliwiającym:\n• nadanie nazwy temu obszarowi\n\nhttp://ajd.czest.pl/~l.stepien/filesa/inf2/w_II_inf_9_03_10.pdf",
          "date": "07-02-2013 02:25:07"
        },
        {
          "author": "~anon@178.36.*.*",
          "comment": "Kursor jest nazwą dla obszaru roboczego, w którym\nskładowane są informacje o przetwarzanym w programie\nPL/SQL poleceniu SQL.",
          "date": "07-02-2013 02:38:59"
        },
        {
          "author": "~rod@178.42.*.*",
          "comment": "zrobiłem quiz, 'obszar roboczy ...' jest zaznaczony jako poprawna odpowiedź",
          "date": "27-06-2013 22:53:30"
        },
        {
          "author": "mykhi",
          "comment": "odznaczam \"nazwana instrukcja SQL\" zaznaczam \"obszar roboczy używany do wykonania instrukcji SQL\"",
          "date": "30-06-2013 16:55:59"
        }
      ],
      "answers": [
        {
          "answer": "rodzaj procedury,",
          "correct": false
        },
        {
          "answer": "nazwana instrukcja SQL,",
          "correct": false
        },
        {
          "answer": "obszar roboczy używany do wykonania instrukcji SQL,",
          "correct": true
        },
        {
          "answer": "narzędzie do podnoszenia wyjątków.",
          "correct": false
        }
      ]
    },
    {
      "question": "Czy definicja kursora w PL/SQL może dotyczyć instrukcji:",
      "id": 728,
      "comments": null,
      "answers": [
        {
          "answer": "INSERT,",
          "correct": false
        },
        {
          "answer": "SELECT,",
          "correct": true
        },
        {
          "answer": "DELETE,",
          "correct": false
        },
        {
          "answer": "UPDATE.",
          "correct": false
        }
      ]
    },
    {
      "question": "Nazwa kursora może się pojawić w następujących kontekstach:",
      "id": 729,
      "comments": null,
      "answers": [
        {
          "answer": "OPEN nazwa_kursora,",
          "correct": true
        },
        {
          "answer": "SELECT nazwa_kursora,",
          "correct": false
        },
        {
          "answer": "EXIT WHEN nazwa_kursora%NOTFOUND,",
          "correct": true
        },
        {
          "answer": "GOTO nazwa_kursora.",
          "correct": false
        }
      ]
    },
    {
      "question": "Klauzula WHERE CURRENT OF nazwa_kursora może wystąpić w instrukcji:",
      "id": 730,
      "comments": null,
      "answers": [
        {
          "answer": "SELECT,",
          "correct": false
        },
        {
          "answer": "INSERT,",
          "correct": false
        },
        {
          "answer": "DELETE,",
          "correct": true
        },
        {
          "answer": "UPDATE.",
          "correct": true
        }
      ]
    },
    {
      "question": "Nazwa wyjątku może się pojawić w następujących kontekstach;",
      "id": 731,
      "comments": null,
      "answers": [
        {
          "answer": "w instrukcji przypisania,",
          "correct": false
        },
        {
          "answer": "w definicji kursora,",
          "correct": false
        },
        {
          "answer": "w instrukcji RAISE,",
          "correct": true
        },
        {
          "answer": "po słowie kluczowym WHEN,",
          "correct": true
        }
      ]
    },
    {
      "question": "Trigger (wyzwalacz) tabelowy może zostać uruchomiony:",
      "id": 732,
      "comments": [
        {
          "author": "~prezes@89.68.*.*",
          "comment": "4 odpowiedź mi nie pasuje. Wynika z niej, że wyzwalacz może być uruchomiony przed operacją, a następnie po operacji na tabeli, co chyba nie jest możliwe. Jak zwykle, kluczowa interpretacja zdania :|",
          "date": "28-01-2014 17:26:51"
        },
        {
          "author": "~SM@87.204.*.*",
          "comment": "Ja w sumie bym się też przychylił do tego, że i przed, i po nie może być, dokumentacja Oracle'a mówi jasno, że albo przed albo po.",
          "date": "28-01-2014 23:14:11"
        },
        {
          "author": "~Archi@89.72.*.*",
          "comment": "Też bym to wyrzucił.",
          "date": "28-01-2014 23:44:22"
        },
        {
          "author": "mykhi",
          "comment": "ok odznaczam.",
          "date": "29-01-2014 08:32:56"
        },
        {
          "author": "~Murek1993@78.11.*.*",
          "comment": "Dla jednej tabeli można utworzyć kilka wyzwalaczy. Kolejność uruchamiania (odpalania) wyzwalaczy jest następująca:\nWyzwalacz przed instrukcją,\nwyzwalacz przed pierwszym wierszem, na którym operuje instrukcja,\nwyzwalacz po pierwszym wierszu, na którym operuje instrukcja,\n…\nwyzwalacz przed ostatnim wierszem,\nwyzwalacz po ostatnim wierszu,\nwyzwalacz po instrukcji",
          "date": "03-07-2015 14:58:07"
        }
      ],
      "answers": [
        {
          "answer": "przed operacją na tabeli",
          "correct": true
        },
        {
          "answer": "po operacji na tabeli",
          "correct": true
        },
        {
          "answer": "bez związku z operacjami na tabeli",
          "correct": false
        },
        {
          "answer": "przed i po operacji na tabeli",
          "correct": false
        }
      ]
    },
    {
      "question": "Dla każdej tabeli można określić",
      "id": 733,
      "comments": [
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "\"maksymalnie 12 typów wyzwalaczy\" jest również prawidłową odpowiedzią. Tutaj kluczowe jest słowo \"typów\". Uzasadnienie w punkcie \"Wyzwalacze bazy danych\" pod tym adresem: http://edu.pjwstk.edu.pl/wyklady/sbd/scb/w6.htm",
          "date": "02-02-2013 18:31:30"
        },
        {
          "author": "mykhi",
          "comment": "poprawilem.",
          "date": "02-02-2013 19:53:23"
        }
      ],
      "answers": [
        {
          "answer": "maksymalnie 2 typy wyzwalaczy",
          "correct": false
        },
        {
          "answer": "maksymalnie 12 typów wyzwalaczy",
          "correct": true
        },
        {
          "answer": "maksymalnie 12 wyzwalaczy",
          "correct": false
        },
        {
          "answer": "dowolną ilość wyzwalaczy",
          "correct": true
        }
      ]
    },
    {
      "question": "Polecenia ROLLBACK i COMMIT dotyczą poleceń SQL",
      "id": 734,
      "comments": [
        {
          "author": "~kelu@84.10.*.*",
          "comment": "btw, ta ostatnia odpowiedź do końca nie jest ścisła. Chodzi o DMLe oczywiście, bo na przykład TRUNCATE modyfikuje zawartość tabeli jakby nie patrzeć, a w Oraclu nie można go ROLLBACKnąć.",
          "date": "07-09-2014 12:15:03"
        },
        {
          "author": "~df@91.207.*.*",
          "comment": "Dokładnie też o tym pomyślałem. TRUNCATE jest poleceniem SQLowym, ale w Oraclu nie można go rollbackować, a zmienia zawartość tabeli - raz na zawsze.",
          "date": "10-07-2020 12:11:59"
        }
      ],
      "answers": [
        {
          "answer": "tylko INSERT, UPDATE, SELECT",
          "correct": false
        },
        {
          "answer": "tylko INSERT, UPDATE, SELECT, DELETE",
          "correct": false
        },
        {
          "answer": "tylko SELECT, INSERT, UPDATE, SELECT, DELETE",
          "correct": false
        },
        {
          "answer": "wszystkich poleceń SQL zmieniających zawartość  tabel",
          "correct": true
        }
      ]
    },
    {
      "question": "W PL/SQL wynik działania instrukcji SELECT może zostać zapisany w postaci",
      "id": 735,
      "comments": [
        {
          "author": "~anon@89.79.*.*",
          "comment": "Tabela też(?).\nCREATE TABLE tab1 AS SELECT * FROM istniejacatabela;",
          "date": "26-06-2014 23:18:28"
        },
        {
          "author": "~anon@89.78.*.*",
          "comment": "Tak, można też wykorzystać \nINSERT INTO table2 SELECT * FROM table1;",
          "date": "07-09-2014 08:46:31"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "INSERT INTO table2 SELECT * FROM table1; to nie jest zapisanie wyniku działąnia instrukcji SELECT. To jest wykonanie INSERTa przy użyciu gotowych danych wyciągniętych SELECTem, ale to dwie różne rzeczy. tak samo z tym CREATE TABLE. W tym pytaniu chodzi o wynik działania instrukcji SELECT, a nie wykorzystanie SELECTa w innych instrukcjach.",
          "date": "07-09-2014 10:15:08"
        }
      ],
      "answers": [
        {
          "answer": "tabeli",
          "correct": false
        },
        {
          "answer": "kursora",
          "correct": true
        },
        {
          "answer": "perspektywy",
          "correct": false
        },
        {
          "answer": "zmiennej",
          "correct": true
        }
      ]
    },
    {
      "question": "Klauzula \"DECLARE Dane_Osoby Osoba%ROWTYPE\" jest w PL/SQL",
      "id": 736,
      "comments": [
        {
          "author": "~SM@78.133.*.*",
          "comment": "Mam wątpliwości, co do tego pytania, gdyż nie jest to wg mnie definicja typu. Wykład mówi tak:\n\"W PL/SQL jest możliwość użycia zmiennych \"wierszowych\", na których można zapamiętać cały wiersz pochodzący z tabeli. Dostęp do poszczególnych pól wiersza odbywa się tak, jak w przypadku rekordów, przez kropkę i podanie nazwy kolumny.\"\nZaś jako przykład podaje:\nDECLARE\n  rek_osob Emp%ROWTYPE; /* Typ wierszowy */\nRównież dokumentacja Oracle nie mówi nic w charakterze definiowania typów słowem %ROWTYPE, a jedynie o deklaracji:\n\"The %ROWTYPE attribute lets you declare a record that represents a row in a table or view.\"\nTakże moim zdaniem jest to jedynie deklaracja zmiennej, w domyśle: zmiennej rekordowej (wierszowej).\n",
          "date": "27-01-2014 10:34:30"
        },
        {
          "author": "~anon@89.79.*.*",
          "comment": "\"Variables declared using %ROWTYPE are treated like those declared using a datatype name.\"\nwięc w sumie może być ;)\n\nJeśli czwarte to też i pierwsze, prawda? Czwarte to doprecyzowane pierwsze?",
          "date": "26-06-2014 23:29:42"
        },
        {
          "author": "~anon@160.83.*.*",
          "comment": "Dokładnie tak A i C",
          "date": "29-06-2017 15:40:32"
        },
        {
          "author": "~anon@148.81.*.*",
          "comment": "Bardziej A, D.",
          "date": "01-07-2017 15:54:25"
        },
        {
          "author": "~OCB@5.173.*.*",
          "comment": "A i D",
          "date": "13-02-2019 17:45:27"
        }
      ],
      "answers": [
        {
          "answer": "deklaracją zmiennej",
          "correct": false
        },
        {
          "answer": "deklatracją nowego rekordu",
          "correct": false
        },
        {
          "answer": "deklaracją nowego typu zmiennej",
          "correct": false
        },
        {
          "answer": "deklaracją zmiennej wraz z definicją jej typu",
          "correct": true
        }
      ]
    },
    {
      "question": "Kursor w PL/SQL to",
      "id": 737,
      "comments": null,
      "answers": [
        {
          "answer": "typ zmiennej",
          "correct": false
        },
        {
          "answer": "rodzaj procedury",
          "correct": false
        },
        {
          "answer": "obiekt o określonych właściwościach i metodach",
          "correct": true
        },
        {
          "answer": "funkcja debuggera",
          "correct": false
        }
      ]
    },
    {
      "question": "Instrukcja FETCH jest używana w kursorze PL/SQL w celu",
      "id": 738,
      "comments": [
        {
          "author": "~anon@87.205.*.*",
          "comment": "Myślę, że poprawna jest tylko ostatnia odpowiedź. Po fetch-u kursor przestawiany jest na następny \"wiersz\"",
          "date": "06-02-2013 21:08:18"
        },
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Według mnie odwrotnie - najpierw przejście do następnego rekordu, a potem pobranie jego zawartości.",
          "date": "06-02-2013 22:37:16"
        },
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Potwierdzam. Wikipedia mówi: \"The cursor is positioned BEFORE the first row in the result set\".\n\nŹródło: http://en.wikipedia.org/wiki/Cursor_(databases)",
          "date": "06-02-2013 22:43:06"
        },
        {
          "author": "~K@83.6.*.*",
          "comment": "Na teście końcowym poprawne były 3 odpowiedzi.",
          "date": "10-08-2013 21:44:59"
        },
        {
          "author": "~rtsaphir@83.6.*.*",
          "comment": "poprawne są odpowiedzi 1,2 i 4 tak wynika z quizu ze strony edu i na egzaminie też tak było",
          "date": "15-09-2013 12:26:22"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam",
          "date": "15-09-2013 12:44:38"
        }
      ],
      "answers": [
        {
          "answer": "przejścia do następnego rekordu",
          "correct": true
        },
        {
          "answer": "pobrania zawartości rekordu ze źródła danych",
          "correct": true
        },
        {
          "answer": "przejścia do następnego rekordu i usunięcia poprzedniego rekordu",
          "correct": false
        },
        {
          "answer": "pobrania zawartości rekordu ze źródła danych i przejścia do następnego rekordu",
          "correct": true
        }
      ]
    },
    {
      "question": "Funkcja NVL służy do",
      "id": 739,
      "comments": null,
      "answers": [
        {
          "answer": "Zamiany napotkanej w tabeli wartości \"NULL\" na zero",
          "correct": false
        },
        {
          "answer": "Zamiany napotkanej w tabeli wartości z \"NULL\" na podaną w argumencie wartość",
          "correct": true
        },
        {
          "answer": "Zamiany wartości zmiennej z \"NULL\" na podaną w argumencie wartość",
          "correct": true
        },
        {
          "answer": "Zamiany wartości podanej w argumencie zmiennej lub komórki perspektywy  z \"NULL\" na podaną w drugim argumencie wartość",
          "correct": false
        }
      ]
    },
    {
      "question": "Użycie klauzuli UNQUE w deklaracji pola tabeli instrukcji CREATE TABLE oznacza, że:",
      "id": 740,
      "comments": [
        {
          "author": "~anon@89.67.*.*",
          "comment": "tutaj mialem zaznaczana na tescie prawidlowa odpowiedz tez ta  ze na tej kolumnie (polu) zostanie automatycznie zalozony indeks",
          "date": "05-02-2013 08:33:37"
        },
        {
          "author": "~anon@89.68.*.*",
          "comment": "true. unique tworzy klucz jednoznaczny a indeks jest automatycznie zakladany na kolumnach tworzących klucz jednoznaczny.",
          "date": "05-02-2013 17:51:18"
        },
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Potwierdzam. Wykład mówi: \"Więzy klucza jednoznacznego UNIQUE – wartości w określonych kolumnach jednoznacznie identyfikują wiersz tabeli. W kolumnach klucza jednoznacznego jest dozwolona pseudo-wartość NULL . Automatycznie jest zakładany indeks na kolumnach tworzących klucz jednoznaczny. Może być określony więcej niż jeden klucz jednoznaczny dla jednej tabeli.\"\nŹródło: http://edu.pjwstk.edu.pl/wyklady/sbd/scb/w4.htm",
          "date": "05-02-2013 18:51:21"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam.",
          "date": "06-02-2013 00:45:07"
        },
        {
          "author": "~Murek1993@78.11.*.*",
          "comment": "Potwierdzam index jest zakladany",
          "date": "04-07-2015 18:41:47"
        },
        {
          "author": "~anon@5.173.*.*",
          "comment": "Odpowiedz c jest błędna, bo mogą się powtarzać jeśli jest kilka rekordów o wartości null",
          "date": "15-02-2019 02:05:35"
        },
        {
          "author": "~zgadza_sie@162.158.*.*",
          "comment": "https://stackoverflow.com/questions/20154033/allow-null-in-unique-column",
          "date": "29-06-2019 21:23:20"
        },
        {
          "author": "~df@91.207.*.*",
          "comment": "Odpowiedź C jest poprawna, ponieważ NULL nie jest wartością. Jest to symbol / znak zamienny jako brak.",
          "date": "10-07-2020 12:24:40"
        }
      ],
      "answers": [
        {
          "answer": "w tym polu nie może pojawić się wartość NULL",
          "correct": false
        },
        {
          "answer": "w żadnym innym polu tej tabeli nie można użyć klauzuli UNIQUE",
          "correct": false
        },
        {
          "answer": "wartości w tym polu nie mogą się powtarzać",
          "correct": true
        },
        {
          "answer": "na tej kolumnie (polu) zostanie automatycznie zalozony indeks",
          "correct": true
        }
      ]
    },
    {
      "question": "Użycie klauzuli PRIMARY KEY deklaracji pola tabeli instrukcji CREATE TABLE powoduje, że:",
      "id": 741,
      "comments": [
        {
          "author": "~sng@84.10.*.*",
          "comment": "Wydaje mi się, że wszystkie odpowiedzi są poprawne. Primary key może zostać użyty tylko raz: http://www.w3schools.com/sql/sql_primarykey.asp",
          "date": "04-02-2012 20:15:43"
        },
        {
          "author": "~H.@94.75.*.*",
          "comment": "Ale klucz główny może się składać z więcej niż jednego pola.",
          "date": "06-02-2012 02:20:42"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "potwierdzam wszystkie prawidlowe tak mi wyswietlilo na tescie",
          "date": "05-02-2013 08:58:45"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam.",
          "date": "05-02-2013 11:02:48"
        }
      ],
      "answers": [
        {
          "answer": "To pole staje się polem klucz głównego",
          "correct": true
        },
        {
          "answer": "W żadnym innym polu tej tabeli nie może zostać użyta klauzula PRIMARY KEY",
          "correct": true
        },
        {
          "answer": "W polu yum nie może wystąpić wartość \"NULL\"",
          "correct": true
        },
        {
          "answer": "Na tej kolumnie (polu) zostanie automatycznie założony indeks",
          "correct": true
        }
      ]
    },
    {
      "question": "Perspektywa (View) w PL/SQL",
      "id": 742,
      "comments": [
        {
          "author": "~anon@46.229.*.*",
          "comment": "zamiast d powinno być a ",
          "date": "29-06-2014 11:04:06"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "dokladnie A jest poprawne",
          "date": "01-07-2017 14:05:15"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "A nie jest poprawne - zwykła perspektywa nie przechowuje żadnych danych, przy każdym odwołaniu do niej dane liczone są na nowo. Odpowiedzi są zaznaczone OK",
          "date": "01-07-2017 14:22:50"
        }
      ],
      "answers": [
        {
          "answer": "Jest obiektem przechowującym rekordy wybrane poleceniem SELECT",
          "correct": false
        },
        {
          "answer": "Jest obiektem utworzonym w oparciu o instrukcję SELECT",
          "correct": true
        },
        {
          "answer": "Może zostać użyta tak, jak by była tabelą np. w instrukcji SELECT, INSERT, UPDATE",
          "correct": true
        },
        {
          "answer": "Wiersze (rekordy) perspektywy nie są przechowywane w bazie danych",
          "correct": true
        }
      ]
    },
    {
      "question": "Instrukcja SELECT Table_Name FROM User_Tables",
      "id": 743,
      "comments": [
        {
          "author": "~morawa@178.36.*.*",
          "comment": "Zwraca nazwy tabel znajdujących się w obszarze tabel użytkownika ?\n",
          "date": "04-02-2013 19:35:15"
        },
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Według wykładu instrukcja ta \"wypisuje nazwy tabel, których właścicielem jest dany użytkownik\". Czyli też obstawiam, że prawidłową odpowiedzią jest \"Zwraca nazwy tabel znajdujących się w obszarze tabel użytkownika\".\n\nŹródło: http://edu.pjwstk.edu.pl/wyklady/sbd/scb/rW3.htm",
          "date": "04-02-2013 19:51:25"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam.",
          "date": "04-02-2013 20:32:30"
        }
      ],
      "answers": [
        {
          "answer": "Wypisuje nazwy kolumn z tabeli User_Tables",
          "correct": false
        },
        {
          "answer": "Wypisuje wszystkie rekordy z perspektywy User_Tables",
          "correct": false
        },
        {
          "answer": "Zwraca nazwy tabel znajdujących się w obszarze tabel użytkownika",
          "correct": true
        },
        {
          "answer": "Zwraca nazwy tabel utworzonych przez użytkownika",
          "correct": false
        }
      ]
    },
    {
      "question": "Sekwencja (SEQUENCE) to",
      "id": 744,
      "comments": [
        {
          "author": "~Radek@89.78.*.*",
          "comment": "SEQUENCE służy do generowania kolejnych numerów rekordów w tabeli.",
          "date": "22-06-2014 16:42:02"
        },
        {
          "author": "~Domka@37.152.*.*",
          "comment": "W systemie Oracle jest specjalny obiekt - sekwencja (ang. sequence) przechowywany w bazie danych, który służy do generowania jednoznacznych numerów dla wartości kluczy głównych i jednoznacznych",
          "date": "01-07-2015 19:27:44"
        },
        {
          "author": "~Domka@37.152.*.*",
          "comment": "W systemie Oracle jest specjalny obiekt - sekwencja (ang. sequence) przechowywany w bazie danych, który służy do generowania jednoznacznych numerów dla wartości kluczy głównych i jednoznacznych",
          "date": "01-07-2015 19:27:44"
        },
        {
          "author": "~anon@89.230.*.*",
          "comment": "to co w koncu\n",
          "date": "27-01-2020 22:11:08"
        },
        {
          "author": "~df@91.207.*.*",
          "comment": "Imo D jest poprawne. Sekwencja jest obiektem, który może służy do generowania wartości dowolnych kolumn. Zazwyczaj używa się go do PK, ale przede wszystkim chodzi o autonumerację:\ncol INT seq_name.nextval\nPrzykłady:\nid NUMBER DEFAULT t1_seq.NEXTVAL\nid INT GENERATED BY DEFAULT AS IDENTITY (START WITH 1) NOT NULL PRIMARY KEY\n\nA zatem to jest obiekt pomocniczy (a co ważne: opcjonalny) do tworzenia wartości kolumn z defaultu",
          "date": "10-07-2020 12:33:18"
        }
      ],
      "answers": [
        {
          "answer": "Ciąg instrukcji SQL",
          "correct": false
        },
        {
          "answer": "Obiekt PL/SQL przechowujący procedury, funkcje i wyzwalacze",
          "correct": false
        },
        {
          "answer": "Obiekt przechowywyany w bazie danych, służący do generowania kluczy głównych i jednozancznych",
          "correct": true
        },
        {
          "answer": "Typ zmiennej w PL/SQL której użycie generuje autonumerację rekordów tabeli",
          "correct": false
        }
      ]
    },
    {
      "question": "Instrukcja COMMIT",
      "id": 745,
      "comments": [
        {
          "author": "~anon@89.67.*.*",
          "comment": "Moim zdaniem poprawna jest rowniez o trwalosci zmiany zawartosci w tabeli.\n\n\"Symetryczną operacją do ROLLBACK jest COMMIT, która zatwierdza zmiany w bazie danych bez możliwości późniejszego ich wycofania. Reasumując, użytkownik lub aplikacja po wykonaniu instrukcji wchodzących w skład transakcji, albo przekazuje do wykonania instrukcję COMMIT - zatwierdź zmiany i zakończ transakcję, albo przekazuje do wykonania instrukcję ROLLBACK - wycofaj zmiany i zakończ transakcję.\"\n\nPytanie co rozumiemy przes slowo trwale. Czy to ze juz nigdy nic nie zmienimy czy trwale to znaczy nie mozna zrobic rollbacka i trzeba sie odwolywac do dziennika powtorzen.",
          "date": "27-06-2013 18:17:10"
        },
        {
          "author": "~df@91.207.*.*",
          "comment": "Wg. mnie tylko C, ponieważ COMMIT oraz ROLLBACK dokonują się w obrębie aktualnej transakcji (BEGIN ... END), a zatem nie do ostatniego polecenia COMMIT albo ROLLBACK. Może tak być ale zdecydowanie nie musi.",
          "date": "10-07-2020 12:35:14"
        }
      ],
      "answers": [
        {
          "answer": "Dotyczy ostatnio wydanego polecenia SELECT, UPDATE albo DELETE",
          "correct": false
        },
        {
          "answer": "Dotyczy wszystkich poleceń SELECT, INSERT, UPDATE albo DELETE wydanych od ostatniego polecenia ROLLBACK",
          "correct": false
        },
        {
          "answer": "Dokonuje trwałej zmiany w zawartości table bazy danych",
          "correct": true
        },
        {
          "answer": "Wszystkich poleceń INSERT, UPDATE albo DELETE wydanych od ostatniego polecenia COMMIT albo ROLLBACK",
          "correct": true
        }
      ]
    },
    {
      "question": "Instrukcja CREATE PROCEDURE może się pojawić:",
      "id": 746,
      "comments": [
        {
          "author": "~anon@91.230.*.*",
          "comment": " \"Jest także możliwość definiowania funkcji i procedur w blokach PL/SQL; ich użycie jest wtedy ograniczone do tego bloku.\" http://edu.pjwstk.edu.pl/wyklady/sbd/scb/w6.htm - wynika z tego, że w bloku plsql jest także poprawna",
          "date": "29-06-2014 13:41:08"
        },
        {
          "author": "~ziom@85.222.*.*",
          "comment": "up",
          "date": "01-02-2015 12:36:12"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "Definiowanie procedur jest dozwolone, ale nie za pomocą CREATE PROCEDURE. Spróbujcie.",
          "date": "01-07-2017 10:00:08"
        }
      ],
      "answers": [
        {
          "answer": "w bloku PL/SQL,",
          "correct": false
        },
        {
          "answer": "w SQL*Plusie,",
          "correct": true
        },
        {
          "answer": "w innej procedurze,",
          "correct": false
        },
        {
          "answer": "w wyzwalaczu.",
          "correct": false
        }
      ]
    },
    {
      "question": "Instrukcja CREATE FUNCTION może się pojawić:",
      "id": 747,
      "comments": null,
      "answers": [
        {
          "answer": "w bloku PL/SQL,",
          "correct": false
        },
        {
          "answer": "w SQL*Plusie,",
          "correct": true
        },
        {
          "answer": "w innej funkcji,",
          "correct": false
        },
        {
          "answer": "w wyzwalaczu.",
          "correct": false
        }
      ]
    },
    {
      "question": "Instrukcja CREATE TRIGGER może się pojawić:",
      "id": 748,
      "comments": [
        {
          "author": "~Dobosz@78.8.*.*",
          "comment": "tu jest błąd.\nPowinno być \\\"w bloku PL/SQL,\\\". SQL*Plusie pozwala na zarządzanie bazą zdalnie, chyba nawet tworzenie triggerów, ale cały czas jest to blok PL/SQL. Chyba...",
          "date": "05-02-2012 16:22:46"
        },
        {
          "author": "~MSiwak@77.255.*.*",
          "comment": "Jest dobrze CREATE TIGGER to polecenie SQL które może zostać wykonane przez Klienta SQL którym jest np. SQL plus. Co to są bloki pl/sql masz tutaj http://pl.wikipedia.org/wiki/PL/SQL i nie możesz utworzyć wyzwalacza w żadnym z nich",
          "date": "05-02-2012 17:10:47"
        },
        {
          "author": "~anon@81.15.*.*",
          "comment": "to jest wypowieź Matejewskiego: \"W obu środowiskach (ORACLE i MS SQL Server) należy wykonać CO NAJMNIEJ dwie procedury i dwa wyzwalacze. W jednym z tych obiektów należy użyć kursora  - w T-SQL może to być w wyzwalaczu lub procedurze, w PL/SQL w procedurze. W PL/SQL jeden z wyzwalaczy ma być FOR EACH ROW.\" z tego wynika że pierwsze jest dobrze",
          "date": "29-01-2016 14:27:37"
        },
        {
          "author": "~anon@178.42.*.*",
          "comment": "w BLOKU pl/sql . Tu masz wyjasnienie : http://edu.pjwstk.edu.pl/wyklady/sbd/scb/w5.html",
          "date": "29-01-2016 16:20:05"
        }
      ],
      "answers": [
        {
          "answer": "w bloku PL/SQL,",
          "correct": false
        },
        {
          "answer": "w SQL*Plusie,",
          "correct": true
        },
        {
          "answer": "w procedurze,",
          "correct": false
        },
        {
          "answer": "w innym wyzwalaczu.",
          "correct": false
        }
      ]
    },
    {
      "question": "Instrukcja CREATE PACKAGE może się pojawić:",
      "id": 749,
      "comments": null,
      "answers": [
        {
          "answer": "w bloku PL/SQL,",
          "correct": false
        },
        {
          "answer": "w wyzwalaczu",
          "correct": false
        },
        {
          "answer": "w innym pakiecie,",
          "correct": false
        },
        {
          "answer": "w skrypcie SQL*Plus,",
          "correct": true
        }
      ]
    },
    {
      "question": "Instrukcja CREATE PACKAGE BODY może się pojawić:",
      "id": 750,
      "comments": [
        {
          "author": "~ktw@178.36.*.*",
          "comment": "poprawna to 'w pakiecie' zamiast 'w skrypcie sql*plus'",
          "date": "03-02-2014 11:51:24"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "nie zgadzam się, jest poprawnie zaznaczone. Czemu uważasz tak jak napisałeś?",
          "date": "07-09-2014 12:25:07"
        },
        {
          "author": "~anon@84.10.*.*",
          "comment": "Przykład: http://psoug.org/snippet/Create-Package_450.htm",
          "date": "07-09-2014 12:25:53"
        },
        {
          "author": "~PCH@89.72.*.*",
          "comment": "Czy poprawne będą w takim razie 2 odpowiedzi? ",
          "date": "29-01-2018 19:29:27"
        },
        {
          "author": "~anon@89.64.*.*",
          "comment": "Nie, w kolegi przykładzie CREATE PACKAGE BODY jest poza pakietem",
          "date": "01-02-2019 21:49:09"
        }
      ],
      "answers": [
        {
          "answer": "w bloku PL/SQL,",
          "correct": false
        },
        {
          "answer": "w wyzwalaczu",
          "correct": false
        },
        {
          "answer": "w skrypcie SQL*Plus,",
          "correct": true
        },
        {
          "answer": "w pakiecie.",
          "correct": false
        }
      ]
    },
    {
      "question": "W wyzwalaczu można:",
      "id": 751,
      "comments": null,
      "answers": [
        {
          "answer": "poprosić użytkownika o podanie wartości zmiennej,",
          "correct": false
        },
        {
          "answer": "na ekranie użytkownika formularza wypisać ostrzeżenie,",
          "correct": false
        },
        {
          "answer": "sprawdzić czy wartości wstawiane do tabeli są poprawne,",
          "correct": true
        },
        {
          "answer": "utworzyć nową tabelę.",
          "correct": false
        }
      ]
    },
    {
      "question": "W wyzwalaczu można:",
      "id": 752,
      "comments": [
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "W wyzwalaczu nie można na ekranie użytkownika wypisać komunikatu o błędzie. Wyzwalacz jest związany z bazą danych, a nie z aplikacją kliencką.",
          "date": "03-02-2013 15:19:24"
        },
        {
          "author": "~anon@178.36.*.*",
          "comment": "jak wyżej :) do poprawy",
          "date": "06-02-2013 14:28:58"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam.",
          "date": "06-02-2013 21:56:59"
        }
      ],
      "answers": [
        {
          "answer": "poprosić użytkownika o podanie hasła,",
          "correct": false
        },
        {
          "answer": "na ekranie użytkownika wypisać komunikat o błędzie,",
          "correct": false
        },
        {
          "answer": "utworzyć nową tabelę.",
          "correct": false
        },
        {
          "answer": "porównać ze sobą nową i starą wartość w kolumnie przy UPDATE",
          "correct": true
        }
      ]
    },
    {
      "question": "W wyzwalaczu można:",
      "id": 753,
      "comments": [
        {
          "author": "~eth@62.121.*.*",
          "comment": "nie można w wyzwalaczach używać commit.",
          "date": "05-02-2012 13:53:17"
        },
        {
          "author": "~Fist@77.254.*.*",
          "comment": "Popieram. \nWikipedia:\nGłówne cechy wyzwalaczy to:\nnie mogą zatwierdzać transakcji (COMMIT) ...",
          "date": "03-02-2013 19:18:24"
        },
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "To samo mówi wykład (http://edu.pjwstk.edu.pl/wyklady/sbd/scb/rW6.htm): \"W  wyzwalaczach nie wolno używać instrukcji COMMIT ani ROLLBACK\".",
          "date": "03-02-2013 19:29:24"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam.",
          "date": "03-02-2013 19:30:13"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "btw, na MSSQL można używać COMMIT i ROLLBACK oraz używać DDLi",
          "date": "06-09-2014 14:01:52"
        },
        {
          "author": "~anon@89.74.*.*",
          "comment": "a wyzwalacz chyba nie wycofuje zmiany? czyli najpierw dopuszcza, a potem kasuje? czy B naprawdę jest ok?",
          "date": "16-01-2017 18:43:29"
        },
        {
          "author": "~anon@83.9.*.*",
          "comment": "ale tu nie masz nic o wycofywaniu, tylko ogolnie o tym, ze mozna zapobiec zmianom ;)",
          "date": "21-01-2017 17:43:39"
        },
        {
          "author": "~anon@31.0.*.*",
          "comment": "1 poprawne lub nie w zależności od języka. Kocham takie pytania...",
          "date": "08-02-2019 01:19:46"
        }
      ],
      "answers": [
        {
          "answer": "użyć instrukcji COMMIT,",
          "correct": false
        },
        {
          "answer": "nie dopuścić do wprowadzenia zmian,",
          "correct": true
        },
        {
          "answer": "sprawdzić czy wartości wstawiane do tabeli są poprawne,",
          "correct": true
        },
        {
          "answer": "utworzyć nową tabelę.",
          "correct": false
        }
      ]
    },
    {
      "question": "W wyzwalaczu można:",
      "id": 754,
      "comments": null,
      "answers": [
        {
          "answer": "poprosić użytkownika o podanie wartości zmiennej,",
          "correct": false
        },
        {
          "answer": "do kolumny klucza głównego tworzonego wiersza wygenerować nową wartość,",
          "correct": true
        },
        {
          "answer": "sprawdzić która jest godzina,",
          "correct": true
        },
        {
          "answer": "utworzyć nową tabelę.",
          "correct": false
        }
      ]
    },
    {
      "question": "W wyzwalaczu można:",
      "id": 755,
      "comments": [
        {
          "author": "~Radek@89.78.*.*",
          "comment": "Wydaje mi się że nie można przekazać informacji o błędzie do aplikacji",
          "date": "28-08-2014 21:09:19"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "można przekazać informację o błędzie, nie można wyświetlić u użytkownika takiej informacji, ale przekazać do aplikacji można.",
          "date": "07-09-2014 12:27:39"
        }
      ],
      "answers": [
        {
          "answer": "zrealizować akcję referencyjną NULLIFY,",
          "correct": false
        },
        {
          "answer": "przekazać informację o błędzie do aplikacji klienta,",
          "correct": true
        },
        {
          "answer": "sprawdzić czy w danej kolumnie wstawianego wiersza występuje NULL,",
          "correct": true
        },
        {
          "answer": "utworzyć nowy wyzwalacz.",
          "correct": false
        }
      ]
    },
    {
      "question": "Które mechanizmy wchodzą w skład oprogramowania strony serwera bazy danych:",
      "id": 756,
      "comments": null,
      "answers": [
        {
          "answer": "formularze,",
          "correct": false
        },
        {
          "answer": "deklaratywne więzy spójności,",
          "correct": true
        },
        {
          "answer": "wyzwalacze wierszowe,",
          "correct": true
        },
        {
          "answer": "obiekty OCX.",
          "correct": false
        }
      ]
    },
    {
      "question": "Wśród więzów spójności encji znajdują się:",
      "id": 757,
      "comments": null,
      "answers": [
        {
          "answer": "więzy klucza głównego,",
          "correct": true
        },
        {
          "answer": "więzy klucza obcego,",
          "correct": false
        },
        {
          "answer": "zdarzenia formularzowe,",
          "correct": false
        },
        {
          "answer": "więzy CHECK.",
          "correct": true
        }
      ]
    },
    {
      "question": "Wśród więzów spójności encji znajdują się:",
      "id": 758,
      "comments": null,
      "answers": [
        {
          "answer": "więzy klucza obcego,",
          "correct": false
        },
        {
          "answer": "więzy klucza jednoznacznego,",
          "correct": true
        },
        {
          "answer": "blokady,",
          "correct": false
        },
        {
          "answer": "więzy NOT NULL",
          "correct": true
        }
      ]
    },
    {
      "question": "Wśród więzów spójności referencyjnej znajdują się:",
      "id": 759,
      "comments": null,
      "answers": [
        {
          "answer": "więzy klucza głównego,",
          "correct": false
        },
        {
          "answer": "więzy klucza obcego,",
          "correct": true
        },
        {
          "answer": "więzy NOT NULL,,",
          "correct": false
        },
        {
          "answer": "więzy CHECK",
          "correct": false
        }
      ]
    },
    {
      "question": "Do zapewnienia więzów spójności referencyjnej służą:",
      "id": 760,
      "comments": [
        {
          "author": "~anon@178.36.*.*",
          "comment": "klauzula Check czy References jest poprawna bo nie wiem juz :) ..",
          "date": "05-02-2013 21:26:06"
        },
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Klauzura CHECK to więzy spójności encji (więzy, które ograniczają wartości, jakie mogą się pojawić w wierszu tabeli).\nKlauzura REFERENCES to więzy spójności referencyjnej, na przykład:\nMgr NUMBER\t REFERENCES Emp(Empno)\n\nŹródło:\nhttp://edu.pjwstk.edu.pl/wyklady/sbd/scb/rW4.htm",
          "date": "05-02-2013 23:13:16"
        },
        {
          "author": "~anon@160.83.*.*",
          "comment": "Tutaj poprawna jest odp tylko B",
          "date": "29-06-2017 16:31:14"
        },
        {
          "author": "~jol@89.70.*.*",
          "comment": "Nie wprowadzaj ludzi w błąd. Odpowiedzi są poprawne.\nZ wykładu 4 RBD:\n\"Są dwie podstawowe metody określania więzów spójności na serwerze: albo za pomocą mechanizmu deklaratywnych więzów spójności – w definicjach tabel (instrukcje CREATE TABLE i ALTER TABLE) albo za pomocą mechanizmu wyzwalaczy bazy danych, o których będzie mowa w wykładzie 6.\"",
          "date": "31-08-2017 14:02:57"
        }
      ],
      "answers": [
        {
          "answer": "wyzwalacze,",
          "correct": true
        },
        {
          "answer": "klauzula CHECK,",
          "correct": false
        },
        {
          "answer": "klauzula REFERENCES,",
          "correct": true
        },
        {
          "answer": "indeksy.",
          "correct": false
        }
      ]
    },
    {
      "question": "Do zapewnienia więzów spójności encji służą:",
      "id": 761,
      "comments": [
        {
          "author": "~anon@87.205.*.*",
          "comment": "na wykladzie jest tylko klauzula check,not null, klucz glowny i klucz jednoznaczny nic o wyzwalaczach",
          "date": "01-02-2015 22:06:30"
        },
        {
          "author": "~anon@94.254.*.*",
          "comment": "Wyzwalacz ( odpowiednio zaimplementowany ) dziala jak klauzula CHECK\n",
          "date": "01-02-2015 22:19:12"
        }
      ],
      "answers": [
        {
          "answer": "wyzwalacze,",
          "correct": true
        },
        {
          "answer": "klauzula CHECK,",
          "correct": true
        },
        {
          "answer": "klauzula REFERENCES,",
          "correct": false
        },
        {
          "answer": "indeksy.",
          "correct": false
        }
      ]
    },
    {
      "question": "Które akcje referencyjne są dostępne w Oracle:",
      "id": 762,
      "comments": [
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "W Oracle dostępne akcje referencyjne to jedynie: CASCADE oraz SET NULL.\n\nŹródło: http://edu.pjwstk.edu.pl/wyklady/sbd/scb/w4.htm",
          "date": "07-02-2013 01:00:27"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "Jw. poprawne zatem jest tylko Cascade w tym przypadku",
          "date": "28-06-2013 12:26:38"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam (odznaczam: RESTRICTED)",
          "date": "30-06-2013 16:51:28"
        }
      ],
      "answers": [
        {
          "answer": "RESTRICTED,",
          "correct": false
        },
        {
          "answer": "NULLIFY,",
          "correct": false
        },
        {
          "answer": "DEFAULT,",
          "correct": false
        },
        {
          "answer": "CASCADE.",
          "correct": true
        }
      ]
    },
    {
      "question": "SQL*Plus stanowi:",
      "id": 763,
      "comments": [
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "SQL*Plus nie jest językiem poleceń do bazy danych. Jest on klientem korzystającym z serwera bazy danych.\nZgodnie z Wikipedią, SQL*Plus jest \"terminalowym klientem baz danych Oracle\" (http://pl.wikipedia.org/wiki/SQL*Plus). Podobnie mówią wykłady z SBD: \"SQL*Plus jest standardowym, tekstowym interfejsem do baz danych Oracle\". W wykładzie jest również wzmianka, iż jest on \"oprogramowaniem klienckim\": http://edu.pjwstk.edu.pl/wyklady/sbd/scb/w1.htm",
          "date": "03-02-2013 15:52:29"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam.",
          "date": "03-02-2013 16:31:20"
        },
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Poprawka: Wykład 4 mówi o tym, że \"SQL*Plus jest językiem i jednocześnie interakcyjnym systemem umożliwiającym wprowadzanie i wykonywanie instrukcji języka SQL, skryptów złożonych z instrukcji języka SQL i SQL*Plus, bloków języka PL/SQL oraz wywołań procedur\". Czyli jednak odpowiedź \"język interakcyjnych poleceń do bazy danych\" też jest poprawną odpowiedzią (źródło: http://edu.pjwstk.edu.pl/wyklady/sbd/scb/rW4.htm). I teraz powstaje pytanie jak autor czwartej odpowiedzi rozumie słowo \"klient\"? Czy poprzez \"klienta\" rozumie człowieka, czy \"oprogramowanie klienckie\"? Od tego zależy, czy odpowiedź czwarta jest poprawna czy nie.",
          "date": "04-02-2013 02:20:20"
        },
        {
          "author": "mykhi",
          "comment": "nie wiem, ale cofam w takim razie do tego co było zakładając, że pierwotna odpowiedź skądkolwiek się wzięła - była poprawna.",
          "date": "04-02-2013 02:24:40"
        },
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Według Wikipedii: \"Klient – w informatyce – program komputerowy występujący w roli klienta wobec usług dostarczanych przez serwer\" (http://pl.wikipedia.org/wiki/Klient_(informatyka)) - czyli klientem może być aplikacja kliencka. Tak więc według mnie bezpieczniej jest zaznaczyć odpowiedź zarówno 3 jak i 4 jako poprawne, a w razie czego iść i się wykłócać o definicje słowa klient. :)",
          "date": "04-02-2013 02:25:13"
        },
        {
          "author": "~anon@188.65.*.*",
          "comment": "Podbijam 3 i 4",
          "date": "11-02-2019 12:50:16"
        }
      ],
      "answers": [
        {
          "answer": "część serwera bazy danych,",
          "correct": false
        },
        {
          "answer": "część serwera aplikacji Oracle,",
          "correct": false
        },
        {
          "answer": "język interakcyjnych poleceń do bazy danych,",
          "correct": true
        },
        {
          "answer": "klient korzystający z serwera bazy danych.",
          "correct": false
        }
      ]
    },
    {
      "question": "Deklaracja VARIABLE Klient VARCHAR2(30) jest częścią:",
      "id": 764,
      "comments": null,
      "answers": [
        {
          "answer": "SQL,",
          "correct": false
        },
        {
          "answer": "PL/SQL,",
          "correct": false
        },
        {
          "answer": "SQL*Plus,",
          "correct": true
        },
        {
          "answer": "prekompilatora do języka C.",
          "correct": false
        }
      ]
    },
    {
      "question": "Instrukcja ACCEPT Klient PROMPT \"Podaj nazwisko klienta: \" jest częścią:",
      "id": 765,
      "comments": null,
      "answers": [
        {
          "answer": "SQL,",
          "correct": false
        },
        {
          "answer": "PL/SQL,",
          "correct": false
        },
        {
          "answer": "SQL*Plus,",
          "correct": true
        },
        {
          "answer": "prekompilatora do języka C.",
          "correct": false
        }
      ]
    },
    {
      "question": "Kursor w PL/SQL służy do:",
      "id": 766,
      "comments": null,
      "answers": [
        {
          "answer": "Wprowadzania danych z klawiatury,",
          "correct": false
        },
        {
          "answer": "Przeglądania i wykonywania operacji na rekordach zwróconych przez zapytanie.",
          "correct": true
        },
        {
          "answer": "Przyspieszenia wykonywania zapytań.",
          "correct": false
        },
        {
          "answer": "Obsługi wyjątków.",
          "correct": false
        }
      ]
    },
    {
      "question": "Obiektowa baza danych w Oracle obejmuje:",
      "id": 767,
      "comments": null,
      "answers": [
        {
          "answer": "wielowymiarowość,",
          "correct": false
        },
        {
          "answer": "kolekcje,",
          "correct": true
        },
        {
          "answer": "typy obiektowe,",
          "correct": true
        },
        {
          "answer": "dziedziczenie.",
          "correct": true
        }
      ]
    },
    {
      "question": "Obiektowa baza danych w Oracle obejmuje:",
      "id": 768,
      "comments": null,
      "answers": [
        {
          "answer": "tabele zagnieżdżone,",
          "correct": true
        },
        {
          "answer": "hermetyzację obiektów,",
          "correct": false
        },
        {
          "answer": "perspektywy obiektowe,",
          "correct": true
        },
        {
          "answer": "transformację STAR.",
          "correct": false
        }
      ]
    },
    {
      "question": "W kolumnach bazy danych Oracle można przechowywywać:",
      "id": 769,
      "comments": null,
      "answers": [
        {
          "answer": "duże obiekty binarne,",
          "correct": true
        },
        {
          "answer": "duże obiekty znakowe,",
          "correct": true
        },
        {
          "answer": "wskaźniki do obiektów,",
          "correct": true
        },
        {
          "answer": "zagnieżdżone tabele.",
          "correct": true
        }
      ]
    },
    {
      "question": "Czy są takie instrukcje w Oracle:",
      "id": 770,
      "comments": null,
      "answers": [
        {
          "answer": "CREATE TYPE,",
          "correct": true
        },
        {
          "answer": "CREATE CLASS,",
          "correct": false
        },
        {
          "answer": "CREATE METHOD,",
          "correct": false
        },
        {
          "answer": "CREATE SERVLET.",
          "correct": false
        }
      ]
    },
    {
      "question": "W bazie danych Oracle można zmieniać zawartość następujących typów obiektów:",
      "id": 771,
      "comments": [
        {
          "author": "~BFILE@83.31.*.*",
          "comment": "Zgodnie z wykładem https://edux.pjwstk.edu.pl/mat/216/lec/rw7.htm \n\"W szczególności, procedura DBMS_LOB.Write(lobloc, amount, offset, text) dopisuje do istniejącej zawartości obiektu o lokalizatorze lobloc zawartość text o długości amount począwszy od miejsca offset... \" \"Jak widać, nie jest przewidziana możliwość wpisywania danych do obiektu typu BFILE!\"\n\nodpowiedz C jest nieprawidłowa. ",
          "date": "31-08-2016 21:20:44"
        },
        {
          "author": "~anon@5.173.*.*",
          "comment": "to jak w koncu?\n\n\n\n",
          "date": "08-02-2019 04:10:43"
        }
      ],
      "answers": [
        {
          "answer": "BLOB,",
          "correct": true
        },
        {
          "answer": "CLOB,",
          "correct": true
        },
        {
          "answer": "BFILE,",
          "correct": true
        },
        {
          "answer": "NCLOB.",
          "correct": true
        }
      ]
    },
    {
      "question": "Standard SQL określa następujące interfejsy programistyczne:",
      "id": 772,
      "comments": null,
      "answers": [
        {
          "answer": "PL/SQL,",
          "correct": false
        },
        {
          "answer": "Java,",
          "correct": false
        },
        {
          "answer": "moduły,",
          "correct": true
        },
        {
          "answer": "osadzony SQL.",
          "correct": true
        }
      ]
    },
    {
      "question": "Standard SQL określa następujące interfejsy programistyczne:",
      "id": 773,
      "comments": [
        {
          "author": "~Kamil@79.191.*.*",
          "comment": "A co z Interfejsem Poziomu Wywołań? http://edu.pjwstk.edu.pl/wyklady/rbd/scb/wyklad13/jdbc.htm",
          "date": "25-06-2013 23:46:29"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "Potwierdzam, interfejs wywołań też jest określony przez Standard ISO. Tu jest o tym trochę: http://en.wikipedia.org/wiki/Call_Level_Interface\n\nPytanie czy to oznacza jednoznacznie czy to standard SQL określa CLI? Czy CLI jest tylko dodatkiem",
          "date": "07-09-2014 10:24:29"
        },
        {
          "author": "~anon@78.11.*.*",
          "comment": "http://edu.pjwstk.edu.pl/wyklady/rbd/scb/rW13.htm",
          "date": "02-07-2015 23:34:32"
        },
        {
          "author": "~anon@178.36.*.*",
          "comment": "Interfes poziomu wywołań powinno być dobrze , na wykładzie jest brane pod uwagę ADO i ADO.NET a jak jest napisane wcześniej oba wywodzą się od CLI.",
          "date": "31-01-2016 16:43:50"
        }
      ],
      "answers": [
        {
          "answer": "PL/SQL,",
          "correct": false
        },
        {
          "answer": "Interfejs Poziomu Wywołań CLI,",
          "correct": false
        },
        {
          "answer": "moduły,",
          "correct": true
        },
        {
          "answer": "osadzony SQL.",
          "correct": true
        }
      ]
    },
    {
      "question": "Standard SQL określa następujące interfejsy programistyczne:",
      "id": 774,
      "comments": [
        {
          "author": "~ŚK@85.222.*.*",
          "comment": "pyt134 bez żadnej poprawnej odpowiedzi?!",
          "date": "05-02-2012 19:02:45"
        },
        {
          "author": "~anon@62.121.*.*",
          "comment": "osadzony sql, są dwie połączone odpowiedzi...",
          "date": "05-02-2012 21:26:22"
        },
        {
          "author": "~zbyś@178.162.*.*",
          "comment": "Interfejsy programistyczne określone przez Standard SQL: moduły, osadzony SQL,  Interfejs Poziomu Wywołań,bezpośredni SQL\nźródło: http://edu.pjwstk.edu.pl/wyklady/rbd/scb/wyklad13/jdbc.htm \nCzyli odpowiedź d) też jest OK",
          "date": "07-09-2014 21:23:30"
        },
        {
          "author": "~anon@162.158.*.*",
          "comment": "up",
          "date": "30-06-2019 00:15:27"
        },
        {
          "author": "mykhi",
          "comment": "zaznaczam d)",
          "date": "03-07-2019 13:49:35"
        }
      ],
      "answers": [
        {
          "answer": "osadzony SQL",
          "correct": true
        },
        {
          "answer": "ODBC,",
          "correct": false
        },
        {
          "answer": "JDBC.",
          "correct": false
        },
        {
          "answer": "Interfejs Poziomu Wywołań CLI",
          "correct": true
        }
      ]
    },
    {
      "question": "Osadzanie instrukcji SQL w interfejsie osadzonego SQL dotyczy:",
      "id": 775,
      "comments": null,
      "answers": [
        {
          "answer": "cache serwera bazy danych,",
          "correct": false
        },
        {
          "answer": "słownika danych,",
          "correct": false
        },
        {
          "answer": "języka programowania,",
          "correct": false
        },
        {
          "answer": "PL/SQL.",
          "correct": true
        }
      ]
    },
    {
      "question": "Instrukcje osadzonego SQL są poprzedzane słowem kluczowym:",
      "id": 776,
      "comments": [
        {
          "author": "~anon@89.67.*.*",
          "comment": "Z wykladu\n\n\"5.7 Osadzony SQL\n\nJedną z metod dostępu do bazy danych z programu zewnętrznego jest osadzanie instrukcji SQL wprost w tekście programu języka. Nazwy zmiennych języka zewnętrznego w instrukcji osadzonego SQL muszą być poprzedzone dwukropkiem.\n\nEXEC SQL BEGIN DECLARE SECTION;\nSQLSTATE CHAR(5);\nnum_prac NUMBER(4);\nEXEC SQL END DECLARE SECTION;\n. . . . . . . . .\nEXEC SQL DELETE FROM Emp WHERE Emp.Empno = :num_prac ;\nIF SQLSTATE = '00000' \nTHEN . . . . . . ; /* operacja usuwania powiodła się */\nELSE . . . . . . ; /* wystąpił wyjątek */\"\n\nEXEC SQL to poprawna odpowiedz",
          "date": "28-06-2013 12:31:37"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam (odznaczam EXEC zaznaczam EXEC SQL)",
          "date": "30-06-2013 16:54:04"
        }
      ],
      "answers": [
        {
          "answer": "EXEC,",
          "correct": false
        },
        {
          "answer": "DO,",
          "correct": false
        },
        {
          "answer": "EXEC SQL,",
          "correct": true
        },
        {
          "answer": "BEGIN.",
          "correct": false
        }
      ]
    },
    {
      "question": "Instrukcja \"SQLExecDirect(hstmt, (SQLCHAR *) sqlsource, SQL_NTS)\" dotyczy języka:",
      "id": 777,
      "comments": null,
      "answers": [
        {
          "answer": "PL/SQL,",
          "correct": false
        },
        {
          "answer": "osadzonego SQL,",
          "correct": false
        },
        {
          "answer": "Interfejsu Poziomu Wywołań,",
          "correct": true
        },
        {
          "answer": "ASP.",
          "correct": false
        }
      ]
    },
    {
      "question": "Interfejs JDBC może być używany w:",
      "id": 778,
      "comments": [
        {
          "author": "~bart@89.231.*.*",
          "comment": "Szczególnie interfejs JDBC stał się popularny i jest używany między innymi w:\n\nprogramach aplikacyjnych napisanych w Javie - po stronie klienta;\napletach czyli małych programach Javy realizowanych na przeglądarce użytkownika;\nserwletach czyli programach Javy spełniających rolę małych serwerów aplikacyjnych to jest programów realizujących przez sieć zlecenia użytkowników;\nprocedurach i funkcjach zakodowanych w Javie składowanych w bazie danych.\n\nCzy zgodnie z ostatnim pkt odp \"kodzie składowanym w bazie danych\" nie powinna być poprawna?",
          "date": "05-02-2013 21:05:20"
        },
        {
          "author": "~kogut@109.206.*.*",
          "comment": "wygląda na to , że też",
          "date": "03-07-2018 20:32:42"
        }
      ],
      "answers": [
        {
          "answer": "apletach,",
          "correct": true
        },
        {
          "answer": "serwletach,",
          "correct": true
        },
        {
          "answer": "kodzie składowanym w bazie danych,",
          "correct": false
        },
        {
          "answer": "programach aplikacyjnych.",
          "correct": true
        }
      ]
    },
    {
      "question": "W JDBC zbiór wyników zapytania znajduje się na obiekcie klasy:",
      "id": 779,
      "comments": null,
      "answers": [
        {
          "answer": "Rowset,",
          "correct": false
        },
        {
          "answer": "RecordSet,",
          "correct": false
        },
        {
          "answer": "ResultSet,",
          "correct": true
        },
        {
          "answer": "QuerySet.",
          "correct": false
        }
      ]
    },
    {
      "question": "W zapytaniu \"SELECT HelloWorld() FROM Dual;\" identyfikator HelloWorld może oznaczać:",
      "id": 780,
      "comments": [
        {
          "author": "~Radek@89.78.*.*",
          "comment": "Wydaje mi się że procedury nie można wywołać w zapytaniu SELECT",
          "date": "22-06-2014 16:47:28"
        },
        {
          "author": "~anon@87.239.*.*",
          "comment": "Mi też się tak wydaje w wykładzie jest przykład tylko z funkcją po instrukcji SELECT http://edu.pjwstk.edu.pl/wyklady/sbd/scb/rW6.htm",
          "date": "24-06-2014 18:22:55"
        },
        {
          "author": "~sbd@83.6.*.*",
          "comment": "sprawdzilem w sqldeveloperze :\ndla funkcji dziala, dla procedury nie dziala",
          "date": "22-01-2017 22:31:35"
        }
      ],
      "answers": [
        {
          "answer": "funkcję PL/SQL;",
          "correct": true
        },
        {
          "answer": "klasę Java;",
          "correct": false
        },
        {
          "answer": "funkcję PL/SQL związaną z metodą klasy Java;",
          "correct": false
        },
        {
          "answer": "procedurę PL/SQL.",
          "correct": true
        }
      ]
    },
    {
      "question": "Jako obiekty bazy danych Oracle można przechowywać kod języków:",
      "id": 781,
      "comments": null,
      "answers": [
        {
          "answer": "C,",
          "correct": true
        },
        {
          "answer": "Java,",
          "correct": true
        },
        {
          "answer": "PL/SQL,",
          "correct": true
        },
        {
          "answer": "VisualBasic.",
          "correct": true
        }
      ]
    },
    {
      "question": "Aplikacja wykonywana za pomocą internetowego modułu PLSQL  wykorzystuje:",
      "id": 782,
      "comments": null,
      "answers": [
        {
          "answer": "serwer WWW Apache;",
          "correct": false
        },
        {
          "answer": "powiązania ODBC",
          "correct": false
        },
        {
          "answer": "powiązania bazodanowe,",
          "correct": true
        },
        {
          "answer": "powiązania JDBC.",
          "correct": false
        }
      ]
    },
    {
      "question": "Aplikacja wykonywana za pomocą internetowego modułu PLSQL  wykorzystuje:",
      "id": 783,
      "comments": null,
      "answers": [
        {
          "answer": "powiązania bazodanowe,",
          "correct": true
        },
        {
          "answer": "transformację STAR,",
          "correct": false
        },
        {
          "answer": "procedury PL/SQL,",
          "correct": false
        },
        {
          "answer": "migawki.",
          "correct": false
        }
      ]
    },
    {
      "question": "Aplikacja wykonywana za pomocą Internet Information Servera wykorzystuje:",
      "id": 784,
      "comments": null,
      "answers": [
        {
          "answer": "ODBC,",
          "correct": false
        },
        {
          "answer": "powiązania bazodanowe,",
          "correct": true
        },
        {
          "answer": "wielowymiarowość,",
          "correct": false
        },
        {
          "answer": "skrypty Visual Basica.",
          "correct": false
        }
      ]
    },
    {
      "question": "Aplikacja ASP jest przechowywana jako:",
      "id": 785,
      "comments": null,
      "answers": [
        {
          "answer": "plik tekstowy,",
          "correct": true
        },
        {
          "answer": "plik binarny,",
          "correct": false
        },
        {
          "answer": "procedura w bazie danych,",
          "correct": false
        },
        {
          "answer": "biblioteka DLL.",
          "correct": false
        }
      ]
    },
    {
      "question": "W internetowej aplikacji PL/SQL przy dostępie do danych w bazie danych wykorzystuje się:",
      "id": 786,
      "comments": [
        {
          "author": "~anon@89.76.*.*",
          "comment": "Kursor też jest prawidłową odpowiądzia",
          "date": "05-02-2015 00:16:44"
        },
        {
          "author": "~anon@77.252.*.*",
          "comment": "anonku, mylisz sie",
          "date": "07-02-2016 18:07:56"
        }
      ],
      "answers": [
        {
          "answer": "protokół HTTP,",
          "correct": false
        },
        {
          "answer": "metodę GET,",
          "correct": false
        },
        {
          "answer": "instrukcję SELECT,",
          "correct": true
        },
        {
          "answer": "kursor.",
          "correct": false
        }
      ]
    },
    {
      "question": "Serwlet jest to:",
      "id": 787,
      "comments": [
        {
          "author": "~wąsik@159.205.*.*",
          "comment": "aplet != serwlet. Poprawną odpowiedzią powinno być obiekt klasy HttpServlet.",
          "date": "20-06-2014 21:23:44"
        },
        {
          "author": "~ziom@85.222.*.*",
          "comment": "up\n",
          "date": "01-02-2015 12:55:48"
        },
        {
          "author": "~anon@31.178.*.*",
          "comment": "może warto by zmienić:)",
          "date": "01-07-2017 09:56:06"
        },
        {
          "author": "~Kogut@83.24.*.*",
          "comment": "Up",
          "date": "06-07-2018 14:37:22"
        },
        {
          "author": "mykhi",
          "comment": "odznaczam a) zaznaczam c)",
          "date": "06-07-2018 17:15:33"
        },
        {
          "author": "~anon@94.254.*.*",
          "comment": "Miał być zaznaczony obiekt a nie metoda ",
          "date": "07-07-2018 08:59:32"
        },
        {
          "author": "mykhi",
          "comment": "ano, odznaczam c) zaznaczam a)",
          "date": "08-07-2018 22:30:46"
        }
      ],
      "answers": [
        {
          "answer": "aplet przechowywany po stronie serwera aplikacji,",
          "correct": false
        },
        {
          "answer": "obiekt klasy HttpServlet,",
          "correct": true
        },
        {
          "answer": "metoda klasy HttpServlet,",
          "correct": false
        },
        {
          "answer": "rodzaj sterownika JDBC.",
          "correct": false
        }
      ]
    },
    {
      "question": "Serwlet przy dostępie do danych w bazie danych wykorzystuje:",
      "id": 788,
      "comments": null,
      "answers": [
        {
          "answer": "serwer WWW Apache",
          "correct": false
        },
        {
          "answer": "protokół HTTP",
          "correct": false
        },
        {
          "answer": "powiązania bazodanowe,",
          "correct": true
        },
        {
          "answer": "powiązania JDBC.",
          "correct": false
        }
      ]
    },
    {
      "question": "Programista aplikacji internetowej w postaci serwletu opracowuje kod metod:",
      "id": 789,
      "comments": [
        {
          "author": "~Adziu@83.24.*.*",
          "comment": "Wydaje mi sie, że HttpServletRequest i HttpServletResponse to nie tyle metody co KLASY. ",
          "date": "22-06-2014 19:44:53"
        },
        {
          "author": "~Lukas@83.31.*.*",
          "comment": "Kolega ma rację. Poprawne odpowiedzi to a i b.",
          "date": "30-06-2014 00:38:07"
        },
        {
          "author": "~kogut@83.24.*.*",
          "comment": "potwierdzam",
          "date": "03-07-2018 14:20:01"
        },
        {
          "author": "~anon@46.112.*.*",
          "comment": "https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html\n\nAnalogicznie z respons'em",
          "date": "07-02-2019 21:06:11"
        }
      ],
      "answers": [
        {
          "answer": "doGet",
          "correct": true
        },
        {
          "answer": "doPost",
          "correct": true
        },
        {
          "answer": "HttpServletRequest",
          "correct": true
        },
        {
          "answer": "HttpServletResponse",
          "correct": true
        }
      ]
    },
    {
      "question": "Które metody dotyczą zachowania spójności danych przy współbieżnym dostępie:",
      "id": 790,
      "comments": null,
      "answers": [
        {
          "answer": "blokowanie pesymistyczne",
          "correct": true
        },
        {
          "answer": "przyznawanie uprawnień do obiektów w bazie danych",
          "correct": false
        },
        {
          "answer": "autoryzowanie dostępu",
          "correct": false
        },
        {
          "answer": "blokowanie optymistyczne",
          "correct": true
        }
      ]
    },
    {
      "question": "Które metody dotyczą możliwości odtworzenia danych po awarii dysku:",
      "id": 791,
      "comments": [
        {
          "author": "~anon@89.67.*.*",
          "comment": "Tutaj slowo \"dziennik\" jest niewystarczające by uznać ta odpowiedz za prawidlowa. Dziennik wycofan nie umozliwia odtworzenia bazy danych po awarii dysku, a dziennik powtorzen tak.",
          "date": "27-06-2013 18:19:54"
        },
        {
          "author": "~anon@89.74.*.*",
          "comment": "dziennik jak najbardziej...do tego jeszcze repliki i kopia zapasowa",
          "date": "30-06-2013 15:28:07"
        },
        {
          "author": "~kogut@109.206.*.*",
          "comment": " w takim razie co z tą repliką , ktoś coś wie ?\n",
          "date": "02-07-2018 22:42:12"
        }
      ],
      "answers": [
        {
          "answer": "dziennik",
          "correct": true
        },
        {
          "answer": "repliki",
          "correct": false
        },
        {
          "answer": "udostępnienie danych na stronach WWW",
          "correct": false
        },
        {
          "answer": "kopia zapasowa",
          "correct": true
        }
      ]
    },
    {
      "question": "Które metody dotyczą ochrony danych przed nieautoryzowanym dostępem:",
      "id": 792,
      "comments": null,
      "answers": [
        {
          "answer": "kopia zapasowa",
          "correct": false
        },
        {
          "answer": "wprowadzenie kont i haseł",
          "correct": true
        },
        {
          "answer": "słownik danych (metadane)",
          "correct": false
        },
        {
          "answer": "przyznawanie uprawnień do wykonywania operacji na obiektach",
          "correct": true
        }
      ]
    },
    {
      "question": "Własność szeregowalności transakcji oznacza:",
      "id": 793,
      "comments": null,
      "answers": [
        {
          "answer": "konieczność specyfikowania kolejności wykonywania transakcji",
          "correct": false
        },
        {
          "answer": "wymuszenie na systemie szeregowego wykonywania transakcji",
          "correct": false
        },
        {
          "answer": "współbieżną realizację transakcji tak jakby były one wykonywane jedna po drugiej",
          "correct": true
        },
        {
          "answer": "ustalenie priorytetu wykonywania transakcji",
          "correct": false
        }
      ]
    },
    {
      "question": "Dane słownika danych (metadane) są przechowywane w relacyjnej bazie danych:",
      "id": 794,
      "comments": null,
      "answers": [
        {
          "answer": "w specjalnym pliku binarnym w tym samym katalogu co pliki systemu zarządzania bazą danych",
          "correct": false
        },
        {
          "answer": "nie muszą być przechowywane w bazie danych",
          "correct": false
        },
        {
          "answer": "w specjalnej bazie danych (budowanej przez administratora)",
          "correct": false
        },
        {
          "answer": "w specjalnych tabelach w tej samej bazie danych",
          "correct": true
        }
      ]
    },
    {
      "question": "Do odtworzenia stanu bazy danych po awarii procesu użytkownika służą:",
      "id": 795,
      "comments": null,
      "answers": [
        {
          "answer": "dziennik powtórzeń,",
          "correct": false
        },
        {
          "answer": "pliki śladu,",
          "correct": false
        },
        {
          "answer": "segmenty wycofań,",
          "correct": true
        },
        {
          "answer": "kopia zapasowa.",
          "correct": false
        }
      ]
    },
    {
      "question": "Do odtworzenia stanu bazy danych po awarii procesu serwera służą:",
      "id": 796,
      "comments": null,
      "answers": [
        {
          "answer": "dziennik powtórzeń,",
          "correct": true
        },
        {
          "answer": "pliki śladu,",
          "correct": false
        },
        {
          "answer": "segmenty wycofań,",
          "correct": true
        },
        {
          "answer": "kopia zapasowa.",
          "correct": false
        }
      ]
    },
    {
      "question": "Do odtworzenia stanu bazy danych po awarii dysku z danymi służą:",
      "id": 797,
      "comments": [
        {
          "author": "~anon@89.67.*.*",
          "comment": "Segmenty wycofań nie mogą slużyć do odtworzenia stanu bazy po awarii dysku z danymi gdyż odpowiadają za wycofywanie transakcji i wielowersyjnosc. Po commicie wszelkie dane z dziennika wycofan ( segmentow wycofan) sa kasowane.\n\n\"Dziennik wycofań\n\nW celu umożliwienia wycofania transakcji SZBD zapisuje wszystkie zachodzące na stronach dyskowych zmiany w specjalnym dzienniku wycofań (ang. undo log) nazywanym w Oracle segmentami wycofań (ang. undo segments). Dziennik wycofań jest przechowywany razem z danymi w bazie danych. Gdy trzeba wycofać transakcję, system odczytuje w tył zapisy o zmianach wprowadzonych przez transakcję i przywraca poprzednie wartości danych w bazie danych - jednocześnie kasując rekordy dziennika wycofań.\"",
          "date": "27-06-2013 00:29:22"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "ale anonku, chodzi o przywrócenie stanu bazy czyli także transakcji do stanów w których były w momencie awarii. Wiadomo, że z dziennika wycofań nie przywrócimy struktury bazy, ale nie o to chodzi w tym pytaniu.",
          "date": "06-09-2014 14:51:43"
        }
      ],
      "answers": [
        {
          "answer": "dziennik powtórzeń,",
          "correct": true
        },
        {
          "answer": "pliki śladu,",
          "correct": false
        },
        {
          "answer": "segmenty wycofań,",
          "correct": true
        },
        {
          "answer": "kopia zapasowa.",
          "correct": true
        }
      ]
    },
    {
      "question": "Przy otwieraniu bazy danych przy powtórnym włączeniu komputera po nagłej awarii zasilania są używane:",
      "id": 798,
      "comments": null,
      "answers": [
        {
          "answer": "dziennik powtórzeń,",
          "correct": true
        },
        {
          "answer": "pliki śladu,",
          "correct": false
        },
        {
          "answer": "segmenty wycofań,",
          "correct": true
        },
        {
          "answer": "kopia zapasowa.",
          "correct": false
        }
      ]
    },
    {
      "question": "Rezerwowa baza danych pracująca w trybie STANDBY otrzymuje z głównej bazy danych:",
      "id": 799,
      "comments": null,
      "answers": [
        {
          "answer": "pliki z danymi,",
          "correct": false
        },
        {
          "answer": "dziennik powtórzeń,",
          "correct": false
        },
        {
          "answer": "zarchiwizowany dziennik powtórzeń,",
          "correct": true
        },
        {
          "answer": "nic nie otrzymuje.",
          "correct": false
        }
      ]
    },
    {
      "question": "Poziom izolacji transakcji READ UNCOMMITED obejmuje następujące własności:",
      "id": 800,
      "comments": null,
      "answers": [
        {
          "answer": "brak traconych modyfikacji,",
          "correct": true
        },
        {
          "answer": "nie-zatwierdzony odczyt,",
          "correct": true
        },
        {
          "answer": "nie-powtarzalny odczyt,",
          "correct": true
        },
        {
          "answer": "fantomy.",
          "correct": true
        }
      ]
    },
    {
      "question": "Poziom izolacji transakcji READ COMMITED obejmuje następujące własności:",
      "id": 801,
      "comments": [
        {
          "author": "~anon@89.67.*.*",
          "comment": "Jeszcze mialem taka poprawna odpowiedz:\nwidać zmiany wprowadzane przez inne transakcje, o ile tamte zakończyły się zatwierdzeniem",
          "date": "05-02-2013 08:51:54"
        },
        {
          "author": "mykhi",
          "comment": "dodałem...",
          "date": "05-02-2013 11:02:09"
        },
        {
          "author": "~anon@2a02:a318:c33f:6b80:9176:7e48:618d:b56b",
          "comment": "nie powtarzalny odczyt i fantomy to raczej są wtedy, kiedy jest ustawiony read uncommited. Read commited zapewnia że nie czytamy nic, co jest w trakcie modyfikacji czyż nie?",
          "date": "14-02-2020 23:23:25"
        }
      ],
      "answers": [
        {
          "answer": "brak traconych modyfikacji,",
          "correct": true
        },
        {
          "answer": "nie-zatwierdzony odczyt,",
          "correct": false
        },
        {
          "answer": "nie-powtarzalny odczyt,",
          "correct": true
        },
        {
          "answer": "fantomy.",
          "correct": true
        },
        {
          "answer": "widać zmiany wprowadzane przez inne transakcje, o ile tamte zakończyły się zatwierdzeniem",
          "correct": true
        }
      ]
    },
    {
      "question": "Poziom izolacji transakcji REPEATABLE READ obejmuje następujące własności:",
      "id": 802,
      "comments": null,
      "answers": [
        {
          "answer": "brak traconych modyfikacji,",
          "correct": true
        },
        {
          "answer": "nie-zatwierdzony odczyt,",
          "correct": false
        },
        {
          "answer": "nie-powtarzalny odczyt,",
          "correct": false
        },
        {
          "answer": "fantomy.",
          "correct": true
        }
      ]
    },
    {
      "question": "Poziom izolacji transakcji SERIALIZABLE obejmuje następujące własności:",
      "id": 803,
      "comments": null,
      "answers": [
        {
          "answer": "brak traconych modyfikacji,",
          "correct": true
        },
        {
          "answer": "nie-zatwierdzony odczyt,",
          "correct": false
        },
        {
          "answer": "nie-powtarzalny odczyt,",
          "correct": false
        },
        {
          "answer": "fantomy.",
          "correct": false
        }
      ]
    },
    {
      "question": "Domyślny poziom izolacji w Oracle obejmuje następujące własności:",
      "id": 804,
      "comments": null,
      "answers": [
        {
          "answer": "brak traconych modyfikacji,",
          "correct": true
        },
        {
          "answer": "nie-zatwierdzony odczyt,",
          "correct": false
        },
        {
          "answer": "nie-powtarzalny odczyt,",
          "correct": true
        },
        {
          "answer": "fantomy.",
          "correct": true
        }
      ]
    },
    {
      "question": "Przy normalnym otwieraniu bazy danych system korzysta z informacji zapisanych w:",
      "id": 805,
      "comments": null,
      "answers": [
        {
          "answer": "pliku kontrolnym,",
          "correct": false
        },
        {
          "answer": "pliku śladu,",
          "correct": false
        },
        {
          "answer": "dzienniku powtórzeń,",
          "correct": false
        },
        {
          "answer": "pliku inicjalizacyjnym instancji.",
          "correct": true
        }
      ]
    },
    {
      "question": "Które mechanizmy są używane do zapewnienia wielowersyjności w bazie danych:",
      "id": 806,
      "comments": [
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Segmenty wycofań. Dziennik powtórzeń chyba nie.\n\nŹródło: http://edu.pjwstk.edu.pl/wyklady/sbd/scb/rW13.htm",
          "date": "07-02-2013 01:43:39"
        },
        {
          "author": "~anon@178.36.*.*",
          "comment": "wielowersyjność - możliwość odczytywania danych zmienianych równocześnie przez inne transakcje w takiej postaci w jakiej istniały w pewnych chwilach w przeszłości (np. w chwili rozpoczynania się danego zapytania lub danej transakcji).\n\ndziennik powtórzeń - dziennik rejestrujący wszystkie zmiany zachodzące na stronach dyskowych umożliwiający odtworzenie bazy danych po wystąpieniu awarii.\n\nTakze, nie.",
          "date": "07-02-2013 02:06:00"
        },
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "\"W niektórych systemach używa się tylko dziennika powtórzeń, który, tak czy owak, zawiera w sobie informacje dziennika wycofań.\"",
          "date": "07-02-2013 02:14:21"
        },
        {
          "author": "~anon@178.36.*.*",
          "comment": "No, czyli dziennik powtorzen jest ok. Segment/dziennik wycofan byc moze tez, ale jak sam przytoczyles nie zawsze sie go uzywa.",
          "date": "07-02-2013 02:29:02"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "Pozwole sobie wkleic caly akapit :\n\n\"Są dwa rodzaje dzienników: dzienniki wycofań i dzienniki powtórzeń. Dziennik wycofań jest związany z wycofywaniem transakcji oraz z wielowersyjnością. Dziennik powtórzeń jest związany z odtwarzaniem bazy danych po awarii serwera lub nośnika danych. Ze względu na inne spełniane funkcje oba dzienniki zwykle są zapisywane osobno: dziennik wycofań razem z danymi w bazie danych, a dziennik powórzeń na innym nośniku danych niż pliki z danymi. W niektórych systemach używa się tylko dziennika powtórzeń, który, tak czy owak, zawiera w sobie informacje dziennika wycofań.\"\n\nWyraźnie napisane ze segmenty wycofan. Dzennik powtórzeń ZAWIERA w sobie segmenty wycofan, zatem cały dziennik powtórzen nie odpowiada za zapewnienie wielowersyjnosci zatem odpwiedz ta jest bledna. Poprawna to segmenty wycofan.",
          "date": "26-06-2013 19:50:08"
        },
        {
          "author": "~SM@78.133.*.*",
          "comment": "W wykładzie jak byk jest napisane:\n\"Są dwa rodzaje dzienników: dzienniki wycofań i dzienniki powtórzeń. Dziennik wycofań jest związany z wycofywaniem transakcji oraz z wielowersyjnością. Dziennik powtórzeń jest związany z odtwarzaniem bazy danych po awarii serwera lub nośnika danych.\"\nTakże trzecia odpowiedź jest poprawna, zaś pierwsza nie. Nie po to moim zdaniem jest w wykładzie cały akapit zatytuowany \"Dziennik wycofań i wielowersyjność\", żeby ta trzecie odpowiedź była błędna :)",
          "date": "27-01-2014 10:43:05"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "up",
          "date": "07-02-2019 18:24:38"
        },
        {
          "author": "mykhi",
          "comment": "zaznaczam c)",
          "date": "07-02-2019 19:09:44"
        }
      ],
      "answers": [
        {
          "answer": "dziennik powtórzeń,",
          "correct": true
        },
        {
          "answer": "pliki śladu,",
          "correct": false
        },
        {
          "answer": "segmenty wycofań,",
          "correct": true
        },
        {
          "answer": "kopia zapasowa.",
          "correct": false
        }
      ]
    },
    {
      "question": "Które mechanizmy są używane w bazie danych przy wykonywaniu transakcji typu READ ONLY:",
      "id": 807,
      "comments": null,
      "answers": [
        {
          "answer": "dziennik powtórzeń,",
          "correct": true
        },
        {
          "answer": "pliki śladu,",
          "correct": false
        },
        {
          "answer": "segmenty wycofań,",
          "correct": true
        },
        {
          "answer": "kopia zapasowa.",
          "correct": false
        }
      ]
    },
    {
      "question": "Które mechanizmy są używane do zapewnienia spójności bazy danych w środowisku współbieżnie wykonywanych transakcji:",
      "id": 808,
      "comments": null,
      "answers": [
        {
          "answer": "blokady,",
          "correct": true
        },
        {
          "answer": "perspektywy,",
          "correct": false
        },
        {
          "answer": "role,",
          "correct": false
        },
        {
          "answer": "wielowersyjność.",
          "correct": true
        }
      ]
    },
    {
      "question": "Przy wykonywaniu operacji ROLLBACK są wykorzystywane:",
      "id": 809,
      "comments": [
        {
          "author": "~mm@89.67.*.*",
          "comment": "a nie tylko segmenty wycofań?",
          "date": "01-07-2017 12:32:16"
        },
        {
          "author": "~podleeesa@89.230.*.*",
          "comment": "chyba tylko b",
          "date": "28-01-2020 12:38:40"
        }
      ],
      "answers": [
        {
          "answer": "dziennik powtórzeń,",
          "correct": true
        },
        {
          "answer": "segmenty wycofań,",
          "correct": true
        },
        {
          "answer": "kopia zapasowa,",
          "correct": false
        },
        {
          "answer": "pliki śladu.",
          "correct": false
        }
      ]
    },
    {
      "question": "Terminy atomowość-spójność-izolacja-trwałość oznaczane skrótem ACID dotyczą:",
      "id": 810,
      "comments": null,
      "answers": [
        {
          "answer": "modelu wykonywania transakcji w bazie danych,",
          "correct": true
        },
        {
          "answer": "modelu obliczeń w rozproszonej bazie danych,",
          "correct": false
        },
        {
          "answer": "modelu wykonywania pojedynczej instrukcji SQL,",
          "correct": false
        },
        {
          "answer": "modelu sprawdzania więzów spójności.",
          "correct": false
        }
      ]
    },
    {
      "question": "Czy jest prawdą:",
      "id": 811,
      "comments": null,
      "answers": [
        {
          "answer": "Z każdą stroną w puli buforów jest wiązany licznik odwołań i bit aktualizacji.",
          "correct": true
        },
        {
          "answer": "Zmieniana strona jest natychmiast zapisywana na dysk.",
          "correct": false
        },
        {
          "answer": "Z jednej strony w puli buforów może korzystać tylko jeden użytkownik.",
          "correct": false
        },
        {
          "answer": "Zawsze najlepszą strategią zastępowania stron jest LRU.",
          "correct": false
        }
      ]
    },
    {
      "question": "Czy format stron z rekordami zmiennej długości zapewnia:",
      "id": 812,
      "comments": null,
      "answers": [
        {
          "answer": "Przesuwanie rekordów po stronie bez zmiany identyfikatora rekordu.",
          "correct": true
        },
        {
          "answer": "Utrzymywanie spójnej puli wolnych miejsc.",
          "correct": true
        },
        {
          "answer": "Zamianę miejscami dwóch rekordów na stronie.",
          "correct": true
        },
        {
          "answer": "Używanie zewnętrznych wskaźników do rekordu.",
          "correct": true
        }
      ]
    },
    {
      "question": "Indeks pogrupowany jest gdy:",
      "id": 813,
      "comments": [
        {
          "author": "~anon@89.67.*.*",
          "comment": "\"Indeks nazywamy pogrupowanym (wewnętrznym) (ang. clustered) gdy zachodzi przypadek 1i) w definicji pozycji danych oraz plik danych jest posortowany według wartości klucza wyszukiwania tego indeksu. W rezultacie, rekordy o tej samej wartości klucza lub zbliżonej znajdują się na tej samej stronie lub tylko na kilku stronach dyskowych. Może być tylko jeden indeks pogrupowany, bo plik danych można posortować według wartości tylko jednego klucza wyszukiwania.\" \n\nCzy przypadkiem 3 odpowiedz nie jest rowniez prawidlowa?",
          "date": "27-06-2013 14:38:05"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "Odp C jest również poprawna",
          "date": "27-06-2017 20:23:08"
        }
      ],
      "answers": [
        {
          "answer": "pozycje danych są podzielone na osobne partycje,",
          "correct": false
        },
        {
          "answer": "rekordy danych i pozycje danych indeksu są w związku 1-1,",
          "correct": false
        },
        {
          "answer": "pozycje danych indeksu z tą samą wartością klucza wyszukiwania znajdują się na tej samej stronie,",
          "correct": false
        },
        {
          "answer": "uporządkowanie zapisu rekordów danych jest takie samo jak uporządkowanie zapisu pozycji danych indeksu.",
          "correct": true
        }
      ]
    },
    {
      "question": "Indeks na B+ drzewie zapewnia:",
      "id": 814,
      "comments": null,
      "answers": [
        {
          "answer": "możliwość wypisywania pozycji danych indeksu w kolejności uporządkowanej względem wartości klucza wyszukiwania,",
          "correct": true
        },
        {
          "answer": "realizację zapytań równościowych względem wartości klucza wyszukiwania,",
          "correct": true
        },
        {
          "answer": "realizację zapytań zakresowych względem wartości klucza wyszukiwania,",
          "correct": true
        },
        {
          "answer": "aktualizację wartości klucza wyszukiwania.",
          "correct": true
        }
      ]
    },
    {
      "question": "Indeks haszowany zapewnia:",
      "id": 815,
      "comments": [
        {
          "author": "~as@193.201.*.*",
          "comment": "z wykladów indeks haszowany: \"Nie wspiera wyszukiwania zakresowego i sortowania.\" + \"Sprawdza się dobrze tylko w przypadku zapytań o pojedyncze wiersze.\" więc powiedziałabym, że odp. \"możliwość wypisywania pozycji danych w kolejności uporządkowanej względem wartości klucza wyszukiwania\" jest błędna a \"realizację zapytań równościowych względem wartości klucza wyszukiwania,\" prawidłowa",
          "date": "01-07-2017 12:44:52"
        },
        {
          "author": "~mm@89.67.*.*",
          "comment": "zgadzamy się z przedmówcą",
          "date": "01-07-2017 14:39:20"
        }
      ],
      "answers": [
        {
          "answer": "możliwość wypisywania pozycji danych w kolejności uporządkowanej względem wartości klucza wyszukiwania,",
          "correct": true
        },
        {
          "answer": "realizację zapytań równościowych względem wartości klucza wyszukiwania,",
          "correct": false
        },
        {
          "answer": "realizację zapytań zakresowych względem wartości klucza wyszukiwania,",
          "correct": false
        },
        {
          "answer": "aktualizację wartości klucza wyszukiwania.",
          "correct": true
        }
      ]
    },
    {
      "question": "Sortowania w bazie danych używa się przy:",
      "id": 816,
      "comments": null,
      "answers": [
        {
          "answer": "wykonywaniu klauzuli GROUP BY,",
          "correct": true
        },
        {
          "answer": "budowie początkowego indeksu na B+-drzewie,",
          "correct": true
        },
        {
          "answer": "wykonywaniu klauzuli DISTINCT,",
          "correct": true
        },
        {
          "answer": "metodzie złączania Nested Loops Join.",
          "correct": false
        }
      ]
    },
    {
      "question": "Sortowania w bazie danych używa się przy:",
      "id": 817,
      "comments": null,
      "answers": [
        {
          "answer": "wykonywaniu klauzuli ORDER BY,",
          "correct": true
        },
        {
          "answer": "budowie początkowego indeksu na B+-drzewie,",
          "correct": true
        },
        {
          "answer": "wykonywaniu klauzuli UNION DISTINCT,",
          "correct": true
        },
        {
          "answer": "metodzie złączania Sort-Merge.",
          "correct": true
        }
      ]
    },
    {
      "question": "Sortowania w bazie danych używa się przy:",
      "id": 818,
      "comments": null,
      "answers": [
        {
          "answer": "wykonywaniu klauzuli WHERE,",
          "correct": false
        },
        {
          "answer": "budowie początkowego indeksu na B+-drzewie,",
          "correct": true
        },
        {
          "answer": "wykonywaniu klauzuli UNION ALL,",
          "correct": false
        },
        {
          "answer": "metodzie złączania Index Nested Loops Join.",
          "correct": false
        }
      ]
    },
    {
      "question": "Sortowania w bazie danych używa się przy:",
      "id": 819,
      "comments": null,
      "answers": [
        {
          "answer": "wykonywaniu klauzuli EXCEPT,",
          "correct": true
        },
        {
          "answer": "wykonywaniu klauzuli GROUP BY,",
          "correct": true
        },
        {
          "answer": "wykonywaniu klauzuli HAVING,",
          "correct": false
        },
        {
          "answer": "metodzie złączania Nested Loops Join.",
          "correct": false
        }
      ]
    },
    {
      "question": "Sortowania w bazie danych używa się przy:",
      "id": 820,
      "comments": [
        {
          "author": "~kelu@84.10.*.*",
          "comment": "hej, macie jakieś źródło odnośnie tego EXCEPTa?",
          "date": "06-09-2014 12:41:52"
        },
        {
          "author": "~anon@78.11.*.*",
          "comment": "Kolumny używane do sortowania, a więc występujące w klauzuli ORDER BY, jak również GROUP BY i DISTINCT, które również wymagają posortowania danych. Ponieważ indeks sam w sobie jest posortowany, może wyeliminować konieczność wykonywania kosztownej operacji sortowania.",
          "date": "02-07-2015 22:15:18"
        },
        {
          "author": "~anon@78.11.*.*",
          "comment": "W bazach danych tego typu problem sortowania pojawia się często. Oto przykłady:\n\nKlauzula ORDER BY - dane są wymagane w pewnym porządku.\nBudowa indeksu - początkowego B+ drzewa dla zbioru rekordów (w ramach metody BULK LOADING lub REBUILD).\nZłączanie tabel metodą sortowania przez scalanie.\nRealizacja operatorów relacyjnych: DISTINCT, GROUP BY, UNION DISTINCT, EXCEPT.",
          "date": "02-07-2015 22:17:10"
        }
      ],
      "answers": [
        {
          "answer": "wykonywaniu klauzuli EXCEPT,",
          "correct": true
        },
        {
          "answer": "budowie początkowego indeksu na B+-drzewie,",
          "correct": true
        },
        {
          "answer": "wykonywaniu funkcji agregującej AVG,",
          "correct": false
        },
        {
          "answer": "metodzie złączania Hash Join.",
          "correct": false
        }
      ]
    },
    {
      "question": "Sortowanie za pomocą B+-drzewa jest lepsze niż sortowanie zewnętrzne, gdy indeks jest:",
      "id": 821,
      "comments": null,
      "answers": [
        {
          "answer": "rzadki,",
          "correct": false
        },
        {
          "answer": "gęsty,",
          "correct": false
        },
        {
          "answer": "pogrupowany,",
          "correct": true
        },
        {
          "answer": "wewnętrzny.",
          "correct": true
        }
      ]
    },
    {
      "question": "Strategia optymalizacyjna \"tylko-indeks\" stosuje się, gdy:",
      "id": 822,
      "comments": null,
      "answers": [
        {
          "answer": "na tabeli jest założony tylko jeden indeks,",
          "correct": false
        },
        {
          "answer": "zamiast rozważać tabelę można rozważyć jeden z jej indeksów,",
          "correct": true
        },
        {
          "answer": "wszystkie kolumny występujące na liście SELECT występują w kluczu wyszukiwania jednego z indeksów,",
          "correct": true
        },
        {
          "answer": "można usunąć tabelę zostawiając w bazie danych tylko jej indeks.",
          "correct": false
        }
      ]
    },
    {
      "question": "W metodzie Hash Join występuje liczba funkcji haszujących równa:",
      "id": 823,
      "comments": null,
      "answers": [
        {
          "answer": "0,",
          "correct": false
        },
        {
          "answer": "1,",
          "correct": false
        },
        {
          "answer": "2,",
          "correct": true
        },
        {
          "answer": "3.",
          "correct": false
        }
      ]
    },
    {
      "question": "Które stwierdzenia stanowią dobre heurystyki optymalizacji zapytań:",
      "id": 824,
      "comments": null,
      "answers": [
        {
          "answer": "Selekcje wykonuj tak wcześnie, jak tylko możliwe.",
          "correct": true
        },
        {
          "answer": "Staraj się związać selekcje z iloczynem kartezjańskim, w celu zidentyfikowania rodzaju złączenia relacji.",
          "correct": true
        },
        {
          "answer": "Wybierz plan wykonania działający \"w miejscu\" bez pomocniczej relacji.",
          "correct": true
        },
        {
          "answer": "Wyszukuj wspólne podwyrażenia i wykonuj je tylko raz.",
          "correct": true
        }
      ]
    },
    {
      "question": "Które stwierdzenia stanowią dobre heurystyki optymalizacji zapytań:",
      "id": 825,
      "comments": null,
      "answers": [
        {
          "answer": "Przed przystąpieniem do realizacji zapytania dokonaj analizy możliwych opcji z oszacowaniem ich kosztu.",
          "correct": true
        },
        {
          "answer": "Staraj się związać selekcje z iloczynem kartezjańskim, w celu zidentyfikowania rodzaju złączenia relacji.",
          "correct": true
        },
        {
          "answer": "Wykonuj jednocześnie ciągi operacji jednoargumentowych takich jak selekcje i rzuty.",
          "correct": true
        },
        {
          "answer": "Przetwórz wstępnie plik we właściwy sposób (indeksy, sortowanie).",
          "correct": true
        }
      ]
    },
    {
      "question": "Które z poniższych stwierdzeń są prawdziwe:",
      "id": 826,
      "comments": null,
      "answers": [
        {
          "answer": "Przy warunkach zakresowych istotna jest kolejność atrybutów w kluczu wyszukiwania.",
          "correct": true
        },
        {
          "answer": "Indeks haszowany na relacji wewnętrznej jest dobry dla metody Index Nested Loops Join.",
          "correct": true
        },
        {
          "answer": "Pogrupowany indeks na B+ drzewie względem kolumn złączenia jest dobry dla metody Sort-Merge Join.",
          "correct": true
        },
        {
          "answer": "Metoda Hash Join wymaga istnienia indeksu haszowanego.",
          "correct": false
        }
      ]
    },
    {
      "question": "Które z poniższych stwierdzeń są prawdziwe:",
      "id": 827,
      "comments": null,
      "answers": [
        {
          "answer": "Metoda Sort-Merge Join wymaga istnienia indeksu na B+-drzewie.",
          "correct": false
        },
        {
          "answer": "Indeks pogrupowany jest użyteczny przy zapytaniach zakresowych a także przy mało-selektywnych zapytaniach równościowych.",
          "correct": true
        },
        {
          "answer": "Aktualizacja pól wyszukiwania w indeksach spowalnia INSERT/DELETE/UPDATE.",
          "correct": true
        },
        {
          "answer": "Tylko jeden indeks może być pogrupowany dla jednej tabeli.",
          "correct": true
        }
      ]
    },
    {
      "question": "Protokół ścisłego blokowania dwufazowego (Strict 2PL) obejmuje warunki:",
      "id": 828,
      "comments": [
        {
          "author": "~anon@89.67.*.*",
          "comment": "Jeszcze poprawne odpowiedzi są tutaj miałem to na egzaminie takie :\n1. Każda transakcja musi uzyskać blokadę X na obiekcie przed zapisaniem go\n2. Blokady trzymane przez transakcję są zwalniane gdy transakcja kończy się",
          "date": "05-02-2013 08:24:36"
        },
        {
          "author": "mykhi",
          "comment": "dodałem.",
          "date": "05-02-2013 10:59:19"
        },
        {
          "author": "~Lukas@83.31.*.*",
          "comment": "Odpowiedż b jest nie prawidłowa. Tak wynika z quizu u honzik.",
          "date": "30-06-2014 07:59:37"
        },
        {
          "author": "~piotrek@83.9.*.*",
          "comment": "odpowiedz B jest prawidłowa zgodnie z wykładem https://edux.pjwstk.edu.pl/mat/216/lec/rw12.htm\n\n\"Jeśli transakcja trzyma blokadę X na obiekcie, żadna inna transakcja nie ma prawa założyć żadnej blokady (ani typu S ani X) na tym obiekcie.\"",
          "date": "05-09-2016 10:38:51"
        },
        {
          "author": "~matej@2a02:a311:a33d:a700:1881:5cf:c788:371c",
          "comment": "odpowiedź c również prawidłowa",
          "date": "17-02-2020 10:16:52"
        }
      ],
      "answers": [
        {
          "answer": "Każda transakcja musi uzyskać blokadę S na obiekcie zanim odczyta ten obiekt.",
          "correct": true
        },
        {
          "answer": "Jeśli transakcja trzyma blokadę X na obiekcie, żadna inna transakcja nie ma prawa założyć żadnej blokady (ani S ani X) na tym obiekcie.",
          "correct": true
        },
        {
          "answer": "Aby założyć blokadę X transakcja musi zwolnić wszystkie swoje blokady S.",
          "correct": false
        },
        {
          "answer": "Blokady trzymane przez transakcję są zwalniane gdy tylko nie są jej potrzebne.",
          "correct": false
        },
        {
          "answer": "Każda transakcja musi uzyskać blokadę X na obiekcie przed zapisaniem go.",
          "correct": true
        },
        {
          "answer": "Blokady trzymane przez transakcję są zwalniane gdy transakcja kończy się",
          "correct": true
        }
      ]
    },
    {
      "question": "Protokół ścisłego blokowania dwufazowego (Strict 2PL) obejmuje warunki:",
      "id": 829,
      "comments": null,
      "answers": [
        {
          "answer": "Każda transakcja musi uzyskać blokadę X na obiekcie zanim odczyta ten obiekt.",
          "correct": false
        },
        {
          "answer": "Jeśli transakcja trzyma blokadę S na obiekcie, żadna inna transakcja nie ma prawa założyć żadnej blokady (ani S ani X) na tym obiekcie.",
          "correct": false
        },
        {
          "answer": "Blokady trzymane przez transakcję są zwalniane gdy transakcja kończy się.",
          "correct": true
        },
        {
          "answer": "Z każdą blokadą X powinna być związana odpowiadająca jej blokada S ale nie na odwrót.",
          "correct": false
        }
      ]
    },
    {
      "question": "Protokół ścisłego blokowania dwufazowego (Strict 2PL) obejmuje warunki:",
      "id": 830,
      "comments": [
        {
          "author": "~anon@31.11.*.*",
          "comment": "Właśnie robiłem to zadanie na eduxie i na bank poprawne odpowiedzi to A i D",
          "date": "29-06-2014 20:50:47"
        },
        {
          "author": "~kogut@109.206.*.*",
          "comment": "w takim razie co z tą odpowiedzią D ? \n",
          "date": "02-07-2018 22:45:26"
        }
      ],
      "answers": [
        {
          "answer": "Każda transakcja musi uzyskać blokadę X na obiekcie przed zapisaniem go.",
          "correct": true
        },
        {
          "answer": "Jeśli transakcja trzyma blokadę S na obiekcie, żadna inna transakcja nie ma prawa założyć żadnej blokady (ani S ani X) na tym obiekcie.",
          "correct": false
        },
        {
          "answer": "Dwie współpracujące ze sobą transakcje mogą wspólnie założyć jedną blokadę X.",
          "correct": false
        },
        {
          "answer": "W pierwszej fazie transakcja zakłada blokady, w drugiej fazie je zwalnia w dowolnej kolejności.",
          "correct": false
        }
      ]
    },
    {
      "question": "Aby zapobiec zakleszczeniu (deadlock) wystarczy:",
      "id": 831,
      "comments": null,
      "answers": [
        {
          "answer": "uzależniać założenie blokady od priorytetu transakcji,",
          "correct": true
        },
        {
          "answer": "uzależniać założenie nowej blokady od liczby założonych już przez transakcję blokad,",
          "correct": false
        },
        {
          "answer": "pozwalać tylko jednej transakcji na założenie blokady X,",
          "correct": false
        },
        {
          "answer": "sprawdzać, czy w grafie oczekiwania na zwolnienie blokady występuje cykl.",
          "correct": true
        }
      ]
    },
    {
      "question": "Fantomem nazywamy:",
      "id": 832,
      "comments": [
        {
          "author": "~Radek@89.78.*.*",
          "comment": "Skoro transakcja odczytała dane to musiałby już wcześniej wprowadzone te dane ?\nPoprawną odpowiedzią będzie \"wiersz, który został zmieniony, po tym jak inna transakcja odczytała ją\"",
          "date": "22-06-2014 16:50:02"
        },
        {
          "author": "~anon@89.79.*.*",
          "comment": "fantom - wiersz, który zostaje wstawiony do tabeli po tym jak transakcja wykonała operację na tej tabeli a przed jej zatwierdzeniem (co potencjalnie oznacza, że gdyby ten wiersz był obecny przy wykonywaniu operacji, jej wynik byłby inny).\n\nhttp://edu.pjwstk.edu.pl/wyklady/sbd/scb/w12.htm",
          "date": "26-06-2014 22:21:49"
        }
      ],
      "answers": [
        {
          "answer": "tabelę, do której nie ma dostępu żaden użytkownik,",
          "correct": false
        },
        {
          "answer": "wiersz, który został usunięty z tabeli, po tym jak inna transakcja odczytała ją,",
          "correct": false
        },
        {
          "answer": "wiersz, który został wpisany do tabeli, po tym jak inna transakcja odczytała ją,",
          "correct": true
        },
        {
          "answer": "wiersz, który został zmieniony, po tym jak inna transakcja odczytała ją.",
          "correct": false
        }
      ]
    },
    {
      "question": "Który rodzaj złączenia jest dobry w rozproszonej bazie danych:",
      "id": 833,
      "comments": null,
      "answers": [
        {
          "answer": "sort-merge join,",
          "correct": false
        },
        {
          "answer": "hash join,",
          "correct": false
        },
        {
          "answer": "półzłączenia,",
          "correct": true
        },
        {
          "answer": "złączenie zewnętrzne.",
          "correct": false
        }
      ]
    },
    {
      "question": "Czy jest prawdą dla protokołu dwu-fazowego zatwierdzania:",
      "id": 834,
      "comments": [
        {
          "author": "~anon@178.36.*.*",
          "comment": "czy to jest na pewno poprawna odpowiedź :) ?",
          "date": "05-02-2013 20:28:24"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "\"Protokół dwufazowego zatwierdzania (2PC ang. Two-Phase Commit)\n\nKoordynator wysyła do wszystkich węzłów komunikat prepare.\nWęzły podejmują lokalnie decyzję o gotowości do zatwierdzenia prepare lub konieczności wycofania transakcji abort i zapisują w swoim dzienniku odpowiednio albo rekord prepare albo rekord abort i następnie wysyłają do koordynatora odpowiednio komunikat albo yes albo no.\nGdy koordynator uzyska jednomyślną odpowiedź yes, zapisuje do swojego dziennika rekord commit i wysyła do wszystkich węzłów komunikat commit. W przeciwnym przypadku zapisuje do swojego dziennika rekord abort i wysyła do wszystkich węzłów komunikat abort.\nWęzły zapisują w swoim dzienniku odpowiednio rekord abort/commit albo end, kończą transakcję usuwając informację o niej z bufora bazy danych w pamięci RAM. a następnie wysyłają do koordynatora komunikat ack.\nPo otrzymaniu wszystkich potwierdzeń ack koordynator zapisuje do swojego dziennika rekord end i kończy transakcję usuwając informację o niej z buforu bazy danych w pamięci RAM.\"\n\nPoprawne",
          "date": "26-06-2013 21:23:42"
        },
        {
          "author": "~DR@31.11.*.*",
          "comment": "tak",
          "date": "02-02-2014 04:48:14"
        }
      ],
      "answers": [
        {
          "answer": "jest tylko jeden koordynator,",
          "correct": true
        },
        {
          "answer": "koordynator podejmuje decyzję \"commit\", gdy co najmniej jeden z węzłów przesłał mu komunikat \"yes\",",
          "correct": false
        },
        {
          "answer": "koordynator podejmuje decyzję \"abort\", gdy wszystkie węzły nadesłały komunikat \"no\",",
          "correct": false
        },
        {
          "answer": "w przypadku awarii sieci jest potrzebna dodatkowa trzecia faza.",
          "correct": false
        }
      ]
    },
    {
      "question": "Czy jest prawdą dla protokołu dwu-fazowego zatwierdzania:",
      "id": 835,
      "comments": null,
      "answers": [
        {
          "answer": "jeden węzeł wyróżnia się jako główny koordynator, a drugi jako zapasowy koordynator,",
          "correct": false
        },
        {
          "answer": "koordynator podejmuje decyzję \"commit\", gdy każdy z węzłów przysłal mu komunikat \"yes\",",
          "correct": true
        },
        {
          "answer": "tylko koordynator zapisuje komunikaty realizacji protokołu do swojego dziennika powtórzeń,",
          "correct": false
        },
        {
          "answer": "w przypadku awarii koordynatora jego funkcje przejmuje inny węzeł.",
          "correct": false
        }
      ]
    },
    {
      "question": "Czy jest prawdą:",
      "id": 836,
      "comments": null,
      "answers": [
        {
          "answer": "Bufory bazy danych zawierają używane ostatnio bloki danych z bazy danych.",
          "correct": true
        },
        {
          "answer": "Bufory bazy danych mogą zawierać zmodyfikowane dane zatwierdzonych transakcji, które jeszcze nie zostały przepisane na dysk.",
          "correct": true
        },
        {
          "answer": "Bufory bazy danych zmienione przez niezatwierdzone transakcje mogą zostać przepisane na dysk.",
          "correct": true
        },
        {
          "answer": "W buforach bazy danych są zapisywane pozycje segmentów wycofań.",
          "correct": true
        }
      ]
    },
    {
      "question": "Segmenty wycofań służą do:",
      "id": 837,
      "comments": null,
      "answers": [
        {
          "answer": "wycofywania nie zatwierdzonych zmian przy odtwarzaniu,",
          "correct": true
        },
        {
          "answer": "zagwarantowania spójności odczytu,",
          "correct": true
        },
        {
          "answer": "realizacji transakcji korzystających ze zdjęcia migawkowego danych,",
          "correct": true
        },
        {
          "answer": "przyśpieszenia wykonywania zapytań.",
          "correct": false
        }
      ]
    },
    {
      "question": "Które z mechanizmów są używane w rozproszonej bazie danych:",
      "id": 838,
      "comments": null,
      "answers": [
        {
          "answer": "dyspozytor,",
          "correct": false
        },
        {
          "answer": "powiązanie bazodanowe,",
          "correct": true
        },
        {
          "answer": "wielowersyjność",
          "correct": false
        },
        {
          "answer": "audyt.",
          "correct": false
        }
      ]
    },
    {
      "question": "Które z mechanizmów są używane w rozproszonej bazie danych:",
      "id": 839,
      "comments": [
        {
          "author": "~Wąsky@217.153.*.*",
          "comment": "Synchroniczna replikacja w rozproszonej bazie danych obejmuje zakładanie blokad. Więc według mnie odpowiedź \"blokady\" jest również poprawna.\n\nŹródło: http://edu.pjwstk.edu.pl/wyklady/sbd/scb/rW14.htm",
          "date": "06-02-2013 02:54:29"
        },
        {
          "author": "~gz@89.68.*.*",
          "comment": "fajnie gdyby ktokolwiek zareagowal z poprawianiem ;)",
          "date": "06-02-2013 13:46:36"
        },
        {
          "author": "mykhi",
          "comment": "spokojnie, jestem sam jeden.",
          "date": "06-02-2013 21:52:49"
        }
      ],
      "answers": [
        {
          "answer": "replikacja danych,",
          "correct": true
        },
        {
          "answer": "blokady,",
          "correct": true
        },
        {
          "answer": "transformacja STAR,",
          "correct": false
        },
        {
          "answer": "partycjonowanie tabeli.",
          "correct": false
        }
      ]
    },
    {
      "question": "Które z mechanizmów są używane w rozproszonej bazie danych:",
      "id": 840,
      "comments": null,
      "answers": [
        {
          "answer": "klaster",
          "correct": false
        },
        {
          "answer": "migawki,",
          "correct": true
        },
        {
          "answer": "instrukcja ANALYZE,",
          "correct": false
        },
        {
          "answer": "serwer równoległy.",
          "correct": false
        }
      ]
    },
    {
      "question": "Które z mechanizmów są używane w rozproszonej bazie danych:",
      "id": 841,
      "comments": null,
      "answers": [
        {
          "answer": "indeks bitmapowy,",
          "correct": false
        },
        {
          "answer": "powiązanie bazodanowe,",
          "correct": true
        },
        {
          "answer": "hurtownia danych,",
          "correct": false
        },
        {
          "answer": "agregacja danych.",
          "correct": false
        }
      ]
    },
    {
      "question": "Które z mechanizmów są używane w rozproszonej bazie danych:",
      "id": 842,
      "comments": null,
      "answers": [
        {
          "answer": "równoległe wykonywanie zapytań,",
          "correct": false
        },
        {
          "answer": "dwufazowe zatwierdzanie,",
          "correct": true
        },
        {
          "answer": "dziennik migawki,",
          "correct": true
        },
        {
          "answer": "audyt.",
          "correct": false
        }
      ]
    },
    {
      "question": "Które z mechanizmów są charakterystyczne dla hurtowni danych:",
      "id": 843,
      "comments": null,
      "answers": [
        {
          "answer": "replikacja danych,",
          "correct": false
        },
        {
          "answer": "blokady,",
          "correct": false
        },
        {
          "answer": "transformacja STAR,",
          "correct": true
        },
        {
          "answer": "partycjonowanie tabeli.",
          "correct": true
        }
      ]
    },
    {
      "question": "Które z mechanizmów są charakterystyczne dla hurtowni danych:",
      "id": 844,
      "comments": [
        {
          "author": "~Mossi@94.254.*.*",
          "comment": "Tutaj chyba jeszcze perspektywy\nhttp://edu.pjwstk.edu.pl/wyklady/sbd/scb/rW15.htm",
          "date": "07-07-2018 06:48:04"
        },
        {
          "author": "~anon@2a02:a31c:360:9b00:6cf4:15d0:abff:2fd1",
          "comment": "Ale perspektywy to chyba obiekty raczej\n",
          "date": "03-02-2020 12:49:30"
        }
      ],
      "answers": [
        {
          "answer": "blokady,",
          "correct": false
        },
        {
          "answer": "perspektywy,",
          "correct": false
        },
        {
          "answer": "role,",
          "correct": false
        },
        {
          "answer": "indeksy bitmapowe.",
          "correct": true
        }
      ]
    },
    {
      "question": "Które z mechanizmów są charakterystyczne dla hurtowni danych:",
      "id": 845,
      "comments": null,
      "answers": [
        {
          "answer": "histogram,",
          "correct": true
        },
        {
          "answer": "audyt,",
          "correct": false
        },
        {
          "answer": "agregacje,",
          "correct": true
        },
        {
          "answer": "profil.",
          "correct": false
        }
      ]
    },
    {
      "question": "Które z mechanizmów są charakterystyczne dla hurtowni danych:",
      "id": 846,
      "comments": null,
      "answers": [
        {
          "answer": "instrukcja ANALYZE,",
          "correct": true
        },
        {
          "answer": "szeregowalność,",
          "correct": false
        },
        {
          "answer": "wielowymiarowość,",
          "correct": true
        },
        {
          "answer": "dziennik powtórzeń.",
          "correct": false
        }
      ]
    },
    {
      "question": "Które z mechanizmów są charakterystyczne dla hurtowni danych:",
      "id": 847,
      "comments": null,
      "answers": [
        {
          "answer": "role,",
          "correct": false
        },
        {
          "answer": "wielowymiarowość,",
          "correct": true
        },
        {
          "answer": "migawki,",
          "correct": true
        },
        {
          "answer": "schemat gwiazda.",
          "correct": true
        }
      ]
    },
    {
      "question": "Które obiekty są związane z agregacją w hurtowni danych:",
      "id": 848,
      "comments": [
        {
          "author": "~anon@89.67.*.*",
          "comment": "\"Po zaprojektowaniu tabel faktów i wymiarów projektuje się następnie perspektywy zmaterializowane określające wymagane złączenia i agregacje (podsumowania) danych z bazowych tabel. Na perspektywie zmaterializowanej można zakładać indeksy w szczególności bitmapowe, więc przy wykonywaniu zapytań, perspektywa zmaterializowana ma te same własności co tabela.\n\nPonadto można zażyczyć sobie, aby zapytania pisane w terminach tabel faktów i wymiarów były automatycznie przekształcane przez optymalizator do zapytań korzystających z perspektyw zmaterializowanych.\"\n\nMoim zdaniem indeks bitmapowy rowniez jest zwiazany z agregacja. Bo zwiazany jest z perspektywa zmaterializowana. Ale to podlega dyskusji",
          "date": "29-06-2013 16:35:24"
        },
        {
          "author": "~SM@78.133.*.*",
          "comment": "@Up, moim zdaniem również:\n\"Obok wcześniejszego wyliczania agregacji perspektywy zmaterializowane używane są też do wcześniejszego wyliczania złączeń tabeli faktów z pewnymi wybranymi tabelami wymiarów. Przy takim zastosowaniu perspektywy zmaterializowane pełnią rolę tzw. indeksów złaczeniowych (przy bitmapowej implementacji - bitmapowych indeksów złączeniowych).\"",
          "date": "27-01-2014 10:48:48"
        },
        {
          "author": "~anon@89.77.*.*",
          "comment": "Ale indeks bitmapowy to mechanizm a ie obiekt, nie tego dotyczy pytanie :)",
          "date": "28-06-2017 18:55:23"
        }
      ],
      "answers": [
        {
          "answer": "indeks bitmapowy,",
          "correct": false
        },
        {
          "answer": "perspektywa zmaterializowana,",
          "correct": true
        },
        {
          "answer": "klaster,",
          "correct": false
        },
        {
          "answer": "klauzula GROUP BY.",
          "correct": true
        }
      ]
    },
    {
      "question": "Dane są tabele P(A,B), Q(B,C). W aplikacji często jest wykonywane zapytanie SELECT P.A,Q.C FROM P, Q WHERE P.B=Q.B AND Q.B='&amp;Klient'. Która ze struktur danych byłaby najkorzystniejsza:",
      "id": 849,
      "comments": null,
      "answers": [
        {
          "answer": "indeksy na P.B, Q.B;",
          "correct": false
        },
        {
          "answer": "indeksy na P.A, Q.C;",
          "correct": false
        },
        {
          "answer": "klaster obejmujący P i Q z indeksem B;",
          "correct": true
        },
        {
          "answer": "indeks na Q.B.",
          "correct": false
        }
      ]
    },
    {
      "question": "Dane są tabele P(A,B), Q(B,C). W aplikacji często jest wykonywane zapytanie SELECT P.A,Q.C FROM P, Q WHERE P.B=Q.B. Która ze struktur danych byłaby najkorzystniejsza:",
      "id": 850,
      "comments": [
        {
          "author": "~mm@89.67.*.*",
          "comment": "Chyba jednak nie do końca... Wyciąganie danych jest robione na samym końcu w takim zapytaniu, najpierw jest łączenie... WG mnie indeksy na P.B, Q.B",
          "date": "01-07-2017 09:49:41"
        },
        {
          "author": "~jol@89.70.*.*",
          "comment": "Wedlug mnie tez",
          "date": "31-08-2017 00:56:18"
        },
        {
          "author": "~mb@89.69.*.*",
          "comment": "też tak uważam",
          "date": "18-01-2018 21:34:39"
        },
        {
          "author": "~anon@46.112.*.*",
          "comment": "+",
          "date": "07-02-2019 21:33:53"
        },
        {
          "author": "~Łukasz@2a02:a311:803f:2380:2de3:1541:7759:36d",
          "comment": "Też tak uważam.",
          "date": "10-08-2019 16:34:53"
        },
        {
          "author": "~anon@37.47.*.*",
          "comment": "Index warto zalozyc na kolumny, które często znajdują się w warunku WHERE, z wykladow",
          "date": "04-02-2020 22:31:31"
        }
      ],
      "answers": [
        {
          "answer": "indeksy na P.B, Q.B;",
          "correct": false
        },
        {
          "answer": "indeksy na P.A, Q.C;",
          "correct": true
        },
        {
          "answer": "klaster obejmujący P i Q z indeksem B;",
          "correct": false
        },
        {
          "answer": "indeks na P.B.",
          "correct": false
        }
      ]
    },
    {
      "question": "Dane są tabele P(A,B), Q(B,C). W aplikacji często jest wykonywane zapytanie SELECT P.A,Q.B FROM P, Q WHERE P.B=Q.B AND Q.C='&amp;Klient'. Która ze struktur danych byłaby najkorzystniejsza:",
      "id": 851,
      "comments": null,
      "answers": [
        {
          "answer": "indeksy na P.B, Q.B;",
          "correct": false
        },
        {
          "answer": "indeksy na P.B, Q.C;",
          "correct": true
        },
        {
          "answer": "klaster obejmujący P i Q z indeksem B;",
          "correct": false
        },
        {
          "answer": "indeks na Q.C.",
          "correct": false
        }
      ]
    },
    {
      "question": "Zastosowanie indeksu przy wyszukiwaniu jest uzasadnione, gdy dzięki niemu ograniczamy się do:",
      "id": 852,
      "comments": null,
      "answers": [
        {
          "answer": "&gt;=50% ogólnej liczby wierszy w tabeli.",
          "correct": false
        },
        {
          "answer": "&lt;=50% ogólnej liczby wierszy w tabeli.",
          "correct": false
        },
        {
          "answer": "&lt;=25% ogólnej liczby wierszy w tabeli.",
          "correct": true
        },
        {
          "answer": "&gt;=25% ogólnej liczby wierszy w tabeli.",
          "correct": false
        }
      ]
    },
    {
      "question": "Zastosowanie strategii tylko indeks jest stosowane, gdy:",
      "id": 853,
      "comments": null,
      "answers": [
        {
          "answer": "na tabeli nie jest założony żaden indeks,",
          "correct": false
        },
        {
          "answer": "wyszukiwanie jest określone na perspektywie,",
          "correct": false
        },
        {
          "answer": "wyszukiwanie sprowadza się do przejścia indeksu,",
          "correct": true
        },
        {
          "answer": "wstawianie sprowadza się do wstawienia do indeksu.",
          "correct": false
        }
      ]
    },
    {
      "question": "Indeks bitmapowy zakłada się na kolumnie:",
      "id": 854,
      "comments": [
        {
          "author": "~p@83.28.*.*",
          "comment": "Wykład głosi, że \"Indeksy bitmapowe są zakładane na kolumnach, których zbiór wartości jest niewielki i które występują często w warunku WHERE zapytań z równością\". Czy odpowiedź \"gdy wyszukiwanie jest określane przez równość z podanymi wartościami\" nie jest poprawna?",
          "date": "05-02-2013 11:10:30"
        },
        {
          "author": "~anon@79.191.*.*",
          "comment": "Dołączam się do pytania powyżej",
          "date": "25-06-2013 23:48:14"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "\"indeks bitmapowy - specjalny indeks zakładany na kolumnach, których zbiór wartości jest niewielki i które często występują w warunku WHERE razem z operatorem równości lub operatorem IN.\"\n\nZ wykladu zatem odpowiedz \"gdy wyszukiwanie\" rowniez jest poprawne",
          "date": "26-06-2013 21:26:52"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam.",
          "date": "30-06-2013 16:49:05"
        }
      ],
      "answers": [
        {
          "answer": "w której liczba różnych wartości jest duża,",
          "correct": false
        },
        {
          "answer": "w której liczba różnych wartości jest mała,",
          "correct": true
        },
        {
          "answer": "gdy wyszukiwanie jest określane przez równość z podanymi wartościami,",
          "correct": true
        },
        {
          "answer": "gdy zachodzi konieczność sortowania względem wartości w tej kolumnie.",
          "correct": false
        }
      ]
    },
    {
      "question": "Indeks używający B-drzewa zakłada się na kolumnie:",
      "id": 855,
      "comments": null,
      "answers": [
        {
          "answer": "gdy wyszukiwanie po tej kolumnie daje zwykle duży zbiór wyników,",
          "correct": false
        },
        {
          "answer": "gdy wyszukiwanie po tej kolumnie daje zwykle mały zbiór wyników,",
          "correct": true
        },
        {
          "answer": "gdy wyszukiwanie często dotyczy największej wartości,",
          "correct": true
        },
        {
          "answer": "gdy często sortuje się dane względem tej kolumny.",
          "correct": true
        }
      ]
    },
    {
      "question": "Czy istniejący indeks przyśpiesza wykonanie instrukcji SELECT:",
      "id": 856,
      "comments": null,
      "answers": [
        {
          "answer": "nigdy,",
          "correct": false
        },
        {
          "answer": "zawsze,",
          "correct": false
        },
        {
          "answer": "czasem.",
          "correct": true
        }
      ]
    },
    {
      "question": "Czy istniejący indeks przyśpiesza wykonanie instrukcji INSERT:",
      "id": 857,
      "comments": [
        {
          "author": "~kelu@84.10.*.*",
          "comment": "Czy ktoś dysponuje przykładem lub źródłem, kiedy tak się dzieje?",
          "date": "06-09-2014 15:25:54"
        },
        {
          "author": "~kokodżambo@89.76.*.*",
          "comment": "Gdy masz insert razem z selectem (chyba?),",
          "date": "01-02-2015 19:52:03"
        },
        {
          "author": "~mm@89.67.*.*",
          "comment": "wtedy indeks przyspiesza działanie SELECT, a nie bezpośrednio INSERT...",
          "date": "01-07-2017 10:33:35"
        }
      ],
      "answers": [
        {
          "answer": "nigdy,",
          "correct": false
        },
        {
          "answer": "zawsze,",
          "correct": false
        },
        {
          "answer": "czasem.",
          "correct": true
        }
      ]
    },
    {
      "question": "Czy istniejący indeks przyśpiesza wykonanie instrukcji UPDATE:",
      "id": 858,
      "comments": null,
      "answers": [
        {
          "answer": "nigdy",
          "correct": false
        },
        {
          "answer": "zawsze",
          "correct": false
        },
        {
          "answer": "czasem",
          "correct": true
        }
      ]
    },
    {
      "question": "Czy istniejący indeks przyśpiesza wykonanie instrukcji DELETE:",
      "id": 859,
      "comments": null,
      "answers": [
        {
          "answer": "nigdy",
          "correct": false
        },
        {
          "answer": "zawsze",
          "correct": false
        },
        {
          "answer": "czasem",
          "correct": true
        }
      ]
    },
    {
      "question": "Czy istniejący indeks przyśpiesza wykonanie instrukcji ROLLBACK:",
      "id": 860,
      "comments": null,
      "answers": [
        {
          "answer": "nigdy",
          "correct": true
        },
        {
          "answer": "zawsze",
          "correct": false
        },
        {
          "answer": "czasem",
          "correct": false
        }
      ]
    },
    {
      "question": "Czy istniejący indeks przyśpiesza wykonanie instrukcji COMMIT:",
      "id": 861,
      "comments": null,
      "answers": [
        {
          "answer": "nigdy",
          "correct": true
        },
        {
          "answer": "zawsze",
          "correct": false
        },
        {
          "answer": "czasem",
          "correct": false
        }
      ]
    },
    {
      "question": "Użycie których metod może spowodować zmniejszenie liczby przesłań między pamięcią wewnętrzną i zewnętrzną:",
      "id": 862,
      "comments": null,
      "answers": [
        {
          "answer": "użycie perspektywy,",
          "correct": false
        },
        {
          "answer": "indeks na kolumnie klucza obcego,",
          "correct": true
        },
        {
          "answer": "zwykły indeks oparty na B-drzewie dla kolumny o dwóch wartościach,",
          "correct": false
        },
        {
          "answer": "indeks bitmapowy na kolumnie zawierającej nazwiska klientów.",
          "correct": false
        }
      ]
    },
    {
      "question": "Użycie których metod może spowodować zmniejszenie liczby przesłań między pamięcią wewnętrzną i zewnętrzną:",
      "id": 863,
      "comments": null,
      "answers": [
        {
          "answer": "zwiększenie liczby buforów,",
          "correct": true
        },
        {
          "answer": "klaster,",
          "correct": true
        },
        {
          "answer": "indeks bitmapowy na kolumnie zawierającej płeć klientów,",
          "correct": true
        },
        {
          "answer": "wykonanie instrukcji SET TRANSACTION READ ONLY.",
          "correct": false
        }
      ]
    },
    {
      "question": "Użycie których metod może spowodować zmniejszenie liczby przesłań między pamięcią wewnętrzną i zewnętrzną:",
      "id": 864,
      "comments": null,
      "answers": [
        {
          "answer": "dodatkowa tabela pomocnicza,",
          "correct": true
        },
        {
          "answer": "indeks bitmapowy na kolumnie zawierającej płeć klientów,",
          "correct": true
        },
        {
          "answer": "wykonanie instrukcji SET TRANSACTION READ ONLY,",
          "correct": false
        },
        {
          "answer": "zwykły indeks oparty na B-drzewie dla kolumny zawierającej nazwiska osób.",
          "correct": true
        }
      ]
    },
    {
      "question": "Użycie których metod może spowodować zmniejszenie liczby przesłań między pamięcią wewnętrzną i zewnętrzną:",
      "id": 865,
      "comments": null,
      "answers": [
        {
          "answer": "indeks bitmapowy na kolumnie zawierającej kraj, w którym mieszkają klienci,",
          "correct": true
        },
        {
          "answer": "wykonanie instrukcji ANALYZE,",
          "correct": true
        },
        {
          "answer": "wykonanie instrukcji SET TRANSACTION READ ONLY,",
          "correct": false
        }
      ]
    },
    {
      "question": "Ile warunków złączeń potrzeba w zapytaniu aby uniknąć złączenia kartezjańskiego?",
      "id": 1908,
      "comments": null,
      "answers": [
        {
          "answer": "liczba tabel minus jeden",
          "correct": true
        },
        {
          "answer": "liczba kolumn minus jeden",
          "correct": false
        },
        {
          "answer": "liczba kolumn plus jeden",
          "correct": false
        },
        {
          "answer": "liczba tabel plus jeden",
          "correct": false
        }
      ]
    },
    {
      "question": "Który z poniższych operatorów zwróci część wspólną wyników zapytań A i B zadanych w Oraclu?",
      "id": 1909,
      "comments": null,
      "answers": [
        {
          "answer": "INTERSECT",
          "correct": true
        },
        {
          "answer": "MINUS",
          "correct": false
        },
        {
          "answer": "UNION",
          "correct": false
        },
        {
          "answer": "UNION ALL",
          "correct": false
        }
      ]
    },
    {
      "question": "Polecenie RENAME TABLE służy do:",
      "id": 1910,
      "comments": null,
      "answers": [
        {
          "answer": "zmiany nazwy tabeli",
          "correct": true
        },
        {
          "answer": "w Oraclu nie ma polecenia pozwalającego na zmianę nazwy tabeli",
          "correct": false
        },
        {
          "answer": "usunięcia tabeli",
          "correct": false
        },
        {
          "answer": "usunięcia danych z tabeli",
          "correct": false
        }
      ]
    },
    {
      "question": "Perspektywa w PL/SQL:",
      "id": 1911,
      "comments": null,
      "answers": [
        {
          "answer": "może zostać użyta tak, jak by była tabelą np. w instrukcji SELECT, INSERT, UPDATE",
          "correct": true
        },
        {
          "answer": "jest obiektem przechowującym rekordy wybrane poleceniem SELECT",
          "correct": false
        },
        {
          "answer": "jest obiektem utworzonym w oparciu o instrukcję SELECT",
          "correct": true
        },
        {
          "answer": "wiersze (rekordy) perspektywy nie są przechowywane w bazie danych",
          "correct": true
        }
      ]
    },
    {
      "question": "Które z poniższych klauzul muszą wystąpić przed GROUP BY (zakładając, że chcemy, aby w ogóle wystąpiły)?",
      "id": 1912,
      "comments": [
        {
          "author": "~Mirek@85.232.*.*",
          "comment": "Bzdura! WHERE nie musi wystąpić. Przykład: w bazie uczelnianej daj zapytanie: \nSELECT AVG(sal) FROM emp GROUP BY deptno;",
          "date": "06-09-2013 16:13:22"
        },
        {
          "author": "~mimo@89.77.*.*",
          "comment": "(zakładając, że chcemy, aby w ogóle wystąpiły) :*",
          "date": "06-09-2013 17:37:19"
        },
        {
          "author": "~Kamil@95.49.*.*",
          "comment": "Na 100% poprawną odpowiedzią jest też C (Having). Tak jest na przykładowym teście na eduxie.",
          "date": "26-01-2014 19:55:05"
        },
        {
          "author": "mykhi",
          "comment": "zaznaczam też HAVING.",
          "date": "26-01-2014 20:02:26"
        },
        {
          "author": "~anon@87.207.*.*",
          "comment": "test na eduxie, u mnie having NIE poprawna",
          "date": "26-01-2014 21:44:42"
        },
        {
          "author": "mykhi",
          "comment": "odznaczam. srsly u guise... ;/",
          "date": "26-01-2014 21:50:46"
        },
        {
          "author": "~Kamil@95.49.*.*",
          "comment": "Przepraszam. Racja, HAVING nie musi wystąpić, a może. To było inne pytanie. ",
          "date": "26-01-2014 22:40:12"
        },
        {
          "author": "~anon@84.10.*.*",
          "comment": "Pytanie, czemu INTO nie musi być przed GROUP BY? Ktoś zna taki przykład?",
          "date": "06-09-2014 16:09:11"
        },
        {
          "author": "~radek@194.93.*.*",
          "comment": "Przykład że nie musi wystąpić INTO przed GROUP BY \"select plec from tabela group by plec\"",
          "date": "29-01-2015 11:15:08"
        },
        {
          "author": "~radek@194.93.*.*",
          "comment": "... a rozumiem. Jeśli chcemy żeby wystąpiło INTO to chyba rzeczywiście musi wystąpić przed GROUP BY",
          "date": "29-01-2015 11:41:57"
        },
        {
          "author": "~s8780@89.76.*.*",
          "comment": "Prawidowe odpowiedzi to where from into Tak wynika z testu na eduxe Prosze poprawic odpowiedzi w tym pytaniu",
          "date": "29-01-2015 13:38:49"
        },
        {
          "author": "~anon@89.76.*.*",
          "comment": "bo jak założymy że chcemy żeby było into to musi być przed group by",
          "date": "05-02-2015 21:27:29"
        },
        {
          "author": "~Majkel@213.238.*.*",
          "comment": "Jedyna poprawna odpowiedź to 2 - From. Where jest opcjonalne, może ale nie musi wystąpić.",
          "date": "01-07-2017 22:02:30"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "Ale jest zdanie \"zakładając, że chcemy, aby w ogóle wystąpiły\" więc możemy chcieć żeby było WHERE. WHERE w tej konstrukcji pytania to poprawne odp.",
          "date": "01-07-2017 23:12:44"
        },
        {
          "author": "~anon@89.77.*.*",
          "comment": "Wszystkie są poprawne, jeśli mówimy o dialekci Oracle, w MS SQL będzie bez Having i Into.",
          "date": "02-07-2017 00:28:15"
        },
        {
          "author": "~anon@2a01:110f:1505:3600:b97b:909f:2446:f056",
          "comment": "Wszystko poza Having \njeżeli zakładamy że każdy z tych ma wystąpić to to tylko:\nSELECT, INTO, WHERE \"MUSZĄ\"(!!) wystąpić przed group by. Having może, ale nie 'musi' ",
          "date": "01-02-2020 15:33:25"
        },
        {
          "author": "~df@91.207.*.*",
          "comment": "Polecenie wygląda tak:\nSELECT col INTO x FROM tab WHERE col < y GROUP BY col HAVING COUNT(*) > 1\nW tym momencie, jeśli już używamy tych keywordów, to wszystkie poza HAVING występują przed GROUP BY, a zatem odp a, b, d są poprawne przy założeniu, że chcemy, aby w ogóle wystąpiły.",
          "date": "10-07-2020 16:13:38"
        }
      ],
      "answers": [
        {
          "answer": "INTO",
          "correct": false
        },
        {
          "answer": "FROM",
          "correct": true
        },
        {
          "answer": "HAVING",
          "correct": false
        },
        {
          "answer": "WHERE",
          "correct": true
        }
      ]
    },
    {
      "question": "SELECT ename, NVL(sal, 0) \"Salary\" FROM Emp WHERE Sal IS NULL ORDER BY ename;",
      "id": 1913,
      "comments": [
        {
          "author": "~MarC0@178.213.*.*",
          "comment": "Prawidlowa odpowiedz powinna być: nic nie zwróci (no rows selected).",
          "date": "22-06-2013 13:09:37"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "Dokladnie, sprawdzone na developerze.",
          "date": "28-06-2013 11:31:03"
        },
        {
          "author": "~K@83.6.*.*",
          "comment": "Miałam to pytanie na końcowym teście. Odp prawidłowa była 0. ",
          "date": "09-08-2013 14:33:52"
        },
        {
          "author": "~Mirek@85.232.*.*",
          "comment": "Pytanie jest źle skonstruowane. Może nic nie zwrócić (a więc wyświetlić no rows selected) w przypadku, gdy nie ma pracowników, których salary = null. A że w bazie uczelnianej nie ma pracowników, których pencha = null, to wam wyświetla komunikat. Jeśli byliby tacy, to wynikiem byłoby:\n\"[imię_pracownika] 0 Salary\"",
          "date": "06-09-2013 16:07:20"
        },
        {
          "author": "~df@91.207.*.*",
          "comment": "Zwróci wynik:\nemp1 | 0\nemp2 | 0\nemp3 | 0\n...\n\nA więc teoretycznie tu nie powinno być dobrej odpowiedzi. Możliwe też, że nic nie zwróci, co jest kolejną teoretycznie poprawna odpowiedzią. Ahhh uwielbiam tę uczelnię :)",
          "date": "10-07-2020 16:21:43"
        }
      ],
      "answers": [
        {
          "answer": "0",
          "correct": true
        },
        {
          "answer": "nic nie zwróci",
          "correct": false
        },
        {
          "answer": "spację",
          "correct": false
        },
        {
          "answer": "null",
          "correct": false
        }
      ]
    },
    {
      "question": "Który z poniższych operatorów zwróci sumę zapytań bez eliminacji powtarzających się wierszy?",
      "id": 1914,
      "comments": null,
      "answers": [
        {
          "answer": "MINUS",
          "correct": false
        },
        {
          "answer": "UNION ALL",
          "correct": true
        },
        {
          "answer": "UNION",
          "correct": false
        },
        {
          "answer": "INTERSECT",
          "correct": false
        }
      ]
    },
    {
      "question": "Wśród instrukcji występujących w bloku PL/SQL (między BEGIN i END) mogą się znaleźć:",
      "id": 1944,
      "comments": null,
      "answers": [
        {
          "answer": "instrukcja DELETE FROM EMP",
          "correct": true
        },
        {
          "answer": "obsługa wyjątku",
          "correct": true
        },
        {
          "answer": "podniesienie wyjątku",
          "correct": true
        },
        {
          "answer": "deklaracje klas",
          "correct": false
        }
      ]
    },
    {
      "question": "W jaki sposób tworzy się funkcję:",
      "id": 1945,
      "comments": null,
      "answers": [
        {
          "answer": "CREATE FUNCTION nazwa(lista parametrów) IS",
          "correct": false
        },
        {
          "answer": "CREATE FUNCTION nazwa(lista parametrów) AS",
          "correct": false
        },
        {
          "answer": "CREATE FUNCTION nazwa(lista parametrów) RETURN Typ IS",
          "correct": true
        },
        {
          "answer": "CREATE FUNCTION nazwa(lista parametrów) RETURN Typ AS",
          "correct": true
        }
      ]
    },
    {
      "question": "Używając instrukcji LOCK TABLE można:",
      "id": 1946,
      "comments": null,
      "answers": [
        {
          "answer": "dokonać blokady wybranego pojedynczego wiersza",
          "correct": false
        },
        {
          "answer": "dokonać blokady dowolnej liczby wierszy",
          "correct": false
        },
        {
          "answer": "dokonać blokady tabeli przed nieuprawnionym dostępem",
          "correct": false
        },
        {
          "answer": "dokonać blokady tabeli w trybie wyłączności",
          "correct": true
        }
      ]
    },
    {
      "question": "W Oracle przy wykonywaniu instrukcji CREATE PROCEDURE:",
      "id": 1947,
      "comments": [
        {
          "author": "~anon@89.67.*.*",
          "comment": "\"Przy wykonywaniu instrukcji DDL (czyli typu CREATE/ALTER/DROP) też są zakładane blokady:\n\ndla obiektu bezpośrednio związanego z operacją - blokada wyłączna;\ndla obiektu pośrednio związanego z operacją - np. przy CREATE PROCEDURE - na tabelach w niej występujących - blokada współdzielona.\"\n\nWycinka z 11 wykladu",
          "date": "26-06-2013 19:23:02"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "Potwierdzam, w tym wypadku poprawna odpowiedź to B",
          "date": "07-09-2014 10:27:17"
        },
        {
          "author": "~anon@160.83.*.*",
          "comment": "Dokladnie poprawne jest B",
          "date": "27-06-2017 15:43:55"
        },
        {
          "author": "mykhi",
          "comment": "zaznaczam B, odznaczam C",
          "date": "27-06-2017 16:10:24"
        }
      ],
      "answers": [
        {
          "answer": "są zakładane blokady wyłączne na występujące w treści procedury tabele",
          "correct": false
        },
        {
          "answer": "są zakładane blokady współdzielone na występujące w treści procedury tabele",
          "correct": true
        },
        {
          "answer": "nie są zakładane żadne blokady na występujące w treści procedury tabele",
          "correct": false
        },
        {
          "answer": "nie są zakładane blokady jeśli w treści występują tylko instrukcje SELECT",
          "correct": false
        }
      ]
    },
    {
      "question": "Jakie są rodzaje parametrów procedur",
      "id": 1951,
      "comments": [
        {
          "author": "~anon@89.67.*.*",
          "comment": "Z dokumentacji oracle\n\n\"When you create a procedure or function, you may define parameters. There are three types of parameters that can be declared:\n\nIN - The parameter can be referenced by the procedure or function. The value of the parameter can not be overwritten by the procedure or function.\nOUT - The parameter can not be referenced by the procedure or function, but the value of the parameter can be overwritten by the procedure or function.\nIN OUT - The parameter can be referenced by the procedure or function and the value of the parameter can be overwritten by the procedure or function.\"\n\nNULL jest niepoprawne.",
          "date": "27-06-2013 17:11:57"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam.",
          "date": "30-06-2013 17:00:07"
        }
      ],
      "answers": [
        {
          "answer": "out",
          "correct": true
        },
        {
          "answer": "null",
          "correct": false
        },
        {
          "answer": "in out",
          "correct": true
        },
        {
          "answer": "in",
          "correct": true
        }
      ]
    },
    {
      "question": "Zawartość tabeli tymczasowej może zostać zniszczona",
      "id": 1952,
      "comments": [
        {
          "author": "~anon@89.67.*.*",
          "comment": "http://edu.pjwstk.edu.pl/wyklady/szb/scb/wyklad3/w3.htm \n\nna koniec transakcji oraz sesji",
          "date": "26-06-2013 19:32:33"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam.",
          "date": "30-06-2013 17:02:37"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "Za pomocą delete też można usuwać zawartość tabeli tymczasowej - sprawdzone w iSQL*Plus.",
          "date": "07-09-2014 11:06:27"
        },
        {
          "author": "~analnyruchacz@77.252.*.*",
          "comment": "Wyrucham was wszystkich w dupciaka!",
          "date": "07-02-2016 17:58:21"
        },
        {
          "author": "~JM@188.65.*.*",
          "comment": "Kelu zawartość tabeli usuwa truncate, delete usunie całą tabelę.",
          "date": "11-02-2019 13:02:10"
        }
      ],
      "answers": [
        {
          "answer": "za pomocą instrukcji delete",
          "correct": false
        },
        {
          "answer": "na koniec sesji",
          "correct": true
        },
        {
          "answer": "na koniec transakcji",
          "correct": true
        },
        {
          "answer": "po powtórnym zalogowaniu do bazy",
          "correct": false
        }
      ]
    },
    {
      "question": "Co będzie wynikiem realizacji instrukcji SELECT * FROM Emp WHERE EmployeeID = EmployeeID OR EmployeeID = NULL",
      "id": 1957,
      "comments": [
        {
          "author": "~anon@87.205.*.*",
          "comment": "instrukcja jest niepoprawna, NULL może tylko porównać przez IS NULL, albo IS NOT NULL",
          "date": "24-06-2013 15:22:17"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "In SQL, a comparison between a null value and any other value (including another null) a using a logical operator (eg =, !=, <, etc) will result in a null, which is considered as false for the purposes of a where clause. The reasoning is that a null means \"unknown\", so the result of any comparison to a null is also \"unknown\". So you'll get no hit on rows using my_column = null.\n\nSQL provides the special syntax for testing if a column is null, via is null and is not null, which is a special condition to test for a null (or not a null).\n\nZatem odpowiedz null jest poprawna. \n\nSwoja droga przelecialem wiekszosc pytan ze sprawdzaniem w sieci i wykladami i stwierdzam ze wiekszosc ma zle odpowiedzi. Zatem nie sugerujcie sie tym co tutaj jest",
          "date": "26-06-2013 19:34:16"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "Poprawiam relacja empno. Sprawdzone na developerze",
          "date": "28-06-2013 13:05:17"
        },
        {
          "author": "~df@91.207.*.*",
          "comment": "Sprawdziłem w SSMS to query i zdziwiłem się, ponieważ:\n\n(x IS NULL) == (x = NULL)\n\nNie jest to oczywiście poprawne, ale działa, więc wygląda na to, że odpowiedź \"relacja Emp\" jest jak najbardziej poprawna, ale lepiej nie używać tego typu rzeczy (jak 90% co się pojawia na tej uczelni...)",
          "date": "10-07-2020 16:30:20"
        }
      ],
      "answers": [
        {
          "answer": "relacja Emp",
          "correct": true
        },
        {
          "answer": "instrukcja jest niepoprawna",
          "correct": false
        },
        {
          "answer": "null",
          "correct": false
        },
        {
          "answer": "relacja pusta",
          "correct": false
        }
      ]
    },
    {
      "question": "Które z poniższych klauzul mogą (ewentualnie muszą) wystąpić przed GROUP BY w Oraclu?",
      "id": 2185,
      "comments": [
        {
          "author": "~m_r_k@178.42.*.*",
          "comment": "HAVING musi być po group by",
          "date": "25-06-2014 10:21:51"
        },
        {
          "author": "~anon@89.79.*.*",
          "comment": "W oracle-u nie. Znajdziesz dyskusję o tym w innych pytaniach :-D",
          "date": "26-06-2014 23:35:20"
        },
        {
          "author": "~Ufo@2a02:a319:c03e:9d80:d9ac:c56c:ff83:8298",
          "comment": "Moze sie komus przyda, bo to pytanie jest podchwytliwe: https://stackoverflow.com/questions/56207060/oracle-why-having-clause-can-be-before-group-by",
          "date": "09-02-2020 17:30:26"
        }
      ],
      "answers": [
        {
          "answer": "<span>WHERE</span>",
          "correct": true
        },
        {
          "answer": "<span>ORDER BY</span>",
          "correct": false
        },
        {
          "answer": "<span>HAVING</span>",
          "correct": true
        },
        {
          "answer": "<span>FROM</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "Transakcja w bazie danych:",
      "id": 2209,
      "comments": [
        {
          "author": "~crt@93.105.*.*",
          "comment": "Żadna odpowiedź w tym pytaniu nie jest poprawna?",
          "date": "06-09-2014 19:27:27"
        },
        {
          "author": "~anon@89.76.*.*",
          "comment": "czemu 4 nie jest poprawna?",
          "date": "01-02-2015 16:02:03"
        },
        {
          "author": "~paweł@85.222.*.*",
          "comment": "wg mnie odpowiedź 4 jest poprawna. Cyt wykład: \"Oraz aby zatwierdzić lub wycofać:\nCOMMIT TRANSACTION lub ROLLBACK TRANSACTION\"",
          "date": "01-02-2015 16:48:12"
        },
        {
          "author": "~anon@85.222.*.*",
          "comment": "a czy 1sza tez nie powinna byc poprawna? Cyt: \"Serwer automatycznie zakłada transakcję na każdą instrukcję DML (INSERT, UPDATE, DELETE).\n\"",
          "date": "01-02-2015 16:51:41"
        },
        {
          "author": "~anon@89.74.*.*",
          "comment": "wszystkie poprawne oprocz rollback",
          "date": "08-02-2015 23:37:43"
        },
        {
          "author": "~Domka@91.199.*.*",
          "comment": "wiadomo, które są poprawne ?",
          "date": "01-07-2015 15:47:30"
        },
        {
          "author": "~Murek1993@78.11.*.*",
          "comment": "Mysle ze 1 i 3 poprawne",
          "date": "02-07-2015 22:30:14"
        },
        {
          "author": "~Murek1993@78.11.*.*",
          "comment": "Mysle ze 1 i 3 poprawne",
          "date": "02-07-2015 22:30:18"
        },
        {
          "author": "~Murek1993@78.11.*.*",
          "comment": "Mysle ze 1 i 3 poprawne",
          "date": "02-07-2015 22:30:19"
        },
        {
          "author": "~piotrek@95.49.*.*",
          "comment": "W wykładzie https://edux.pjwstk.edu.pl/mat/117/lec/ADM6/w6.html jest zapis \"MS SQL Server automatycznie zakłada transakcję na każdą instrukcję DML oraz DDL\" ale to nie oznacza, że po ostatniej instrukcji DML serwer od razu zakłada kolejną transakcję. Według mnie poprawne odpowiedzi to: c, d ",
          "date": "03-09-2016 20:30:21"
        },
        {
          "author": "~anon@5.173.*.*",
          "comment": "to w koncu 1 i 3 czy 3 i 4?",
          "date": "08-02-2019 05:54:32"
        },
        {
          "author": "~anon@79.184.*.*",
          "comment": "3 i 4\n",
          "date": "08-02-2019 06:16:30"
        },
        {
          "author": "~JM@188.65.*.*",
          "comment": "1: nie mam twardych danych, ale intuicyjnie transakcja startuje gdy baza dostanie zadanie do wykonania / instrukcję rozpoczęcia transakcji 2: nie mogę sobie wyobrazić co by miało być w 2 żeby było true 3: także DDL, więć IMO fałsz, w Ms Sql DDL działa normalnie w transakcji, a w Oracle jest implicit commit po każdym DDL - ale wciąż podpada pod definicję transakcji. 4: prawda",
          "date": "11-02-2019 13:10:40"
        }
      ],
      "answers": [
        {
          "answer": "jest zakładana automatycznie przez serwer baz danych od ostatniej instrukcji DML",
          "correct": false
        },
        {
          "answer": "zmiana zatwierdzona przez COMMIT może być ('cośtam') wycofane przez ROLLBACK",
          "correct": false
        },
        {
          "answer": "to ciąg instrukcji DML i DQL wykonywanych w bazie danych",
          "correct": false
        },
        {
          "answer": "mogą być zatwierdzane przez programistę na żądanie",
          "correct": false
        }
      ]
    },
    {
      "question": "Które z poniższych twierdzeń dotyczących polecenia TRUNCATE TABLE są prawdziwe?",
      "id": 2183,
      "comments": [
        {
          "author": "~Mossi@94.254.*.*",
          "comment": "Chyba nie ma czegoś takiego jak DELETE TABLE. Jest samo DELETE lub DROP TABLE.",
          "date": "06-07-2018 23:44:02"
        },
        {
          "author": "~anon@109.241.*.*",
          "comment": "Nie ma DELETE TABLE\nDELETE FROM X WHERE....",
          "date": "07-07-2018 00:14:23"
        },
        {
          "author": "~anon@109.241.*.*",
          "comment": "TRUNCATE TABLE jest szybsze, ale nie mozna juz wydac komendy rollback",
          "date": "07-07-2018 00:16:08"
        },
        {
          "author": "~anon@109.241.*.*",
          "comment": "DROP jest np. DROP TABLE list_customers PURGE; ",
          "date": "07-07-2018 00:21:59"
        }
      ],
      "answers": [
        {
          "answer": "<span>można wycofać jego działanie instrukcją ROLLBACK</span>",
          "correct": false
        },
        {
          "answer": "<span>można nim usunąć tylko całą zawartość tablicy</span>",
          "correct": true
        },
        {
          "answer": "<span>jest szybsze niż polecenie DELETE TABLE</span>",
          "correct": true
        },
        {
          "answer": "<span>nie można w nim stosować klauzuli WHERE</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "Jaki będzie efekt wykonania następującego polecenia:<p></p>\n<p><span>CREATE TABLE Osoby</span></p>\n<p><span>(imie VARCHAR2(30) PRIMARY KEY, nazwisko VARCHAR2(30) PRIMARY KEY, zarobki NUMBER(7,2))</span>\n          </p>",
      "id": 2184,
      "comments": [
        {
          "author": "~anonimous@83.23.*.*",
          "comment": "Dlaczego wystąpi błąd?",
          "date": "02-07-2015 16:33:35"
        },
        {
          "author": "~Murek1993@78.11.*.*",
          "comment": "Chyba dlatego ze ktos probuje 2 klucze dac , a jak chcemy klucz na 2 kolumnach to musi byc poza linia wg mnie, przyklad REATE TABLE `nazwa_tabeli`\n{\n`nazwa_kolumny1` typ_danych ,\n`nazwa_kolumny2` typ_danych,\nCONSTRAINT PRIMARY KEY\nnazwa_klucza_glownego (`nazwa_kolumny1`,`nazwa_kolumny2`)\n}",
          "date": "02-07-2015 19:41:05"
        },
        {
          "author": "~df@91.207.*.*",
          "comment": "Tutaj jest próba przypisania dwóch kluczy obcych do tabeli co jest niedopuszczalne.\nJedyne co można zrobić to klucz złożony:\nCONSTRAINT PRIMARY KEY nazwa (col1, col2 etc.)",
          "date": "10-07-2020 17:15:38"
        }
      ],
      "answers": [
        {
          "answer": "przy próbie wykonania polecenia wystąpi błąd",
          "correct": true
        },
        {
          "answer": "zostanie stworzona tabela Osoby, której kluczem głównym będzie pole imie",
          "correct": false
        },
        {
          "answer": "<span>zostanie stworzona tabela Osoby, której kluczem głównym będzie zbiór złożony z pól (imie, nazwisko)</span>",
          "correct": false
        },
        {
          "answer": "<span>zostanie stworzona tabela Osoby, której kluczem głównym będzie pole nazwisko</span>",
          "correct": false
        }
      ]
    },
    {
      "question": "<span>W którym z poniższych zapytań jest użyte złączenie zewnętrzne między dwiema tabelami (w Oraclu)?</span>",
      "id": 2189,
      "comments": [
        {
          "author": "~Aaa@89.74.*.*",
          "comment": "Czym różni się odpowiedź B od C ? Bo wg są one dokładnie takie same a jedna jest poprawna , druga nie ... ",
          "date": "09-02-2014 19:51:26"
        },
        {
          "author": "~dokladnie@178.36.*.*",
          "comment": "odpowiedz z employeeinfo powinnna byc jedyna prawidlowa...chyba",
          "date": "09-02-2014 19:53:36"
        },
        {
          "author": "~ACBWS@89.78.*.*",
          "comment": "Ktoś potrafi to zweryfikować? ",
          "date": "24-06-2014 21:43:22"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "To ostatnie zapytanie (z employeeinfo) jeśli mielibyśmy traktować dosłownie to łączylibyśmy tabelę employee z samą sobą (nazwa region i employeeinfo to aliasy). Imo to jakaś bzdura, wątpie żeby się to w ogóle wykonało, chyba że tabela employee ma pola \"manager_id\" oraz \"region_name\" na raz.",
          "date": "06-09-2014 12:57:25"
        },
        {
          "author": "~anon@89.76.*.*",
          "comment": "Prośba dodać na końcu prawidłowej odpowiedzi w nawiasach + to wtedy dopiero bedzie prawidłowa odpowiedz/ Tutaj niedopisane jest troche",
          "date": "04-02-2015 22:29:36"
        },
        {
          "author": "~anon@85.222.*.*",
          "comment": "up",
          "date": "08-02-2015 23:55:50"
        },
        {
          "author": "mykhi",
          "comment": "coś bym pomógł ale w sumie nie wiem co chcecie ;D",
          "date": "08-02-2015 23:58:01"
        },
        {
          "author": "~anon@81.15.*.*",
          "comment": "domyślenie w oracle-u złączenie jest wewnętrzne czyli INNER JOIN jeżeli ma byś to złączenie zewnętrzne to jednak LEFT/RIGHT/FULL OUTER JOIN było by lepsze.",
          "date": "30-01-2016 16:26:42"
        },
        {
          "author": "~anon@89.72.*.*",
          "comment": "Jedna odp B / C wygląda tak: SELECT region.region_name, employee.salary FROM region, employee WHERE region.id = employee.region_no(+); , druga bez (+)",
          "date": "05-02-2017 23:15:16"
        }
      ],
      "answers": [
        {
          "answer": "<span>SELECT region.region_name, employee.salary FROM region, employee WHERE employee.salary BETWEEN region.avg_salary AND region.max_salary;</span>",
          "correct": false
        },
        {
          "answer": "<span>SELECT region.region_name, employee.salary FROM region, employee WHERE region.id = employee.region_no;</span>",
          "correct": true
        },
        {
          "answer": "<span>SELECT region.region_name, employee.salary FROM region, employee WHERE region.id = employee.region_no;</span>",
          "correct": false
        },
        {
          "answer": "<span>SELECT region.region_name, employeeinfo.last_name FROM employee region, employee employeeinfo WHERE employeeinfo.id &gt;= region.manager_id;</span>",
          "correct": false
        }
      ]
    },
    {
      "question": "<span>Poziom izolacji transakcji READ COMMITED obejmuje następujące własności:</span>",
      "id": 2186,
      "comments": null,
      "answers": [
        {
          "answer": "<span>widać wszystkie modyfikacje wprowadzane przez równolegle trwające transakcje</span>",
          "correct": false
        },
        {
          "answer": "<span>nie można w nim modyfikować danych w bazie danych</span>",
          "correct": false
        },
        {
          "answer": "<span>widać zmiany wprowadzane przez inne transakcje, o ile tamte zakończyły się zatwierdzeniem</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "<span>Klauzula START WITH określa:</span>",
      "id": 2187,
      "comments": null,
      "answers": [
        {
          "answer": "<span>korzeń drzewa</span>",
          "correct": true
        },
        {
          "answer": "<span>na jakim poziomie drzewa znajduje się dany wiersz w stosunku do wiersza stanowiącego korzeń</span>",
          "correct": false
        },
        {
          "answer": "<span>syna dla ojca</span>",
          "correct": false
        }
      ]
    },
    {
      "question": "<span>Wykonujesz następujące zapytanie:</span><br><span>SELECT e1.ename||' pracuje dla' ||e2.ename &nbsp;\"Pracownicy i ich szefowie\"&nbsp;FROM emp e1, emp e2 WHERE e1.mgr=e2.empno;</span><br><span>Jaki to jest rodzaj złączenia?</span>",
      "id": 2188,
      "comments": null,
      "answers": [
        {
          "answer": "<span>kartezjańskie</span>",
          "correct": false
        },
        {
          "answer": "<span>zewnętrzne</span>",
          "correct": false
        },
        {
          "answer": "<span>samozłączenie</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "<span>W którym z poniższych zapytań jest użyte złączenie zewnętrzne między dwiema tabelami (w Oraclu)?</span>",
      "id": 2190,
      "comments": [
        {
          "author": "~Tsp@213.238.*.*",
          "comment": "Dwie te same odpowiedzi jedno poprawne :P",
          "date": "08-02-2014 18:58:56"
        },
        {
          "author": "~anon@79.191.*.*",
          "comment": "Moim zdaniem jest literówka (która je zasadniczo zmienia) w pytaniu złączenie zewnętrzne w WHERE jest wyrażane przez (+)operator http://andrzejklusiewicz.blogspot.com/2010/11/kurs-oracle-sql-proste-zaczenia.html, więc gdyby w 3 było (+) zamiast > to ono byłoby poprawne ",
          "date": "26-06-2014 21:04:27"
        },
        {
          "author": "~anon@93.105.*.*",
          "comment": "Czemu pomimo tego że dwie odpowiedzi są takie same to tylko jedna jest poprawna?",
          "date": "06-09-2014 19:47:27"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "błąd i jeszcze nie ma komu poprawić :P imo tutaj nie ma poprawnej odpowiedzi w tym stanie, ale tak jak napisał anon@79.191.*.* to gdyby był znak += to on by złączał w taki sposób jak to robi normalnie LEFT OUTER JOIN",
          "date": "06-09-2014 20:22:39"
        },
        {
          "author": "~s8780@89.76.*.*",
          "comment": "SELECT region.region_name, employee.salary FROM region, employee WHERE region.id = employee.region_no(+);   To jest poprawna Prośba dopisac na konic +",
          "date": "30-01-2015 00:34:09"
        },
        {
          "author": "~kisne@162.158.*.*",
          "comment": "ahahahaha, 5 lat i nic nie zmieniono XDD",
          "date": "29-06-2019 14:57:59"
        },
        {
          "author": "~kisnezleszczy@162.158.*.*",
          "comment": "To stwórz własne myKhi, a nie narzekasz.",
          "date": "30-06-2019 00:01:47"
        },
        {
          "author": "~kisnezkisnacychzleszczy@89.66.*.*",
          "comment": "proszę się nie spinać tylko uczyć do poprawki XD",
          "date": "31-08-2019 18:39:06"
        }
      ],
      "answers": [
        {
          "answer": "<span>SELECT region.region_name, employee.salary FROM region, employee WHERE region.id = employee.region_no;</span>",
          "correct": false
        },
        {
          "answer": "<span>SELECT region.region_name, employee.salary FROM region, employee WHERE region.id = employee.region_no;</span>",
          "correct": true
        },
        {
          "answer": "<span>SELECT region.region_name, employeeinfo.last_name FROM employee region, employee employeeinfo WHERE employeeinfo.id &gt;= region.manager_id;</span>",
          "correct": false
        },
        {
          "answer": "<span>SELECT region.region_name, employee.salary FROM region, employee WHERE employee.salary BETWEEN region.avg_salary AND region.max_salary;</span>",
          "correct": false
        }
      ]
    },
    {
      "question": "Relacja R ma atrybut a. Jaka liczba może być wynikiem wykonania instrukcji SELECT Count(*) FROM R WHERE a=a",
      "id": 2191,
      "comments": [
        {
          "author": "~anon@164.127.*.*",
          "comment": "To pytanie juz jest i tam odpowiedzia jest 1 i 0.",
          "date": "30-06-2014 09:27:53"
        },
        {
          "author": "~anon@81.15.*.*",
          "comment": "\"Pytanie 3. Relacja R ma atrybut a. Ile wierszy może zwrócić w wyniku zapytanie z nałożonym jednym warunkiem a = a:\" odp. 1 lub 2\n\njest to jednak pytanie o ilość wierszy. gdy tabela jest pusta: ilość = 0, wypełniona: 1\nlecz tu jest pytanie o wartość a nie o ilość",
          "date": "30-01-2016 11:38:36"
        },
        {
          "author": "~Tudududu@89.72.*.*",
          "comment": "W pytaniu 3cim jest CAŁKOWITA, natomiast tu jest NATURALNA",
          "date": "05-02-2017 23:41:10"
        },
        {
          "author": "~df@91.207.*.*",
          "comment": "count where true zwróci liczebność relacji R, czyli 0, 1, zawsze tyle ile liczebność. Jeśli chodzi o dowolną liczbę naturalną to wg. mnie nie dowolną, tylko konkretną zależną od liczności relacji. Wg. mnie a, c, d",
          "date": "10-07-2020 17:21:52"
        }
      ],
      "answers": [
        {
          "answer": "<span>zawsze tyle jaka jest liczebność relacji R</span>",
          "correct": false
        },
        {
          "answer": "<span>dowolna liczba naturalna</span>",
          "correct": true
        },
        {
          "answer": "1",
          "correct": true
        },
        {
          "answer": "0",
          "correct": true
        }
      ]
    },
    {
      "question": "Jakie nazwiska zostaną wyświetlone w wyniku tego zapytania:<p></p>\n<p>SELECT ename</p>\n<p>FROM emp</p>\n<p>WHERE ename LIKE '_A%';\n          </p>",
      "id": 2192,
      "comments": [
        {
          "author": "~c@89.73.*.*",
          "comment": "Jak dla mnie to pytanie jest tak skonstruowane, że pasują tutaj b,c,d odp. są prawidłowe...\n\nPrzykład: rezultatem może być nazwisko typu AA",
          "date": "09-02-2014 23:34:54"
        },
        {
          "author": "~m_r_k@91.230.*.*",
          "comment": "Zgadzam się z przedmówcą",
          "date": "29-06-2014 13:33:45"
        },
        {
          "author": "~lolek@2a02:a312:603c:880:b42e:1b2c:6021:7ed",
          "comment": "tylko odp b. Pamiętaj że musi się zgadzać dla wszystkich odpowiedzi ( 1 przyklad nie swiadczy o tym ze zgadza się dla tych 3)",
          "date": "01-09-2019 20:30:21"
        },
        {
          "author": "~lolek@2a02:a312:603c:880:b42e:1b2c:6021:7ed",
          "comment": "https://www.w3schools.com/sql/sql_like.asp",
          "date": "01-09-2019 20:33:14"
        }
      ],
      "answers": [
        {
          "answer": "<span>nazwiska, w których litera A występuje na dowolnym miejscu poza pierwszym</span>",
          "correct": false
        },
        {
          "answer": "<span>nazwiska, w których litera A występuje na drugim miejscu</span>",
          "correct": true
        },
        {
          "answer": "<span>nazwiska kończące się na A</span>",
          "correct": false
        },
        {
          "answer": "<span>nazwiska zaczynające się na A</span>",
          "correct": false
        }
      ]
    },
    {
      "question": "Wyzwalacz w T-SQL jest uruchamiany",
      "id": 2193,
      "comments": [
        {
          "author": "~Archi@89.72.*.*",
          "comment": "Na 100% A), z wykładu\n\nWyzwalacz jest uruchamiany w tej samej transakcji co instrukcja (w tym przypadku DELETE), ale już po jej wykonaniu. Tabela jest już w stanie zmienionym, ale zmiany mogą zostać wycofane, gdyż nie została zakończona i zatwierdzona transakcja.",
          "date": "09-02-2014 18:17:53"
        },
        {
          "author": "~Aaa @89.74.*.*",
          "comment": "Potwierdzam A",
          "date": "09-02-2014 19:52:27"
        },
        {
          "author": "mykhi",
          "comment": "zaznaczam",
          "date": "10-02-2014 08:17:03"
        },
        {
          "author": "~step@94.254.*.*",
          "comment": "potwierdzam a",
          "date": "13-02-2017 20:29:11"
        }
      ],
      "answers": [
        {
          "answer": "Po wykonaniu, ale przed zatwierdzeniem polecenia DML",
          "correct": true
        },
        {
          "answer": "Przed wykonaniem polecenia DML",
          "correct": false
        },
        {
          "answer": "Po wykonaniu, ale nie można określicz czy przed czy po zatwierdzeniu",
          "correct": false
        },
        {
          "answer": "Po wykonaniu i zatwierdzeniu polecenia DML",
          "correct": false
        }
      ]
    },
    {
      "question": "Która z poniższych instrukcji w PL/SQL nie zakończy się błędem, przy założeniu, że w tabeli DEPTNO są dwa rekordy z wartościami Deptno IN (10, 20) oraz prawidłowej deklaracji zmiennej v_deptno",
      "id": 2194,
      "comments": [
        {
          "author": "~anon@89.74.*.*",
          "comment": "wszystkie są poprawne",
          "date": "09-02-2014 18:06:59"
        },
        {
          "author": "~Archi@89.72.*.*",
          "comment": "Można pod zmienną podstawić więcej niż jeden rekord?",
          "date": "09-02-2014 18:55:59"
        },
        {
          "author": "~anon@89.68.*.*",
          "comment": "nie można, poprawne jest tylko b.",
          "date": "09-02-2014 22:26:18"
        },
        {
          "author": "~Archi@89.72.*.*",
          "comment": "No właśnie też tak sądze",
          "date": "09-02-2014 22:29:43"
        },
        {
          "author": "~c@89.73.*.*",
          "comment": "Sorry, nie zauważyłem że chodzi o PL/SQL. W TSQL chyba wolno, jeżeli mnie pamięć nie myli.",
          "date": "09-02-2014 23:26:25"
        },
        {
          "author": "~c@89.73.*.*",
          "comment": "http://andrzejklusiewicz.blogspot.com/2010/11/kurs-oracle-plsql-instrukcje-sql-w.html\n\nTu nawet o tym jest.\nW T-SQL jest to dozwolone(chyba), a w PL/SQL nie.\n\nPotwierdzam jedyna odp. prawidłowa to B",
          "date": "09-02-2014 23:29:26"
        },
        {
          "author": "mykhi",
          "comment": "zaznaczam b",
          "date": "10-02-2014 08:19:55"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "Jeszcze miałem odpowiedzi takie:\n\n* SELECT deptno INTO v_deptno FROM dept WHERE deptno < 20; (poprawna)\n* SELECT deptno INTO v_deptno FROM dept WHERE deptno BETWEEN 5 AND 15; (poprawna)\n* SELECT deptno INTO v_deptno FROM dept WHERE deptno = 30; (niepoprawna)",
          "date": "07-09-2014 17:40:04"
        },
        {
          "author": "~japie...@89.64.*.*",
          "comment": "a co z A nie tak?",
          "date": "06-02-2019 16:50:05"
        },
        {
          "author": "~anon@46.112.*.*",
          "comment": "Probujesz zapisać do zmiennej więcej niż jedna wartość",
          "date": "07-02-2019 22:41:47"
        },
        {
          "author": "~anon@46.112.*.*",
          "comment": "B nie jest poprawna! Jesli jest napisane \"są dwa rekordy z wartościami Deptno IN (10, 20)\" to znaczy że mogą byc 10 20, 20 10, ale i 10 10, 20 20.",
          "date": "11-02-2020 20:07:43"
        }
      ],
      "answers": [
        {
          "answer": "SELECT deptno INTO v_deptno FROM dept WHERE deptno&gt;0;",
          "correct": false
        },
        {
          "answer": "SELECT deptno INTO v_deptno FROM dept WHERE deptno=10;",
          "correct": true
        },
        {
          "answer": "SELECT deptno INTO v_deptno FROM dept;",
          "correct": false
        },
        {
          "answer": "SELECT deptno INTO v_deptno FROM dept WHERE deptno IN (10, 20);",
          "correct": false
        }
      ]
    },
    {
      "question": "Problem fantomów dotyczy sytuacji, w której:",
      "id": 2200,
      "comments": [
        {
          "author": "~Archi@89.72.*.*",
          "comment": "A i B na 100%, reszty nie wiem.",
          "date": "09-02-2014 00:25:10"
        },
        {
          "author": "~Archi@89.72.*.*",
          "comment": "Cytując wykład \"Problem fantomów czyli rekordów, których nie było w trakcie rozpoczynania transakcji\" - z tego wynika, że tylko A jednak.",
          "date": "09-02-2014 00:35:31"
        },
        {
          "author": "mykhi",
          "comment": "zaznaczam",
          "date": "09-02-2014 10:10:15"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "Pytanie co z sytuacją gdy mamy izolację typu READ UNCOMMITED, wtedy C też wg mnie jest poprawne.",
          "date": "06-09-2014 14:05:17"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "sorry pomyłka :P nie doczytałem początku \"Użytkownik zobaczył rekord (...)\". Gdyby mowa była o transakcji to wtedy można się zastanawiać.",
          "date": "06-09-2014 14:06:27"
        }
      ],
      "answers": [
        {
          "answer": "W trakcie działania transakcji inna transakcja wstawiła nowy rekord",
          "correct": true
        },
        {
          "answer": "W trakcie działania transakcji inna transakcja usunęła rekord",
          "correct": false
        },
        {
          "answer": "Uzytkownik zobaczył rekord wprowadzony przez innego użytkownika, który nie został zatwierdzony przez COMMIT",
          "correct": false
        },
        {
          "answer": "Rekord został w obrębie jednej transakcji wprowadzony (INSERT) i od razu usunięty (DELETE)",
          "correct": false
        }
      ]
    },
    {
      "question": "Wyniki procedury T-SQL mogą być zwrócone przez",
      "id": 2201,
      "comments": [
        {
          "author": "~anon@89.73.*.*",
          "comment": "a, c, d jest na pewno poprawne.",
          "date": "07-02-2014 11:52:15"
        },
        {
          "author": "mykhi",
          "comment": "zaznaczam",
          "date": "07-02-2014 12:12:56"
        },
        {
          "author": "~anon@178.42.*.*",
          "comment": "jeszcze c :)",
          "date": "07-02-2014 12:24:40"
        },
        {
          "author": "~w@159.205.*.*",
          "comment": "z Result Set nie zgodziłbym się. Result Set definiujemy przy wywołaniu procedury składowanej, w ciele nie mamy możliwości zwrócenia wyniku poprzez wspomniane Result Set.",
          "date": "20-06-2014 21:41:42"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "Result Set nigdzie nie definiujesz ziom, Result Set to domyślny wynik ostatniego select jeśli wywołasz RETURN w procedurze. Poza tym miałem na egzaminie i Result Set jest na pewno poprawną odpowiedzią.",
          "date": "07-09-2014 18:02:03"
        },
        {
          "author": "~df@91.207.*.*",
          "comment": "Z wykładów Gakko:\n\nProcedury:\n• Zwracanie wartości:\no\tPrzez Result Set (np. SELECT)\no\tPrzez OUTPUT (parametr zadeklarowany jako OUTPUT)\no\tPrzez RETURN (natychmiastowe wyjście z procedury, przekazuje tylko INT)\n\nW takim przypadku odpowiedzi są poprawnie zaznaczone (a, c, d)\n",
          "date": "10-07-2020 17:36:46"
        }
      ],
      "answers": [
        {
          "answer": "Zmienną typu OUTPUT",
          "correct": true
        },
        {
          "answer": "Zmienną wiązania",
          "correct": false
        },
        {
          "answer": "Dyrektywę RETURN",
          "correct": true
        },
        {
          "answer": "Result Set",
          "correct": true
        }
      ]
    },
    {
      "question": "Kopia zapasowa dziennika transakcji:",
      "id": 2202,
      "comments": [
        {
          "author": "~anon@89.74.*.*",
          "comment": "chyba tylko c)",
          "date": "09-02-2014 18:03:47"
        },
        {
          "author": "~Archi@89.72.*.*",
          "comment": "A,B,C\nZ wykładu.",
          "date": "09-02-2014 22:32:30"
        },
        {
          "author": "mykhi",
          "comment": "zaznaczam",
          "date": "10-02-2014 08:18:55"
        },
        {
          "author": "~step@94.254.*.*",
          "comment": "potwierdzam",
          "date": "13-02-2017 19:03:10"
        }
      ],
      "answers": [
        {
          "answer": "Jest bezużyteczna, jeśli nie odtworzymy wcześniej pełnej kopii zapasowej",
          "correct": true
        },
        {
          "answer": "Pozwala wyczyścić dziennik transakcji",
          "correct": true
        },
        {
          "answer": "Zawiera zmiany w bazie danych wykonane od ostatniej kopii zapasowej dziennika transakcji",
          "correct": true
        },
        {
          "answer": "Zawiera zmiany w bazie danych wykonane od ostatniej kopii różnicowej",
          "correct": false
        }
      ]
    },
    {
      "question": "Pakiet w PL/SQL",
      "id": 2203,
      "comments": [
        {
          "author": "~anon@89.74.*.*",
          "comment": "DOBRE ODP.: a,c,d\nNIE WIEM: b\nŹRÓDŁO: http://mst.webd.pl/_sggw/plsql/wyk_ad_4.pdf",
          "date": "07-02-2014 16:02:14"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "Ja jeszcze miałem odpowiedzi:\n\n* Składa się z części publicznej (specyfikacji pakietu) i prywatnej (ciała pakietu) (poprawna)\n* Deklaracja zmiennych może odbywać się w części publicznej pakietu (poprawna)\n* Deklaracja zmiennych może odbywać się w części prywatnej pakietu (poprawna)",
          "date": "07-09-2014 17:57:33"
        }
      ],
      "answers": [
        {
          "answer": "W pakiecie mogą być definiowane podprogramy (funkcje i procedury)",
          "correct": true
        },
        {
          "answer": "Zmienne zadeklarowane w części prywatnej pakietu są widoczne w jego części publicznej",
          "correct": false
        },
        {
          "answer": "Część prywatna (ciało) pakietu jest opcjonalna",
          "correct": true
        },
        {
          "answer": "Zmienne zadeklarowane w części publicznej pakietu są widoczne w jego części prywatnej",
          "correct": true
        }
      ]
    },
    {
      "question": "Zintegrowanie w definicji hurtowni danych oznacza, że:",
      "id": 2204,
      "comments": null,
      "answers": [
        {
          "answer": "dane są jednolite",
          "correct": true
        },
        {
          "answer": "dane, raz umieszczone w hurtowni, zazwyczaj pozostają nie zmienione",
          "correct": false
        },
        {
          "answer": "zbierane dane dotyczą tematu, a nie działań",
          "correct": false
        },
        {
          "answer": "gromadzone są dane historyczne i każdy fakt opatrzony jest stemplem czasowym",
          "correct": false
        }
      ]
    },
    {
      "question": "W procedurze (PROCEDURE) PL/SQL<p></p>\n<p>&nbsp;\n          </p>",
      "id": 2205,
      "comments": [
        {
          "author": "~c@89.73.*.*",
          "comment": "c",
          "date": "07-02-2014 11:57:57"
        },
        {
          "author": "mykhi",
          "comment": "zaznaczam",
          "date": "07-02-2014 12:13:25"
        },
        {
          "author": "~prezes@89.67.*.*",
          "comment": "odp. a jest prawidłowa. Źródło:\nhttp://edu.pjwstk.edu.pl/wyklady/sbd/scb/rW6.htm",
          "date": "08-02-2014 13:08:49"
        },
        {
          "author": "~Archi@89.72.*.*",
          "comment": "Zajrzałem aż do dokumentacji oracle:\nhttp://docs.oracle.com/cd/B19306_01/appdev.102/b14251/adfns_packages.htm\n\nZ tego wynika, że domyślnym jest IN (?)",
          "date": "09-02-2014 17:40:37"
        },
        {
          "author": "~Archi@89.72.*.*",
          "comment": "Ale na aktualnym wykładzie też jest IN OUT, więc załóżmy, że wiedzą lepiej...",
          "date": "09-02-2014 17:49:05"
        },
        {
          "author": "~c@89.73.*.*",
          "comment": "Ja bym zaznaczył poprawne odpowiedzi, a nie to co jest w \"kluczu(wykładzie)\". Wystarczy że poprawią błąd w eduxie, a jak nie poprawią to przynajmniej jest podstawa do uzyskania tego punktu po zgłoszeniu się i sprawdzeniu odpowiedzi.",
          "date": "09-02-2014 23:22:10"
        },
        {
          "author": "~Archi@89.72.*.*",
          "comment": "No tak, tylko że to nie jest błąd w eduxie, a jak już to błąd w wykładzie, a nawet w przypadku \"niby błędnej\" odpowiedzi można powiedzieć, że tak było w wykładzie i nawet odszukać tą część.",
          "date": "10-02-2014 03:25:50"
        },
        {
          "author": "~df@91.207.*.*",
          "comment": "W sprawie IN OUT: Napisałem do wykładowcy i przyznał rację, że w wykładzie jest błąd (jak widzę od 6 lat przynajmniej XD)\nDomyślnym parametrem jest IN",
          "date": "10-07-2020 17:40:37"
        }
      ],
      "answers": [
        {
          "answer": "Domyślnym typem parametru jest IN OUT",
          "correct": true
        },
        {
          "answer": "Deklarując parametr procedury nie podaje się jego typu",
          "correct": false
        },
        {
          "answer": "Deklarując parametr procedury można mu nadać wartość domyślną",
          "correct": true
        },
        {
          "answer": "Jedynym typem parametru jest IN OUT",
          "correct": false
        }
      ]
    },
    {
      "question": "W funkcji (FUNCTION) PL/SQL",
      "id": 2206,
      "comments": [
        {
          "author": "~anon@89.73.*.*",
          "comment": "a, b, c na pewno. d chyba nie",
          "date": "07-02-2014 11:59:11"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "Ja miałem jeszcze odpowiedzi:\n\n* Jedynym sposobem uruchomienia funkcji jest użycie komendy EXECUTE (niepoprawna)\n* Funkcje definiowane w bazie danych mogą być użyte w poleceniach SQL (poprawna)",
          "date": "07-09-2014 17:33:47"
        },
        {
          "author": "~anon@148.81.*.*",
          "comment": "d poprawna",
          "date": "01-07-2017 13:41:56"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "d jest poprawna.\nW szczególności to pytanie jest zduplikowane, i w drugiej wersji wszystkie odpowiedzi są poprawne.",
          "date": "01-07-2017 13:59:34"
        }
      ],
      "answers": [
        {
          "answer": "Zwracana jest wartość wyrażenia znajdującego się po instrukcji RETURN",
          "correct": true
        },
        {
          "answer": "Wywołanie funkcji odbywa się przez jej nazwę",
          "correct": true
        },
        {
          "answer": "Można użyć instrukcji DQL",
          "correct": true
        },
        {
          "answer": "Nie można zadeklarować parametru typu OUT",
          "correct": false
        }
      ]
    },
    {
      "question": "Zaznacz poprawne stwierdzenia:",
      "id": 2207,
      "comments": [
        {
          "author": "~Archi@89.72.*.*",
          "comment": "Z racji, że musi być dobra przynajmniej jedna odpowiedź, a tu nie ma żadnej, proponuję wstępnie zaznaczyć D, raczej na 99.9%.",
          "date": "09-02-2014 00:21:24"
        },
        {
          "author": "mykhi",
          "comment": "zaznaczam",
          "date": "09-02-2014 10:09:47"
        },
        {
          "author": "~step @94.254.*.*",
          "comment": "potwierdzam z odpowiedziami",
          "date": "13-02-2017 18:56:25"
        }
      ],
      "answers": [
        {
          "answer": "Każda instrukcja SELECT wymaga pobrania danych z dysku twardego",
          "correct": false
        },
        {
          "answer": "Wynik działania każdej instrukcji UPDATE jest natychmiast po zatwierdzeniu zapisywany w pliku z danymi",
          "correct": false
        },
        {
          "answer": "Wynik działania każdej instrukcji SELECT jest zapisywany w dzienniku transakcji",
          "correct": false
        },
        {
          "answer": "Wynik działania każdej instrukcji UPDATE jest natychmiast po zatwierdzeniu zapisywanyw dzienniku transakcji",
          "correct": true
        }
      ]
    },
    {
      "question": "Które z poniższych instrukcji wypisze tekst Ala123 w SQL Server?<p></p>\n<p>&nbsp;\n          </p>",
      "id": 2208,
      "comments": [
        {
          "author": "~anon@89.73.*.*",
          "comment": "a, b",
          "date": "07-02-2014 12:00:37"
        },
        {
          "author": "~anon@89.73.*.*",
          "comment": "a,b",
          "date": "17-01-2017 16:14:25"
        },
        {
          "author": "~kogut@83.24.*.*",
          "comment": "a zwraca błąd",
          "date": "03-07-2018 13:34:48"
        },
        {
          "author": "~anon@87.206.*.*",
          "comment": "Tylko B",
          "date": "01-09-2019 07:54:06"
        },
        {
          "author": "~anon@89.171.*.*",
          "comment": "nie, A również",
          "date": "01-09-2019 08:39:57"
        }
      ],
      "answers": [
        {
          "answer": "Print 'Ala' + '123';",
          "correct": true
        },
        {
          "answer": "Print 'Ala' + Cast(123 As Varchar);",
          "correct": true
        },
        {
          "answer": "Print 'Ala' + 123;",
          "correct": false
        },
        {
          "answer": "Print 'Ala' + Cast (1+2+3 As Varchar);",
          "correct": false
        }
      ]
    },
    {
      "question": "Dane są dwie tabele Osoby(Imie, Nazwisko, Zarobki, Id_działu) oraz Działy(Id_działu, Nazwa). Które z następujących instrukcji są poprawnymi instrukcjami SQL w Oracle",
      "id": 2195,
      "comments": [
        {
          "author": "~anon@89.73.*.*",
          "comment": "b",
          "date": "07-02-2014 12:03:04"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "Do dodania jeszcze taka odpowiedź:\n\n* UPDATE Osoby SET Id_działu = NULL WHERE COUNT (*) < 5; (niepoprawna)\n\nSporo osób zrobiło w tym błąd wbrew pozorom więc warto dodać tak myślę :)",
          "date": "07-09-2014 17:59:13"
        }
      ],
      "answers": [
        {
          "answer": "SELECT Osoby.Nazwisko, Działy.Nazwa FROM Osoby, Działy, WHERE Osoby.Id_działu =Działy.Id_działu GROUP BY Osoby.Nazwisko HAVING COUNT (Działy.Id_działu) &lt; 2;",
          "correct": false
        },
        {
          "answer": "UPDATE Osoby SET Id_działu = NULL WHERE 5&gt;(SELECT COUNT(*) FROM Działy);",
          "correct": true
        },
        {
          "answer": "DELETE FROM Osoby WHERE Osoby.Nazwisko='KOWALSKI' AND Działy.Id_działu=22;",
          "correct": false
        },
        {
          "answer": "INSERT INTO Osoby VALUES ('Jan', 'Kowalski', 2000);",
          "correct": false
        }
      ]
    },
    {
      "question": "Które z poniższych instrukcji w SQL Server jest składniowo poprawna (zostanie wykonana)",
      "id": 2196,
      "comments": null,
      "answers": [
        {
          "answer": "SELECT empno FROM emp WHERE empno=empno;",
          "correct": true
        },
        {
          "answer": "SELECT 1 FROM emp WHERE 1&lt;&gt;1;",
          "correct": true
        },
        {
          "answer": "SELECT 1 FROM emp WHERE 1=1;",
          "correct": true
        },
        {
          "answer": "SELECT empno FROM emp WHERE empno&lt;&gt;empno;",
          "correct": true
        }
      ]
    },
    {
      "question": "Wskazać poprawne zapytanie SQL (dialekt ORACLE) znajdujące dla każdego departamentu ostatnio zatrudnionych pracowników",
      "id": 2197,
      "comments": [
        {
          "author": "~anon@89.74.*.*",
          "comment": "DOBRA ODP.: b\nZŁE ODP.: a,d\nNIE WIEM: c",
          "date": "07-02-2014 17:05:21"
        },
        {
          "author": "~anon@89.75.*.*",
          "comment": "C działa i daje taki sam wynik jak B. proszę o poprawienie :)",
          "date": "07-02-2014 18:28:43"
        },
        {
          "author": "mykhi",
          "comment": "poprawione",
          "date": "07-02-2014 19:36:57"
        }
      ],
      "answers": [
        {
          "answer": "SELECT deptno, ename, hiredate FROM emp WHERE hiredate = (SELECT MAX(hiredate) FROM emp GROUP BY deptno);",
          "correct": false
        },
        {
          "answer": "SELECT deptno, ename, hiredate FROM emp WHERE (hiredate, deptno) IN (SELECT MAX(hiredate), deptno FROM emp GROUP BY deptno);",
          "correct": true
        },
        {
          "answer": "SELECT deptno, ename, hiredate FROM emp e WHERE hiredate = (SELECT MAX(hiredate) FROM emp WHERE deptno=e.deptno)",
          "correct": true
        },
        {
          "answer": "SELECT deptno, ename, MAX(hiredate) FROM emp GROUP BY deptno;",
          "correct": false
        }
      ]
    },
    {
      "question": "Zaznacz poprawne stwierdzenia dotyczące typów LOB:",
      "id": 2198,
      "comments": [
        {
          "author": "~anon@89.73.*.*",
          "comment": "na pewno b i c. d jest źle.\njeżeli chodzi o a to CHYBA nie",
          "date": "07-02-2014 12:05:16"
        },
        {
          "author": "~prezes@89.67.*.*",
          "comment": "\"Na zawartościach obiektów BLOB i CLOB można operować za pomocą procedur i funkcji specjalnego pakietu DBMS_LOB w podobny sposób jak to się robi na zawartościach plików binarnych. \"\nStąd wynika, że odpowiedź a jest poprawna.\nŹródło:\nhttp://edu.pjwstk.edu.pl/wyklady/sbd/scb/rW7.htm",
          "date": "08-02-2014 13:35:20"
        },
        {
          "author": "~prezes@89.67.*.*",
          "comment": "Z przykładu pod rysunkiem 7.4 z powyższego źródła wynika, że odpowiedź b jest poprawna.",
          "date": "08-02-2014 13:38:33"
        },
        {
          "author": "mykhi",
          "comment": "to które mam zaznaczyć?",
          "date": "08-02-2014 17:37:34"
        },
        {
          "author": "~anon@79.185.*.*",
          "comment": "jestem za zaznaczeniem a,b i c. Po pierwsze to co podał poprzednik według wykładu są specjalne funkcje. Po drugie można utworzyć wiele kolumn LOB w jednej tabeli, na wykładzie jest właśnie taka tabelka. A do 3 nie jestem 100 % pewny ale znowu patrząc na wykład, widzę że wykonywane są powyższe instrukcje przy wykorzystaniu danych lob.",
          "date": "08-02-2014 18:24:45"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "Potwierdzam, zaznaczone są poprawne",
          "date": "07-09-2014 10:29:49"
        }
      ],
      "answers": [
        {
          "answer": "Istnieją specjalne funkcje operujące na danych LOB.",
          "correct": true
        },
        {
          "answer": "Można utworzyć wiele kolumn LOB w jednej tabeli.",
          "correct": true
        },
        {
          "answer": "Na rekordach zawierających dane LOB działają instrukcje SELECT, INSERT, UPDATE, DELETE.",
          "correct": true
        },
        {
          "answer": "Kolumna LOB może wystąpić wyłącznie w tabeli typu obiektowego.",
          "correct": false
        }
      ]
    },
    {
      "question": "Zaznacz poprawne stwierdzenia dotyczące wielowersyjności w bazach danych:",
      "id": 2199,
      "comments": [
        {
          "author": "~anon@89.74.*.*",
          "comment": "DOBRE ODP.: b,c\nZŁE ODP.: a\nNIE WIEM: d",
          "date": "07-02-2014 15:37:14"
        },
        {
          "author": "~kelu@84.10.*.*",
          "comment": "SERIALIZABLE nakłada blokady pesymistyczne, więc nie jest realizowany przy pomocy wielowersyjności.",
          "date": "06-09-2014 13:02:55"
        },
        {
          "author": "~anon@78.11.*.*",
          "comment": "Poziom READ COMMITTED w Oracle umożliwia większy poziom współbieżności niż w Standardzie, gdyż umożliwia odczytywanie obiektów nawet wtedy gdy inna transakcja założyła na tym obiekcie blokadę X (co jest niedozwolone w wersji opisanej przez Standard).  wspolbierznosc a wielowersyjnosc to tosamo?",
          "date": "03-07-2015 22:38:47"
        },
        {
          "author": "~student@162.158.*.*",
          "comment": "Wyklad z Lenkiewiczem: \"Dodatkowo Oracle stosuje mechanizmy wielowersyjności również przy standardowym poziomie READ COMMITTED. W MS SQL Server również jest to możliwe, ale dopiero po włączeniu odpowiedniej opcji.\"",
          "date": "28-06-2019 15:12:35"
        }
      ],
      "answers": [
        {
          "answer": "MS SQL Server realizuje poziom izolacji READ COMMITTED przy pomocy wielowersyjności.",
          "correct": false
        },
        {
          "answer": "MS SQL Server oferuje mechanizm, dzięki któremu możemy tworzyć statyczne obrazy (migawki) bazy danych, oparte na wielowersyjności.",
          "correct": true
        },
        {
          "answer": "Oracle realizuje poziom izolacji READ COMMITTED przy pomocy wielowersyjności.",
          "correct": true
        },
        {
          "answer": "Poziom izolacji SERIALIZABLE w MS SQL Server jest realizowany przy pomocy wielowersyjności.",
          "correct": false
        }
      ]
    },
    {
      "question": "<span>Aby posortować wyniki zapytania w odwrotnym porządku leksykograficznym przy nazwie sortowanej kolumny należy wpisać:</span>",
      "id": 2215,
      "comments": [
        {
          "author": "~anon@46.229.*.*",
          "comment": "poprawna jest b! ",
          "date": "29-06-2014 10:09:36"
        },
        {
          "author": "~anon@31.11.*.*",
          "comment": "dokładnie tak, musi być odpowiedź B.",
          "date": "29-06-2014 17:35:34"
        },
        {
          "author": "~Lukas@83.31.*.*",
          "comment": "No jasne, że b. Mam nadzieję, że nikt się nie nabrał.",
          "date": "30-06-2014 01:02:43"
        },
        {
          "author": "~anon@31.11.*.*",
          "comment": "leksykograficzny to domyślny sposób, czyli asc, więc odwrotny do desc. Miałem to pytanie na edux i poprawna jest desc",
          "date": "30-06-2014 01:19:26"
        },
        {
          "author": "~anon@89.78.*.*",
          "comment": "DESC",
          "date": "25-08-2014 19:38:52"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam z \"nic nie trzeba\" na DESC",
          "date": "25-08-2014 19:40:11"
        }
      ],
      "answers": [
        {
          "answer": "nic nie trzeba wpisywać, to domyślny sposób sortowania",
          "correct": false
        },
        {
          "answer": "DESC",
          "correct": true
        },
        {
          "answer": "ASC",
          "correct": false
        }
      ]
    },
    {
      "question": "W jaki sposób tworzy się perspektywę z opcją sprawdzania:",
      "id": 2218,
      "comments": null,
      "answers": [
        {
          "answer": "pisząc na końcu polecenia tworzenia perspektywy: WITH MAKE SURE OPTION",
          "correct": false
        },
        {
          "answer": "pisząc na końcu polecenia tworzenia perspektywy: WITH PROVE CORRECT OPTION",
          "correct": false
        },
        {
          "answer": "nie trzeba nic pisać, ponieważ jest to opcja domyślna",
          "correct": false
        },
        {
          "answer": "pisząc na końcu polecenia tworzenia perspektywy: WITH CHECK OPTION",
          "correct": true
        }
      ]
    },
    {
      "question": "Jakie znaczenie ma dziennik transakcji w serwerach baz danych?",
      "id": 2219,
      "comments": null,
      "answers": [
        {
          "answer": "Pozwala zachować spójność danych po awarii",
          "correct": true
        },
        {
          "answer": "Pozwala wycofywać transakcje",
          "correct": true
        },
        {
          "answer": "Pozwala zarządzać uprawnieniami",
          "correct": false
        },
        {
          "answer": "Pozwala na odtworzenie stanu bazy danych z określonego punktu w czasie",
          "correct": true
        }
      ]
    },
    {
      "question": "Które ze stwierdzeń jest prawdziwe:",
      "id": 2220,
      "comments": null,
      "answers": [
        {
          "answer": "perspektywa to to samo co tabela",
          "correct": false
        },
        {
          "answer": "używając perspektyw możemy w ogóle nie dbać o inne sposoby ochrony danych",
          "correct": false
        },
        {
          "answer": "perspektywy stanowią element ochrony danych przed niepowołanym lub nieprawidłowym dostępem do danych",
          "correct": true
        },
        {
          "answer": "wiersze perspektywy mogą być wyliczane na żądanie",
          "correct": true
        }
      ]
    },
    {
      "question": "Znormalizowany schemat bazy danych:",
      "id": 2221,
      "comments": null,
      "answers": [
        {
          "answer": "jest zawsze najbardziej wydajny.",
          "correct": false
        },
        {
          "answer": "schemat bazy danych nie ma wpływu na wydajność.",
          "correct": false
        },
        {
          "answer": "można poprawić wydajność zapytań do znormalizowanej bazy danych stosując perspektywy zmaterializowane.",
          "correct": true
        },
        {
          "answer": "może być mniej wydajny niż schemat nieznormalizowany.",
          "correct": true
        }
      ]
    },
    {
      "question": "Która z poniższych instrukcji w SQL Server jest składniowo poprawna (zostanie wykonana)",
      "id": 2222,
      "comments": [
        {
          "author": "~Murek 1993@78.11.*.*",
          "comment": "Powinno chyba byc TRUNCATE table emp;",
          "date": "02-07-2015 12:36:23"
        },
        {
          "author": "~Murek1993@78.11.*.*",
          "comment": "Sprawdzone w sqldeveloper QL Error: ORA-03290: Błędne polecenie obcięcia - brak słowa kluczowego CLUSTER lub TABLE  powinno byc TRUNCATE table emp;",
          "date": "03-07-2015 00:19:27"
        },
        {
          "author": "~vladimir@88.156.*.*",
          "comment": "Tyle, że w pytaniu jest mowa o składni SQL Servera, a tam to działa.",
          "date": "06-09-2015 21:59:37"
        },
        {
          "author": "~blabla@194.152.*.*",
          "comment": "Sprawdzono w SQL Server poprawne tylko 1. ",
          "date": "23-01-2017 12:02:32"
        },
        {
          "author": "~up@91.230.*.*",
          "comment": "Wszystko poprawne, sprawdzone. Nie wprowadzaj ludzi w błąd.",
          "date": "24-01-2017 09:39:22"
        },
        {
          "author": "~anon@109.241.*.*",
          "comment": "Nie sadze. TRUNCATE TABLE a nie TRUNCATE i to w PL/SQL jaki  T-SQL. Jest tez TRUNCATE CLUSTER...",
          "date": "06-07-2018 22:36:34"
        },
        {
          "author": "~anon@109.241.*.*",
          "comment": "A co do INSERT INTO emp (ename, job) SELECT ename, job FROM emp;\t\nTo powinno byc np:\nINSERT INTO emp SELECT ename, job, sal, comm FROM emp WHERE comm > sal * 0.25;\nlub\n\nINSERT INTO emp (empno, ename, job, sal, comm, deptno) VALUES (4160, 'STURDEVIN', 'SECURITY GUARD', 2045, NULL, 30);\nlub\nINSERT INTO dept\nVALUES (my_deptno, UPPER(my_dname), 'CHICAGO');\n\nW formie przedstawionej w tescie jest blad.",
          "date": "06-07-2018 22:48:14"
        },
        {
          "author": "~anon@37.47.*.*",
          "comment": "a nie powinno byc empno IS NULL zamiast = NULL?",
          "date": "04-02-2020 22:32:44"
        },
        {
          "author": "~anon@91.207.*.*",
          "comment": "b jest źle. Poprawnie jest:\nTRUNCATE TABLE emp",
          "date": "10-07-2020 18:12:04"
        }
      ],
      "answers": [
        {
          "answer": "DELETE FROM emp WHERE empno = NULL;",
          "correct": true
        },
        {
          "answer": "TRUNCATE emp;",
          "correct": true
        },
        {
          "answer": "INSERT INTO emp (ename, job) SELECT ename, job FROM emp;",
          "correct": true
        },
        {
          "answer": "UPDATE emp SET sal = sal WHERE sal = sal;",
          "correct": true
        }
      ]
    },
    {
      "question": "Która z poniższych instrukcji PL/SQL prawidłowo podstawia wartość na zmienną (w tabeli EMP jest 14 rekordów)?",
      "id": 2223,
      "comments": [
        {
          "author": "~anon@78.11.*.*",
          "comment": "OStatnia zla",
          "date": "04-07-2015 17:33:20"
        },
        {
          "author": "~anon@78.11.*.*",
          "comment": "musi byc z apostrofem ename potwierdzam",
          "date": "04-07-2015 17:33:50"
        },
        {
          "author": "~anon@5.173.*.*",
          "comment": "poprawne sa 1,3,4",
          "date": "08-02-2019 06:35:02"
        },
        {
          "author": "~anon@213.195.*.*",
          "comment": "niestety nie, jedynie 3 jest poprawna. 1zła - bo do rekordu próbujesz wstawić result set 2 zła - bo zła jest składnia v_ename = ename\n4 - zła bo nie ma kolumny ename w tabeli DUMMY.",
          "date": "08-02-2019 12:03:29"
        }
      ],
      "answers": [
        {
          "answer": "SELECT ename INTO v_ename FROM emp;",
          "correct": false
        },
        {
          "answer": "SELECT v_ename = ename FROM emp WHERE empno = 1234;",
          "correct": false
        },
        {
          "answer": "DECLARE v_ala Varchar2(10) := 'Ala';",
          "correct": true
        },
        {
          "answer": "SELECT ename INTO v_ename FROM dummy;",
          "correct": true
        }
      ]
    },
    {
      "question": "Rola w bazie danych:",
      "id": 2224,
      "comments": null,
      "answers": [
        {
          "answer": "Jest grupą obiektów bazy danych (tabel, procedur, perspektyw)",
          "correct": false
        },
        {
          "answer": "Jest obiektem bazy danych pozwalającym łatwiej zakładać indeksy",
          "correct": false
        },
        {
          "answer": "Jest grupą użytkowników",
          "correct": true
        },
        {
          "answer": "Może mieć nadane uprawnienia",
          "correct": true
        }
      ]
    },
    {
      "question": "Procedura T-SQL zwraca poprzez Result Set",
      "id": 2225,
      "comments": null,
      "answers": [
        {
          "answer": "Wszystkie wiersze ostatniej uruchomionej wewnątrz procedury instrukcji SELECT",
          "correct": true
        },
        {
          "answer": "Poprzez Result Set mogą być zwracane wyłącznie komunikaty o błędach",
          "correct": false
        },
        {
          "answer": "Procedura może zwrócić wyniki tylko poprzez zmienną OUTPUT",
          "correct": false
        },
        {
          "answer": "Ostatni wiersz ostatniej uruchomionej wewnątrz procedury instrukcji SELECT",
          "correct": false
        }
      ]
    },
    {
      "question": "W wyzwalaczu T-SQL",
      "id": 2226,
      "comments": null,
      "answers": [
        {
          "answer": "Mogą być deklarowane zmienne",
          "correct": true
        },
        {
          "answer": "Można używać instrukcji ROLLBACK",
          "correct": true
        },
        {
          "answer": "Można używać kursororów",
          "correct": true
        },
        {
          "answer": "Można używać instrukcji DML",
          "correct": true
        }
      ]
    },
    {
      "question": "Serwer baz danych może zarządzać współbieżnością dzięki:",
      "id": 2227,
      "comments": null,
      "answers": [
        {
          "answer": "denormalizacji",
          "correct": false
        },
        {
          "answer": "materializacji",
          "correct": false
        },
        {
          "answer": "wielowersyjności",
          "correct": true
        },
        {
          "answer": "rolom",
          "correct": false
        }
      ]
    },
    {
      "question": "<p><span><span><span>Które aksjomaty ACID są zapewnione przez użycie planu szeregowalnego:</span></span></span></p>\n<p>&nbsp;</p>\n<form method=\"POST\">\n<p>&nbsp;</p>\n</form>",
      "id": 2367,
      "comments": null,
      "answers": [
        {
          "answer": "atomowość&nbsp;",
          "correct": false
        },
        {
          "answer": "spójność&nbsp;",
          "correct": true
        },
        {
          "answer": "izolacja",
          "correct": true
        },
        {
          "answer": "&nbsp;trwałość",
          "correct": false
        }
      ]
    },
    {
      "question": "&nbsp;<p></p>\n<p><span><span><span><span lang=\"en-US\">Czy replikacja przyśpiesza wykonywanie:</span></span></span></span>\n          </p>",
      "id": 2369,
      "comments": null,
      "answers": [
        {
          "answer": "<p><span><span><span>instrukcji SELECT &nbsp;</span></span></span></p>",
          "correct": true
        },
        {
          "answer": "<span>instrukcji INSERT&nbsp;</span>",
          "correct": false
        },
        {
          "answer": "<p><span><span><span>instrukcji DELETE</span></span></span></p>",
          "correct": false
        },
        {
          "answer": "<p><span><span><span>instrukcji UPDATE</span></span></span></p>",
          "correct": false
        }
      ]
    },
    {
      "question": "<span>Dane są dwie tabele Osoby(Imie, Nazwisko, Zarobki, Id_działu) oraz Działy(Id_działu, Nazwa). Które z następujących instrukcji są poprawnymi instrukcjami SQL w Oracle:</span>",
      "id": 2370,
      "comments": [
        {
          "author": "~radek@89.78.*.*",
          "comment": "Wydaje mi się że 4 odpowiedź również jest poprawna",
          "date": "09-02-2015 08:45:54"
        },
        {
          "author": "~anon@188.146.*.*",
          "comment": "Nie jest bo nie podajesz odpowiednich wartości , gdybys napisał\nINSERT INTO OSOBY (tutaj podajesz w jakich kolumnach chcesz cos umiescic) VALUES (tutaj co ma byc umieszczone w odpowiedniej kolejnosci)",
          "date": "27-01-2016 12:10:08"
        },
        {
          "author": "~Romen@88.156.*.*",
          "comment": "Można użyć INSERT INTO VALUES () wtedy, kiedy liczba kolumn w tabeli zgadza się z liczbą podanych wartości",
          "date": "28-01-2016 21:53:47"
        },
        {
          "author": "~anon@83.6.*.*",
          "comment": "@Up\nZgadza się :)",
          "date": "28-01-2016 22:12:29"
        },
        {
          "author": "~anon@83.6.*.*",
          "comment": "@Up\nZgadza się :)",
          "date": "28-01-2016 22:12:31"
        }
      ],
      "answers": [
        {
          "answer": "<span>SELECT Osoby.Nazwisko, Działy.Id_działu FROM Osoby, Działy WHERE Osoby.Id_działu=Działy.Id_działu GROUP BY Osoby.Nazwisko</span>",
          "correct": false
        },
        {
          "answer": "<span>DELETE FROM Osoby, Działy WHERE Osoby.Nazwisko='KOWALSKI' AND Działy.Nazwa='KASA'</span>",
          "correct": false
        },
        {
          "answer": "<span>UPDATE Osoby SET Id_działu=NULL</span>",
          "correct": true
        },
        {
          "answer": "<span>INSERT INTO Osoby VALUES ('Jan', 'Kowalski', 2000)</span>",
          "correct": false
        }
      ]
    },
    {
      "question": "Dana jest tabela Osoby(Imie, Nazwisko, Zarobki). Które z następujących instrukcji są składniowo poprawnymi instrukcjami SQL w Oracle:",
      "id": 2371,
      "comments": [
        {
          "author": "~anon@89.67.*.*",
          "comment": "Odp C jest niepoprawna",
          "date": "27-06-2017 20:24:32"
        },
        {
          "author": "~kogut@83.6.*.*",
          "comment": "potwierdzam",
          "date": "02-07-2018 14:28:38"
        }
      ],
      "answers": [
        {
          "answer": "<span>UPDATE Osoby Nazwisko=USER</span>",
          "correct": false
        },
        {
          "answer": "<span>INSERT INTO Osoby VALUES ('Jan', 'Kowalski', 2000) WHERE USER = 'KOWALSKI'</span>",
          "correct": false
        },
        {
          "answer": "<span>DELETE FROM Osoby WHERE USER='KOWALSKI'</span>",
          "correct": true
        },
        {
          "answer": "<span>SELECT Osoby.Nazwisko, Osoby.Imie, Osoby.Zarobki FROM Osoby WHERE Osoby.Zarobki &gt;1000</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "<span>Które z poniższych stwierdzeń są prawdziwe:</span>",
      "id": 2372,
      "comments": null,
      "answers": [
        {
          "answer": "<span>należy starać się użyć najmniejszej możliwej liczby tabel</span>",
          "correct": false
        },
        {
          "answer": "<table>\n<tbody>\n<tr>\n<td>należy wszystkie związki jednoznaczne zastąpić związkami jednojednoznacznymi</td>\n<td>&nbsp;</td>\n</tr>\n</tbody>\n</table>",
          "correct": false
        },
        {
          "answer": "<span>w tabeli nie powinno być żadnych niekontrolowanych redundancji</span>",
          "correct": true
        },
        {
          "answer": "<span>jedyną poprawną, nietrywialną zależnością funkcyjną jest zależność do klucza</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "<span>Użycie klauzuli PRIMARY KEY w deklaracji pola tabeli instrukcji CREATE TABLE powoduje, że:</span>",
      "id": 2373,
      "comments": null,
      "answers": [
        {
          "answer": "<span>w żadnym innym polu tej tabeli nie może zostać użyta klauzula PRIMARY KEY</span>",
          "correct": true
        },
        {
          "answer": "<span>w polu tym nie może wystąpić wartość ?NULL?</span>",
          "correct": true
        },
        {
          "answer": "<span>na tej kolumnie zostanie automatycznie założony indeks</span>",
          "correct": true
        },
        {
          "answer": "<span>to pole staje się kluczem głównym</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "<span>Wśród więzów spójności encji znajdują się:</span>",
      "id": 2374,
      "comments": null,
      "answers": [
        {
          "answer": "<span>więzy klucza jednoznacznego</span>",
          "correct": true
        },
        {
          "answer": "<span>więzy NOT NULL</span>",
          "correct": true
        },
        {
          "answer": "<span>więzy CHECK</span>",
          "correct": true
        },
        {
          "answer": "<span>więzy klucza głównego,</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "<span>Które z poniższych klauzul muszą wystąpić przed GROUP BY (zakładając, że chcemy, aby w ogóle wystąpiły)?</span>",
      "id": 2375,
      "comments": [
        {
          "author": "~anon@212.2.*.*",
          "comment": "Pamietać trzeba, ze w Oracle można wstawić Having przed Group by. Są pytania na egzaminie, w których jest to uwzględniane",
          "date": "13-02-2019 16:46:48"
        },
        {
          "author": "~df@91.207.*.*",
          "comment": "Można zrobić:\n\nSELECT empno, sal FROM emp HAVING sal > 100 GROUP BY empno, sal\nSELECT empno, sal FROM emp GROUP BY empno, sal HAVING sal > 100\n\nNie można natomiast użyć HAVING ... GROUP BY ... HAVING\n\nA więc HAVING nie musi być przed GROUP BY, ale jest taka możliwość.",
          "date": "10-07-2020 18:34:33"
        }
      ],
      "answers": [
        {
          "answer": "<span>INTO</span>",
          "correct": true
        },
        {
          "answer": "<span>FROM</span>",
          "correct": true
        },
        {
          "answer": "<span>WHERE</span>",
          "correct": true
        },
        {
          "answer": "<span>HAVING</span>",
          "correct": false
        }
      ]
    },
    {
      "question": "<span>Jaką wartość dla kolumny \"Salary\" zwróci to zapytanie?</span><br><span>SELECT ename, NVL(sal, 0) \"Salary\" FROM Emp WHERE Sal IS NULL ORDER BY ename;</span>",
      "id": 2376,
      "comments": null,
      "answers": [
        {
          "answer": "<table>\n<tbody>\n<tr>\n<td>0</td>\n</tr>\n</tbody>\n</table>",
          "correct": false
        },
        {
          "answer": "<span>spację</span>",
          "correct": false
        },
        {
          "answer": "<table>\n<tbody>\n<tr>\n<td>nic nie zwróci</td>\n<td>&nbsp;</td>\n</tr>\n</tbody>\n</table>",
          "correct": false
        },
        {
          "answer": "<span>null</span>",
          "correct": false
        }
      ]
    },
    {
      "question": "<span>Sortowania w bazie danych używa się przy:</span>",
      "id": 2377,
      "comments": null,
      "answers": [
        {
          "answer": "<span>budowie początkowego indeksu na B+-drzewie</span>",
          "correct": true
        },
        {
          "answer": "<span>wykonywaniu klauzuli UNION DISTINCT</span>",
          "correct": true
        },
        {
          "answer": "<span>wykonywaniu klauzuli ORDER BY</span>",
          "correct": true
        },
        {
          "answer": "<span>metodzie złączania Sort-Merge</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "<span>Instrukcja FETCH jest używana w kursorze PL/SQL w celu:</span>",
      "id": 2378,
      "comments": null,
      "answers": [
        {
          "answer": "<span>pobrania zawartości rekordu ze źródła danych i usunięcia poprzedniego rekordu</span>",
          "correct": false
        },
        {
          "answer": "<table>\n<tbody>\n<tr>\n<td>pobrania zawartości rekordu ze źródła danych i przejścia do następnego rekordu</td>\n<td>&nbsp;</td>\n</tr>\n</tbody>\n</table>",
          "correct": false
        },
        {
          "answer": "<span>pobrania zawartości rekordu ze źródła danych</span>",
          "correct": true
        },
        {
          "answer": "<span>przejścia do następnego rekordu</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "<span>Instrukcja FETCH jest używana w kursorze PL/SQL w celu:</span>",
      "id": 2379,
      "comments": null,
      "answers": [
        {
          "answer": "<span>pobrania zawartości rekordu ze źródła danych</span>",
          "correct": true
        },
        {
          "answer": "<span>usunięcia poprzedniego rekordu</span>",
          "correct": false
        },
        {
          "answer": "<table>\n<tbody>\n<tr>\n<td>pobrania zawartości rekordu ze źródła danych i przejścia do następnego rekordu</td>\n<td>&nbsp;</td>\n</tr>\n</tbody>\n</table>",
          "correct": false
        },
        {
          "answer": "<span>przejścia do następnego rekordu</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "<span>Jaki będzie efekt wykonania następującego polecenia:</span><br><span>CREATE TABLE Osoby</span><br><span>(imie VARCHAR2(30) PRIMARY KEY, nazwisko VARCHAR2(30) PRIMARY KEY, zarobki NUMBER(7,2))</span>",
      "id": 2380,
      "comments": [
        {
          "author": "~PozdrawiamKacpraZ@83.9.*.*",
          "comment": "Czy na pewno jest to poprawna odpowiedz?\nPrzeciez encja asocjacyjna moze miec 2 PK...?",
          "date": "02-02-2015 00:18:20"
        },
        {
          "author": "~anon@94.254.*.*",
          "comment": "encja asocjacyjna gdzie masz klucz glowny na imieniu i nazwisku ? no chyba niezbyt...\n",
          "date": "02-02-2015 00:27:02"
        },
        {
          "author": "~niePozdrawiamPozdrawiacza@94.254.*.*",
          "comment": "chyba cos sie pojebao.. w asocjacyjnej sa fk.",
          "date": "02-02-2015 00:30:03"
        },
        {
          "author": "~POZDRAWIAM@83.9.*.*",
          "comment": "pozdrawiam Twoj jutrzejszy wynik ! czekam az sie tu jutro pochwalisz. LOL ",
          "date": "02-02-2015 00:38:45"
        },
        {
          "author": "~anon@89.76.*.*",
          "comment": "Zgodnie z odpowiedzią z systemu edu to pytanie i odpowiedzi do niego są prawidłowe, a tak na logikę nu to gdzie w jednej tabeli dwa kluczy głównych",
          "date": "02-02-2015 14:23:17"
        },
        {
          "author": "~anon@94.254.*.*",
          "comment": "co prawda dzien opoznienia, ale gdybys dalej byl zainteresowany to dziekuje, zaliczone",
          "date": "04-02-2015 18:42:23"
        }
      ],
      "answers": [
        {
          "answer": "<table>\n<tbody>\n<tr>\n<td>zostanie stworzona tabela Osoby, której kluczem głównym będzie pole imie</td>\n</tr>\n</tbody>\n</table>",
          "correct": false
        },
        {
          "answer": "<span>zostanie stworzona tabela Osoby, której kluczem głównym będzie pole nazwisko</span>",
          "correct": false
        },
        {
          "answer": "<span>zostanie stworzona tabela Osoby, której kluczem głównym będzie zbiór złożony z pól (imie, nazwisko)</span>",
          "correct": false
        },
        {
          "answer": "<span>przy próbie wykonania polecenia wystąpi błąd</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "<span>Relacja R ma atrybut a. Jaka liczba może być wynikiem wykonania instrukcji SELECT Count(*) FROM R WHERE a=a</span>",
      "id": 2381,
      "comments": [
        {
          "author": "~FAJKA KB@87.207.*.*",
          "comment": "Tylko odpowiedź \"zawsze tyle jaka jest liczebność relacji R\", sprawdzone w Oracle\n(\"Select Count (*) FROM Osoba WHERE imie = imie;\" zwraca 32 - czyli ilość rekordów w tablicy osoba).",
          "date": "29-01-2017 23:04:03"
        },
        {
          "author": "~Majkel@213.238.*.*",
          "comment": "Nie prawda, w przypadku gdy w kolumnach sa NULLe - wtedy nie są zliczane. Dlatego odpowiedz 0 lub 1 jest poprawna.",
          "date": "01-07-2017 17:12:13"
        }
      ],
      "answers": [
        {
          "answer": "<table>\n<tbody>\n<tr>\n<td>zawsze tyle jaka jest liczebność relacji R</td>\n<td>&nbsp;</td>\n</tr>\n</tbody>\n</table>",
          "correct": false
        },
        {
          "answer": "<span>0</span>",
          "correct": true
        },
        {
          "answer": "<span>1</span>",
          "correct": true
        },
        {
          "answer": "<span>dowolna liczba naturalna</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "<span>Wskazać poprawne zapytanie SQL (w Oracle) znajdujące stanowiska pracy występujące zarówno &nbsp;w dziale 10 jak i w dziale 20.&nbsp;</span>",
      "id": 2382,
      "comments": null,
      "answers": [
        {
          "answer": "<span>SELECT DISTINCT job FROM emp WHERE deptno = 10 AND deptno = 20</span>",
          "correct": false
        },
        {
          "answer": "<span>SELECT DISTINCT job FROM emp WHERE deptno = 10 INTERSECT SELECT DISTINCT job FROM emp WHERE deptno = 20</span>",
          "correct": true
        },
        {
          "answer": "<span>SELECT DISTINCT job FROM emp WHERE deptno = 10 UNION SELECT DISTINCT job FROM emp WHERE deptno = 20</span>",
          "correct": false
        },
        {
          "answer": "<span>SELECT DISTINCT job FROM emp WHERE deptno = 10 OR deptno = 20</span>",
          "correct": false
        }
      ]
    },
    {
      "question": "<span>Ile warunków złączeń potrzeba w zapytaniu aby uniknąć złączenia kartezjańskiego?</span>",
      "id": 2383,
      "comments": null,
      "answers": [
        {
          "answer": "<span>w ogóle</span>",
          "correct": false
        },
        {
          "answer": "<span>liczba tabel plus jeden</span>",
          "correct": false
        },
        {
          "answer": "<span>liczba tabel minus jeden</span>",
          "correct": true
        },
        {
          "answer": "<span>liczba kolumn minus jeden</span>",
          "correct": false
        }
      ]
    },
    {
      "question": "<span>Wskazać poprawne zapytanie SQL (w Oracle) znajdujące stanowiska, na których średni zarobek wynosi 3000 lub więcej.&nbsp;</span>",
      "id": 2384,
      "comments": [
        {
          "author": "~anon@91.235.*.*",
          "comment": "takie samo pytanie jak 75 i inne odpowiedzi, wiec które są poprawne, moim zdaniem to te sa zle powinny byc zaznaczone b i c",
          "date": "06-02-2015 14:45:27"
        },
        {
          "author": "~s8780@89.76.*.*",
          "comment": "ODpowiedzi z edu testu są Więc jest dobrze",
          "date": "06-02-2015 16:10:36"
        },
        {
          "author": "~step@94.254.*.*",
          "comment": "to samo co wcześniej czyli d w tym przypadku",
          "date": "13-02-2017 20:44:16"
        },
        {
          "author": "~damdev@89.77.*.*",
          "comment": "A nie powinno być c i d? \nW odpowiedzi a: HAVING występuje w połączeniu z GROUP BY ale po GROUP BY a nie przed więc wg mnie zła odpowiedź. ",
          "date": "27-06-2017 16:38:16"
        },
        {
          "author": "~fsh@89.64.*.*",
          "comment": "HAVING jak najbardziej może się pojawić zarówno przed, jak i po GROUP BY.",
          "date": "03-02-2019 20:09:35"
        }
      ],
      "answers": [
        {
          "answer": "<table>\n<tbody>\n<tr>\n<td>SELECT job, AVG(sal) FROM emp HAVING AVG (sal) &gt;= 3000 GROUP BY job</td>\n</tr>\n</tbody>\n</table>",
          "correct": false
        },
        {
          "answer": "<table>\n<tbody>\n<tr>\n<td>SELECT job, AVG(sal) FROM emp GROUP BY job WHERE AVG (sal) &gt;= 3000</td>\n<td>&nbsp;</td>\n</tr>\n</tbody>\n</table>",
          "correct": false
        },
        {
          "answer": "<span>SELECT job, AVG(sal) FROM emp WHERE AVG (sal) &gt;= 3000 GROUP BY job</span>",
          "correct": false
        },
        {
          "answer": "<table>\n<tbody>\n<tr>\n<td>SELECT job, AVG(sal) FROM emp GROUP BY job HAVING AVG (sal) &gt;= 3000</td>\n<td>&nbsp;</td>\n</tr>\n</tbody>\n</table>",
          "correct": false
        }
      ]
    },
    {
      "question": "<span>Kursor w PL/SQL jest to:</span>",
      "id": 2385,
      "comments": null,
      "answers": [
        {
          "answer": "<span>rodzaj procedury</span>",
          "correct": false
        },
        {
          "answer": "<span>typ zmiennej</span>",
          "correct": false
        },
        {
          "answer": "<table>\n<tbody>\n<tr>\n<td>obszar roboczy używany do wykonania instrukcji SQL</td>\n<td>&nbsp;</td>\n</tr>\n</tbody>\n</table>",
          "correct": false
        },
        {
          "answer": "<span>narzędzie do podnoszenia wyjątków</span>",
          "correct": false
        }
      ]
    },
    {
      "question": "<span>Kursor w PL/SQL jest to:</span>",
      "id": 2386,
      "comments": null,
      "answers": [
        {
          "answer": "<span>rodzaj procedury</span>",
          "correct": false
        },
        {
          "answer": "<span>typ zmiennej</span>",
          "correct": false
        },
        {
          "answer": "<table>\n<tbody>\n<tr>\n<td>obszar roboczy używany do wykonania instrukcji SQL</td>\n<td>&nbsp;</td>\n</tr>\n</tbody>\n</table>",
          "correct": false
        },
        {
          "answer": "<span>narzędzie do podnoszenia wyjątków</span>",
          "correct": false
        }
      ]
    },
    {
      "question": "<span>Kursor w PL/SQL to:</span>",
      "id": 2387,
      "comments": null,
      "answers": [
        {
          "answer": "<span>obiekt o określonych właściwościach i metodach</span>",
          "correct": true
        },
        {
          "answer": "<span>rodzaj procedury</span>",
          "correct": false
        },
        {
          "answer": "<span>funkcja debuggera</span>",
          "correct": false
        },
        {
          "answer": "<span>typ zmiennej</span>",
          "correct": false
        }
      ]
    },
    {
      "question": "<span>Wskazać poprawne (w Oraclu) zapytanie SQL znajdujące średnie zarobki tylko tych departamentów, które zatrudniają więcej niż trzech pracowników.</span>",
      "id": 2388,
      "comments": [
        {
          "author": "~annonn@89.64.*.*",
          "comment": "group by musi byc uzyte przed having, no chyba ze czegos nie wiem\n\nodpowiedz A raczej odpada",
          "date": "15-02-2018 12:54:50"
        },
        {
          "author": "~kogut@83.24.*.*",
          "comment": "w oracle mozna zrobic i tak i tak ",
          "date": "03-07-2018 13:59:56"
        }
      ],
      "answers": [
        {
          "answer": "<span>SELECT deptno, AVG(sal) FROM emp HAVING COUNT (*) &gt; 3 GROUP BY deptno;</span>",
          "correct": true
        },
        {
          "answer": "<span>SELECT deptno, AVG(sal) FROM emp GROUP BY deptno HAVING COUNT (*) &gt; 3;</span>",
          "correct": true
        },
        {
          "answer": "<table>\n<tbody>\n<tr>\n<td>SELECT deptno, AVG(sal) FROM emp GROUP BY deptno WHERE COUNT (*) &gt; 3;</td>\n<td>&nbsp;</td>\n</tr>\n</tbody>\n</table>",
          "correct": false
        }
      ]
    },
    {
      "question": "<span>Wśród instrukcji występujących w bloku PL/SQL (między BEGIN a END) mogą się znaleźć:</span>",
      "id": 2389,
      "comments": [
        {
          "author": "~anon@213.195.*.*",
          "comment": "c także poprawna: prócz zmiennych deklarowanych w bloku Pl/SQL mogą jeszcze występować\nzmienne z aplikacji korzystających z bloku Pl/SQL. Nazywane są zmiennymi\nwiązania, a w odwołaniach ich nazwa poprzedzana jest dwukropkiem. Deklarowane są\npoleceniem SQL*Plus VARIABLE, wypisywane poleceniem PRINT.\n",
          "date": "07-02-2019 22:49:07"
        },
        {
          "author": "~anon@89.64.*.*",
          "comment": "Ale nie mogą być deklarowane w bloku PL/SQL tylko poza nim. Przykład z wykładu:\nACCEPT year_sal PROMPT 'Podaj roczne zarobki'\nVARIABLE sal NUMBER(8,2)\nBEGIN\n  :sal := &year_sal /12;\nEND;\n/\nPRINT sal",
          "date": "10-02-2019 13:10:57"
        }
      ],
      "answers": [
        {
          "answer": "<table>\n<tbody>\n<tr>\n<td>instrukcja CREATE TABLE</td>\n</tr>\n</tbody>\n</table>",
          "correct": false
        },
        {
          "answer": "<span>instrukcja COMMIT</span>",
          "correct": true
        },
        {
          "answer": "<span>instrukcje SQL*Plus</span>",
          "correct": false
        },
        {
          "answer": "<span>deklaracje zmiennych</span>",
          "correct": false
        }
      ]
    },
    {
      "question": "<span>Czy istniejący indeks przyśpiesza wykonanie instrukcji COMMIT?</span>",
      "id": 2390,
      "comments": null,
      "answers": [
        {
          "answer": "<table>\n<tbody>\n<tr>\n<td>czasem</td>\n<td>&nbsp;</td>\n</tr>\n</tbody>\n</table>",
          "correct": false
        },
        {
          "answer": "<table>\n<tbody>\n<tr>\n<td>zawsze</td>\n<td>&nbsp;</td>\n</tr>\n</tbody>\n</table>",
          "correct": false
        },
        {
          "answer": "<span>nigdy</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "<span>W którym z poniższych zapytań jest użyte złączenie zewnętrzne między dwiema tabelami (w Oraclu)?</span>",
      "id": 2391,
      "comments": [
        {
          "author": "~OCB@5.173.*.*",
          "comment": "Czy odp.d nie jest przypadkiem dobra?",
          "date": "07-02-2019 16:58:40"
        },
        {
          "author": "~nie@79.184.*.*",
          "comment": "nie, i nauczcie się w końcu, że odpowiedzi są kurwa losowo\nja pierdole",
          "date": "16-02-2019 18:57:35"
        }
      ],
      "answers": [
        {
          "answer": "<span>SELECT region.region_name, employee.salary FROM region, employee WHERE region.id = employee.region_no(+);</span>",
          "correct": true
        },
        {
          "answer": "<span>SELECT region.region_name, employee.salary FROM region, employee WHERE employee.salary BETWEEN region.avg_salary AND region.max_salary;</span>",
          "correct": false
        },
        {
          "answer": "<span>SELECT region.region_name, employeeinfo.last_name FROM employee region, employee employeeinfo WHERE employeeinfo.id &gt;= region.manager_id;</span>",
          "correct": false
        },
        {
          "answer": "<span>SELECT region.region_name, employee.salary FROM region, employee WHERE region.id = employee.region_no;</span>",
          "correct": false
        }
      ]
    },
    {
      "question": "<span>Czy istniejący indeks przyśpiesza wykonanie instrukcji DELETE?</span>",
      "id": 2392,
      "comments": null,
      "answers": [
        {
          "answer": "<span>zawsze</span>",
          "correct": false
        },
        {
          "answer": "<table>\n<tbody>\n<tr>\n<td>czasem</td>\n<td>&nbsp;</td>\n</tr>\n</tbody>\n</table>",
          "correct": false
        },
        {
          "answer": "<span>nigdy</span>",
          "correct": false
        }
      ]
    },
    {
      "question": "<span>Jaka jest wartość wyrażenia NOT Null?</span>",
      "id": 2393,
      "comments": [
        {
          "author": "~anon@109.241.*.*",
          "comment": "NOT NULL jako wartosc nieokreslona w tabeli logiki 3 stanowej = nieokreslone. NOT NULL = Unknown",
          "date": "06-07-2018 17:41:38"
        },
        {
          "author": "~anon@109.241.*.*",
          "comment": "-------------------\n-  p  ---   NOT p -\n-------------------\n- TRUE ---  FALSE -\n-------------------\n- FALSE ---  TRUE -\n-------------------\n- UNKWN --- UNKWN -\n-------------------",
          "date": "06-07-2018 17:45:06"
        }
      ],
      "answers": [
        {
          "answer": "<span>False</span>",
          "correct": false
        },
        {
          "answer": "<span>NULL</span>",
          "correct": true
        },
        {
          "answer": "<span>True</span>",
          "correct": false
        },
        {
          "answer": "<span>jest nieokreślone</span>",
          "correct": false
        }
      ]
    },
    {
      "question": "<span>Które metody dotyczą ochrony danych przed nieautoryzowanym dostępem?</span>",
      "id": 2394,
      "comments": null,
      "answers": [
        {
          "answer": "<span>wprowadzenie kont i haseł</span>",
          "correct": true
        },
        {
          "answer": "<span>słownik danych</span>",
          "correct": false
        },
        {
          "answer": "<span>kopia zapasowa</span>",
          "correct": false
        },
        {
          "answer": "<table>\n<tbody>\n<tr>\n<td>przyznawanie uprawnień do wykonywania operacji na obiektach</td>\n<td>&nbsp;</td>\n</tr>\n</tbody>\n</table>",
          "correct": false
        }
      ]
    },
    {
      "question": "<span>W którym z poniższych przypadków konieczne jest umieszczenie tekstu w apostrofach (w Oraclu)?</span>",
      "id": 2395,
      "comments": null,
      "answers": [
        {
          "answer": "<table>\n<tbody>\n<tr>\n<td>odwołanie do zmiennej typu CHAR w klauzuli WHERE</td>\n</tr>\n</tbody>\n</table>",
          "correct": false
        },
        {
          "answer": "<span>odwołanie do zmiennej numerycznej w klauzuli WHERE</span>",
          "correct": false
        },
        {
          "answer": "<span>wyświetlenie myślnika (-) między dwoma połączonymi kolumnami</span>",
          "correct": true
        },
        {
          "answer": "<span>wskazanie nazw kolumn w klauzuli SELECT</span>",
          "correct": false
        }
      ]
    },
    {
      "question": "W wyzwalaczu T-SQL:<p></p>\n<p>&nbsp;\n          </p>",
      "id": 2396,
      "comments": null,
      "answers": [
        {
          "answer": "Mogą byc deklarowane zmienne.<p></p>\n<p>&nbsp;</p>",
          "correct": true
        },
        {
          "answer": "Można uzywać instrukcji DML.<p></p>\n<p>&nbsp;</p>",
          "correct": true
        },
        {
          "answer": "Można używać kursorów.<p></p>\n<p>&nbsp;</p>",
          "correct": true
        },
        {
          "answer": "Można używać instrukcji ROLLBACK",
          "correct": true
        }
      ]
    },
    {
      "question": "Jakie znaczenie ma dziennik powtórzeń w serwerach baz danych?<p></p>\n<p>&nbsp;\n          </p>",
      "id": 2397,
      "comments": null,
      "answers": [
        {
          "answer": "Pozwala wycofywać transakcje.<p></p>\n<p>&nbsp;</p>",
          "correct": true
        },
        {
          "answer": "Pozwala na odtworzenie stanu bazy danych z określonego punktu w czasie.<p></p>\n<p>&nbsp;</p>",
          "correct": true
        },
        {
          "answer": "Pozwala zarządzać uprawnieniami.<p></p>\n<p>&nbsp;</p>",
          "correct": false
        },
        {
          "answer": "Pozwala zachować spójność danych po awarii.<p></p>\n<p>&nbsp;</p>",
          "correct": true
        }
      ]
    },
    {
      "question": "Zaznacz poprawne stwierdzenia dotyczące kopii zapasowych w MS SQL Server:<p></p>\n<p>&nbsp;\n          </p>",
      "id": 2398,
      "comments": null,
      "answers": [
        {
          "answer": "Kopia różnicowa zawiera zmiany miedzy podstawowym plikiem z danymi (mdf), a dodatkowym plikiem z danymi (ndf).<p></p>\n<p>&nbsp;</p>",
          "correct": false
        },
        {
          "answer": "Kopia różnicowa zawiera zmiany w bazie danych wykonane od ostatniej kopii pełnej.<p></p>\n<p>&nbsp;</p>",
          "correct": true
        },
        {
          "answer": "Kopia różnicowa zawiera zmiany w bazie danych wykonane od poprzedniej kopii różnicowej.",
          "correct": false
        },
        {
          "answer": "Kopia różnicowa zawiera zmiany w bazie danych wykonane od ostatniej kopii dziennika transakcji.",
          "correct": false
        }
      ]
    },
    {
      "question": "Partycjonowanie tabel polega na:",
      "id": 2399,
      "comments": null,
      "answers": [
        {
          "answer": "Podziale tabeli na wiele części względem wartości w wierszach.",
          "correct": true
        },
        {
          "answer": "Podziale tabeli na schemat oraz zawartość.",
          "correct": false
        },
        {
          "answer": "Podziale tabeli&nbsp; na wiele plików dyskowych.",
          "correct": true
        },
        {
          "answer": "Podziale tabel na wiele częsci względem kolumn.<p></p>\n<p>&nbsp;</p>",
          "correct": false
        }
      ]
    },
    {
      "question": "W funkcji (FUNCTION) PL/SQL:",
      "id": 2400,
      "comments": null,
      "answers": [
        {
          "answer": "Funkcje definiowane w bazie danych moga być użyte w poleceniach SQL.",
          "correct": true
        },
        {
          "answer": "Nazwa funkcji może zostać przeciążona.<p></p>\n<p>&nbsp;</p>",
          "correct": true
        },
        {
          "answer": "Można użyć instrukcji DQL.",
          "correct": true
        },
        {
          "answer": "Nie można zadeklarować parametru typu OUT.<p></p>\n<p>&nbsp;</p>",
          "correct": true
        }
      ]
    },
    {
      "question": "<span><span><span>Jakie są podstawowe składowe diagramów związków encji?</span></span></span>",
      "id": 2402,
      "comments": null,
      "answers": [
        {
          "answer": "<span><span><span><span>związki</span></span></span></span>",
          "correct": true
        },
        {
          "answer": "<span><span><span><span>atrybuty</span></span></span></span>",
          "correct": true
        },
        {
          "answer": "<span><span><span><span>encje</span></span></span></span>",
          "correct": true
        }
      ]
    },
    {
      "question": "<p align=\"LEFT\"><span><span><span>Jaki rodzaj związku binarnego jest elementarnym związkiem w hierarchii encji?</span></span></span></p>",
      "id": 2403,
      "comments": null,
      "answers": [
        {
          "answer": "<p align=\"LEFT\"><span><span><span><span>związek jedno-jednoznaczny oznaczany symbolem&nbsp;</span><span><span><strong>jest</strong></span></span><span>.</span> </span></span></span></p>",
          "correct": true
        },
        {
          "answer": "związek weloznaczny",
          "correct": false
        }
      ]
    },
    {
      "question": "W nagłówku bloku anonimowego w PL/SQL może wystąpić :",
      "id": 2404,
      "comments": [
        {
          "author": "~mm@89.67.*.*",
          "comment": "Z jakiej paki BEGIN? ktoś może jakimś źródłem to poprzeć?",
          "date": "01-07-2017 14:21:15"
        },
        {
          "author": "~joł@89.70.*.*",
          "comment": "\"Deklaracje i obsługa wyjątków są opcjonalne\" - RBD 5.1",
          "date": "31-08-2017 20:31:51"
        },
        {
          "author": "~anon@162.158.*.*",
          "comment": "up?",
          "date": "29-06-2019 22:44:36"
        }
      ],
      "answers": [
        {
          "answer": "TRY",
          "correct": false
        },
        {
          "answer": "DECLARE",
          "correct": true
        },
        {
          "answer": "BEGIN",
          "correct": true
        },
        {
          "answer": "CATCH",
          "correct": false
        }
      ]
    },
    {
      "question": "<span>Wśród instrukcji występujących w bloku PL/SQL mogą się znaleźć:</span>",
      "id": 2405,
      "comments": null,
      "answers": [
        {
          "answer": "instrukcja COMMIT",
          "correct": true
        },
        {
          "answer": "instrukcja DBMS_OUTPUT.PUT_LINE(‘Początek transakcji’),",
          "correct": true
        },
        {
          "answer": "instrukcja ROLLBACK.",
          "correct": true
        },
        {
          "answer": "instrukcja warunkowa",
          "correct": true
        }
      ]
    },
    {
      "question": "<p align=\"LEFT\"><span><span><span>Które z następujących elementów:&nbsp;</span></span></span><span><span><span><em>atrybuty, encje, związki</em></span></span></span><span><span><span>&nbsp;mogą być argumentami związków?</span></span></span></p>",
      "id": 2407,
      "comments": null,
      "answers": [
        {
          "answer": "<p align=\"LEFT\"><span><span><span><span><span>atrybuty dekryptywne</span></span></span></span></span></p>",
          "correct": true
        },
        {
          "answer": "<p align=\"LEFT\"><span><span><span><span><span>encje</span></span></span></span></span></p>",
          "correct": true
        },
        {
          "answer": "<p align=\"LEFT\"><span><span><span><span><span>związki</span></span></span></span></span></p>",
          "correct": true
        }
      ]
    },
    {
      "question": "<p align=\"LEFT\"><span><span><span>Jak nazywa się notacja zapisu zapytań używana przy ich optymalizacji?</span></span></span></p>",
      "id": 2408,
      "comments": null,
      "answers": [
        {
          "answer": "selekcja",
          "correct": false
        },
        {
          "answer": "<p align=\"LEFT\"><span><span><span><span><span>algebra zapytań</span></span></span></span></span></p>",
          "correct": true
        }
      ]
    },
    {
      "question": "<p align=\"LEFT\"><span><span><span>Jakie są specjalne notacje zapytań?</span></span></span></p>",
      "id": 2409,
      "comments": null,
      "answers": [
        {
          "answer": "<p align=\"LEFT\"><span><span><span><span><span>QBE</span></span></span></span></span></p>",
          "correct": true
        },
        {
          "answer": "<p align=\"LEFT\"><span><span><span><span><span>rachunek relacyjny</span></span></span></span></span></p>",
          "correct": true
        },
        {
          "answer": "<p align=\"LEFT\"><span><span><span><span><span>algebra relacji</span></span></span></span></span></p>",
          "correct": true
        }
      ]
    },
    {
      "question": "<p align=\"LEFT\"><span><span><span>Jaki jest model podstawowej jednostki danych poziomu fizycznego bazy danych?</span></span></span></p>",
      "id": 2410,
      "comments": [
        {
          "author": "~anon@81.15.*.*",
          "comment": "Jak dla mnie to tabela jest podstawową jednostką danych. Ponieważ bez tabeli nie mogły by powstać rekordy. Inaczej mówiąc \"Co było pierwsze kura czy jajko\". Jak dla mnie rekord jest elementarną jednostką ale nie podstawową.",
          "date": "30-01-2016 11:01:32"
        },
        {
          "author": "~anon@81.15.*.*",
          "comment": "Dodając jeszcze. Tabela może istnieć bez rekordów ale rekord bez tabeli już nie.",
          "date": "30-01-2016 11:06:58"
        },
        {
          "author": "~kogut@109.206.*.*",
          "comment": "\"Modelem podstawowej jednostki danych w bazie danych jest rekord składający się z pól określonych typów danych.\"",
          "date": "03-07-2018 21:08:58"
        }
      ],
      "answers": [
        {
          "answer": "<p align=\"LEFT\"><span><span><span><span><span><em>rekord&nbsp;</em></span></span><span><span>składający się z&nbsp;</span></span><span><span><em>pól</em></span></span><span>&nbsp;</span><span><span>określonych&nbsp;</span></span><span><span><em>typów danych</em></span></span></span></span></span></p>",
          "correct": true
        },
        {
          "answer": "tabela",
          "correct": false
        }
      ]
    },
    {
      "question": "<p><span><span><span>Implementacja migawki prostej z opcją REFRESH FAST w głównej bazie danych wymaga utworzenia:</span></span></span></p>",
      "id": 2411,
      "comments": null,
      "answers": [
        {
          "answer": "<form method=\"POST\" name=\"unnamed30\">\n<p><span><span><span>perspektywy<br><br></span></span></span></p>\n</form>",
          "correct": false
        },
        {
          "answer": "<span><span>&nbsp;indeksu&nbsp;</span></span>",
          "correct": false
        },
        {
          "answer": "<span>dziennika migawki &nbsp;</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "<span lang=\"EN-US\">Problem fantomów dotyczy sytuacji w&nbsp;</span>",
      "id": 2457,
      "comments": null,
      "answers": [
        {
          "answer": "<span lang=\"EN-US\">W trakcie działania transakcji inna transakcja wstawiła nowy rekord</span>",
          "correct": true
        },
        {
          "answer": "W trakcie działanie transkacji inna usunęła rekord",
          "correct": false
        },
        {
          "answer": "Użytkownik zobaczyl rekord wprowadzony przez innego użytkownika, który &nbsp;nie został zatwierdzony przez COMMIT",
          "correct": false
        },
        {
          "answer": "Rekord został w obrębie jednej transkacji wprowadzony (INSERT) i od razu usunięty (DELETE)",
          "correct": false
        }
      ]
    },
    {
      "question": "Która z instrukcji PL/SQL nie zakończy się błędem , przy założeniu że w tabelki DEPTNO są dwa rekordy z wartościami Deptno IN (10,20) oraz prawidłowej deklaracji zmiennej v_deptno",
      "id": 2458,
      "comments": [
        {
          "author": "~Gimbus@89.67.*.*",
          "comment": "Dlaczego c jest poprawne, a b nie?",
          "date": "03-07-2015 10:40:30"
        },
        {
          "author": "~Murek1993@78.11.*.*",
          "comment": "B tez dobre",
          "date": "03-07-2015 12:15:07"
        },
        {
          "author": "~kogut@109.206.*.*",
          "comment": "potwierdzam",
          "date": "03-07-2018 20:39:32"
        },
        {
          "author": "~anon@46.112.*.*",
          "comment": "up",
          "date": "07-02-2019 22:39:18"
        },
        {
          "author": "mykhi",
          "comment": "zaznaczam",
          "date": "07-02-2019 23:10:14"
        },
        {
          "author": "~anon@79.184.*.*",
          "comment": "jak w trzecim przypadku możemy do zmiennej dwie wartosci wpisać? Ktos mi wytlumaczy? ",
          "date": "14-02-2019 16:09:23"
        },
        {
          "author": "~anon@89.171.*.*",
          "comment": "dlaczego dwie? zostanie uwzględniona tylko wartość 10",
          "date": "01-09-2019 08:49:46"
        }
      ],
      "answers": [
        {
          "answer": "SELECT deptno INTO v_deptno FROM dept WHERE deptno = 10;",
          "correct": true
        },
        {
          "answer": "SELECT deptno INTO v_deptno FROM dept WHERE deptno &gt; 10;",
          "correct": true
        },
        {
          "answer": "SELECT deptno INTO v_deptno FROM dept WHERE deptno &lt; 20;",
          "correct": true
        },
        {
          "answer": "SELECT deptno INTO v_deptno FROM dept WHERE deptno = 30;",
          "correct": false
        }
      ]
    },
    {
      "question": "<p><span>&nbsp; &nbsp;Która z poniższych instrukcji PL/SQL prawidłowo podstawia wartość na zmienną (w tabeli EMP jest 14 rekordów) ?</span></p>",
      "id": 2459,
      "comments": [
        {
          "author": "~anon@213.195.*.*",
          "comment": "drugie niepoprawne, ponieważ deklarować zmienne można tylko w bloku declare. Byloby poprawne gdy V_ala byloby zadeklarowane a dopiero potem v_ala := 'Ala';\n\nPLS-00103: Encountered the symbol \"VARCHAR2\" when expecting one of the following:\n\n   := . ( @ % ;\nThe symbol \":=\" was substituted for \"VARCHAR2\" to continue.",
          "date": "07-02-2019 22:34:27"
        },
        {
          "author": "~OCB@5.173.*.*",
          "comment": "Moim zdaniem odpowiedź trzecia jest jedyną poprawną.",
          "date": "13-02-2019 16:58:24"
        },
        {
          "author": "~anon@94.254.*.*",
          "comment": "Co wy pierdolicie",
          "date": "15-02-2019 11:26:10"
        },
        {
          "author": "~anon@89.64.*.*",
          "comment": "up",
          "date": "04-02-2020 23:34:32"
        },
        {
          "author": "~df@91.207.*.*",
          "comment": "2 niepoprawne:\n* Brak DECLARE\n* Różne ciapki (' i `)",
          "date": "10-07-2020 19:16:51"
        }
      ],
      "answers": [
        {
          "answer": "<span lang=\"EN-US\">SELECT ename INTO v_ename FROM emp;</span>",
          "correct": false
        },
        {
          "answer": "<span lang=\"EN-US\">V_ala Varchar2(10) := ‘Ala’;</span>",
          "correct": true
        },
        {
          "answer": "<span lang=\"EN-US\">SELECT ename INTO v_name FROM emp WHERE empno = 1234;</span>",
          "correct": true
        },
        {
          "answer": "<span lang=\"EN-US\">SELECT v_ename = ename FROM emp WHERE empno = 1234;</span>",
          "correct": false
        }
      ]
    },
    {
      "question": "<p><span>&nbsp; &nbsp;Użycie klauzuli UNIQUE w deklaracji pola instrukcji CREATE TABLE oznacza , że :</span></p>",
      "id": 2460,
      "comments": null,
      "answers": [
        {
          "answer": "<span lang=\"EN-US\">Wartości w tym polu nie mogą się powtarzać;</span>",
          "correct": true
        },
        {
          "answer": "<span lang=\"EN-US\">Na tej kolumnie zostanie automatycznie założony indeks</span>",
          "correct": true
        },
        {
          "answer": "<p><span>&nbsp; &nbsp;W żadnym innym polu tej tabeli nie można użyć klauzuli UNIQUE</span></p>",
          "correct": false
        },
        {
          "answer": "<span lang=\"EN-US\">W tym polu nie może pojawić się wartość NULL</span>",
          "correct": false
        }
      ]
    },
    {
      "question": "<p><span>&nbsp; &nbsp; Procedura T-SQL zwraca poprzez Result Set :</span></p>",
      "id": 2462,
      "comments": null,
      "answers": [
        {
          "answer": "<span lang=\"EN-US\">Procedura może zwrócić wynik tylko poprzez zmienna OUTPUT</span>",
          "correct": false
        },
        {
          "answer": "<span lang=\"EN-US\">Wszystkie wiersze ostatniej uruchomionej wewnątrz procedury instrukcji SELECT</span>",
          "correct": true
        },
        {
          "answer": "<span lang=\"EN-US\">Poprzez Result Set mogą być zwracane wyłącznie komunikaty o błędach</span>",
          "correct": false
        },
        {
          "answer": "<span lang=\"EN-US\">Ostatni wiersz ostatniej uruchomionej wewnątrz procedury instrukcji SELECT</span>",
          "correct": false
        }
      ]
    },
    {
      "question": "<p><span>&nbsp; &nbsp;Która z poniższych instrukcji jest poprawna w T-SQL , jeżeli zostały prawidłowo zadeklarowane zmienne @empno i @deptno ?</span></p>",
      "id": 2463,
      "comments": [
        {
          "author": "~anon@162.158.*.*",
          "comment": "b i c nie są wartosciami (np skalarnymi)",
          "date": "29-06-2019 21:40:16"
        },
        {
          "author": "~df@91.207.*.*",
          "comment": "W SSMS wszystkie poprawnie się skompilowały, więc wszystkie są poprawne.",
          "date": "10-07-2020 19:20:12"
        }
      ],
      "answers": [
        {
          "answer": "<span lang=\"EN-US\">SELECT @empno = 100;</span>",
          "correct": true
        },
        {
          "answer": "<span lang=\"EN-US\">SELECT @empno = @empno;</span>",
          "correct": true
        },
        {
          "answer": "<span lang=\"EN-US\">SELECT @empno = empno FROM emp;</span>",
          "correct": true
        },
        {
          "answer": "<span lang=\"EN-US\">SELECT @empno = Max(empno) FROM emp;</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "<p><span>&nbsp; &nbsp;Dane są trzy tabele Klienci ( Id_Klienta, Imie , Nazwisko ), Produkty (Id_Produktu , Nazwa , Cena ) oraz Zakupy (Id_Klienta , Id_Produktu , Ilosc ) . Wskaż poprawne zapytania SQL znajdujące nazwy i ceny produktów , które zostały zakupione przez przynajmniej jednego klienta .</span></p>",
      "id": 2465,
      "comments": null,
      "answers": [
        {
          "answer": "<span lang=\"EN-US\">SELECT DISTINCT Nazwa , Cena FROM Zakupy RIGHT OUTER JOIN Produkty ON Produkty.Id_Produktu = Zakupy.Id_Produktu;</span>",
          "correct": false
        },
        {
          "answer": "<span lang=\"EN-US\">SELECT DISTINCT Nazwa , Cena FROM Produkty, Zakupy WHERE Produkty.Id_Produktu = Zakupy.Id_Produktu;</span>",
          "correct": true
        },
        {
          "answer": "<span lang=\"EN-US\">SELECT DISTINCT Nazwa , Cena FROM Produkty, Klienci;</span>",
          "correct": false
        },
        {
          "answer": "<span lang=\"EN-US\">SELECT DISTINCT Nazwa , Cena FROM Produkty INNER JOIN Zakupy ON Produkty.Id_Produktu = Zakupy.Id_Produktu;</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "Które z poniższych stwierdzeń jest prawidłowe w PL/SQL ?",
      "id": 2467,
      "comments": [
        {
          "author": "~anon@94.254.*.*",
          "comment": "Trzecie jest niepoprawne - brakuje słowa LOOP ",
          "date": "29-01-2016 17:22:31"
        },
        {
          "author": "~piotrek@95.49.*.*",
          "comment": "Pierwsze jest poprawne. ",
          "date": "09-08-2016 13:51:22"
        },
        {
          "author": "~mm@89.67.*.*",
          "comment": "Pierwsze nie jest poprawne. W Trzecim zgadzam się - brakuje LOOP",
          "date": "01-07-2017 12:30:09"
        },
        {
          "author": "~anon@148.81.*.*",
          "comment": "1 i 3 źle",
          "date": "01-07-2017 12:38:19"
        },
        {
          "author": "~Mossi@94.254.*.*",
          "comment": "FOR i IN [REVERSE] wartość1..wartość2 LOOP \n\tciąg_instrukcji \nEND LOOP;",
          "date": "07-07-2018 06:27:45"
        },
        {
          "author": "~anon@46.112.*.*",
          "comment": "up",
          "date": "07-02-2019 22:18:46"
        },
        {
          "author": "mykhi",
          "comment": "odznaczam c)",
          "date": "07-02-2019 22:20:01"
        }
      ],
      "answers": [
        {
          "answer": "Prawidłową konstrukcję pętli jest WHILE warunek BEGIN ciąg instrukcji END",
          "correct": false
        },
        {
          "answer": "Prawidłową konstrukcję pętli jest LOOP ciąg instrukcji END LOOP;",
          "correct": true
        },
        {
          "answer": "Prawidłową konstrukcję pętli jest FOR i IN x … y ciąg instrukcji END LOOP;",
          "correct": false
        },
        {
          "answer": "Prawidłową konstrukcję pętli jest WHILE warunek LOOP ciąg instrukcji END LOOP;",
          "correct": true
        }
      ]
    },
    {
      "question": "<p><span>&nbsp; &nbsp;Wskaż poprawne zapytanie SQL (dialekt Oracle) znajdujące pracowników zarabiających minimalną pensję na ich stanowiskach pracy :</span></p>",
      "id": 2468,
      "comments": null,
      "answers": [
        {
          "answer": "<span lang=\"EN-US\">SELECT ename , job , sal FROM emp WHERE (sal,job) IN (SELECT MIN(sal) , job FROM emp GROUP BY job );</span>",
          "correct": true
        },
        {
          "answer": "<span lang=\"EN-US\">SELECT ename, job MIN(sal) FROM emp GROUP BY job;</span>",
          "correct": false
        },
        {
          "answer": "<span lang=\"EN-US\">SELECT ename, job, sal FROM emp WHERE sal = (SELECT MIN(sal) FROM emp GROUP BY job);</span>",
          "correct": false
        },
        {
          "answer": "<span lang=\"EN-US\">SELECT ename , job, sal FROM emp e WHERE sal = (SELECT MIN(sal) From emp WHERE job = e.job);</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "<p align=\"LEFT\"><span><span><span>Co należy do zalet synonimów?</span></span></span></p>",
      "id": 2551,
      "comments": null,
      "answers": [
        {
          "answer": "Są środkiem do realizacji niezależności fizycznej danych.",
          "correct": false
        },
        {
          "answer": "Ochraniają przed niepowołanym lub nieprawidłowym dostępem do danych.",
          "correct": false
        },
        {
          "answer": "<span lang=\"en-US\"><span>Są środkiem do realizacji niezależności logicznej danych. &nbsp;</span></span>",
          "correct": true
        },
        {
          "answer": "<span lang=\"en-US\"><span>Umożliwiają zdefiniowanie poziomu zewnętrznego bazy danych. &nbsp;</span></span>",
          "correct": true
        }
      ]
    },
    {
      "question": "<p lang=\"en-US\"><span><span><span>Do zakładania blokad służą konstrukcje:</span></span></span></p>",
      "id": 2552,
      "comments": null,
      "answers": [
        {
          "answer": "ROLLBACK",
          "correct": false
        },
        {
          "answer": "<span>FOR UPDATE</span>",
          "correct": true
        },
        {
          "answer": "<span>LOCK TABLE &nbsp;</span>",
          "correct": true
        },
        {
          "answer": "COMMIT",
          "correct": false
        }
      ]
    },
    {
      "question": "Treść pytania<strong>Tabela (relacja) {Klucze - dużymi literami}. Dany schemat relacyjny Książka (NAZWISKO_AUTORA, TYTUŁ, Imie_Autora, Kategoria) z zależnościami funkcyjnymi F = { Nazwisko_Autora -&gt; Imie_Autora Nazwisko_Autora, Tytuł -&gt; Kategoria } jest w:</strong>",
      "id": 2553,
      "comments": null,
      "answers": [
        {
          "answer": "<p><span>drugiej postaci normalnej</span></p>",
          "correct": false
        },
        {
          "answer": "<p><span>trzeciej postaci normalnej</span></p>",
          "correct": false
        },
        {
          "answer": "<p><span><span>pierwszej postaci normalnej</span></span></p>",
          "correct": true
        }
      ]
    },
    {
      "question": "<p><span><strong>Poziom izolowanej transakcji można ustawić za pomocą instrukcji:</strong></span></p>",
      "id": 2554,
      "comments": null,
      "answers": [
        {
          "answer": "<p lang=\"en-US\"><span>ALTER SESSION</span></p>",
          "correct": false
        },
        {
          "answer": "<p lang=\"en-US\"><span><span>SET ISOLATION LEVEL</span></span></p>",
          "correct": true
        },
        {
          "answer": "<p lang=\"en-US\"><span>CREATE TRANSACTION&nbsp;</span></p>",
          "correct": false
        }
      ]
    },
    {
      "question": "Jakie są role zdefiniowane przez system:",
      "id": 2555,
      "comments": [
        {
          "author": "~anon@194.93.*.*",
          "comment": "wszystkie 3 sa poprawne",
          "date": "16-02-2015 08:27:40"
        },
        {
          "author": "~Gimbus@91.230.*.*",
          "comment": "\nCytując wykład:\n\"Trzy role są z góry zdefiniowane:\nCONNECT - zawierająca uprawnienie CREATE SESSION,\nRESOURCE - uprawnienia do tworzenia obiektów,\nDBA - uprawnienia do wykonywania funkcji administratora systemu.\"\n\nCzyli wszystkie 3 poprawne.",
          "date": "04-07-2015 13:18:25"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "Dokladnie wszystkie 3 sa poprawne",
          "date": "01-07-2017 14:34:37"
        },
        {
          "author": "~marol kichalak@159.205.*.*",
          "comment": "mykhi popraw prosze",
          "date": "31-01-2018 23:50:30"
        }
      ],
      "answers": [
        {
          "answer": "CONNECT",
          "correct": true
        },
        {
          "answer": "RESOURCE",
          "correct": true
        },
        {
          "answer": "DBA",
          "correct": true
        }
      ]
    },
    {
      "question": "<p><span><strong>Wśród uprawnień przyznawanych w instrukcji GRANT występują:</strong></span></p>",
      "id": 2556,
      "comments": [
        {
          "author": "~mm@89.67.*.*",
          "comment": "Przykłąd do commit, poproszę. Nigdzie nie znalazłem nic o jakimkolwiek grant commit.",
          "date": "01-07-2017 10:08:55"
        },
        {
          "author": "~df@91.207.*.*",
          "comment": "Commit jest źle\nTylko a i b",
          "date": "10-07-2020 19:33:31"
        }
      ],
      "answers": [
        {
          "answer": "<p><span><span><span>ALTER</span></span></span></p>",
          "correct": true
        },
        {
          "answer": "<p lang=\"en-US\"><span>&nbsp;EXECUTE</span></p>\n<p>&nbsp;</p>\n<p lang=\"en-US\">&nbsp;</p>",
          "correct": true
        },
        {
          "answer": "<span>COMMIT</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "<p><span><strong>Napisanie w SQL*Plus - describe tabela, spowoduje:&nbsp;</strong></span></p>",
      "id": 2557,
      "comments": null,
      "answers": [
        {
          "answer": "<p><span><span><span><span>wyświetlenie schematu tabeli</span></span></span></span></p>",
          "correct": true
        },
        {
          "answer": "<p><span>utworzenie schematu tabeli</span></p>",
          "correct": false
        },
        {
          "answer": "<p><span>wyświetlenie tylko nazw kolumn w tabeli</span></p>",
          "correct": false
        }
      ]
    },
    {
      "question": "<p><span><strong>Tabele PAŃSTWO i RZEKA ( i relacja przepływa przez) połączone są relacją&nbsp;</strong></span></p>",
      "id": 2558,
      "comments": [
        {
          "author": "~anon@88.156.*.*",
          "comment": "Skoro wymaga dodatkowej tabeli łączącej, to nie oznacza też, że jest to wiele - wiele?",
          "date": "28-01-2016 23:14:43"
        },
        {
          "author": "~anon@81.15.*.*",
          "comment": "zgadzam się z przedmówca \"W przypadku asocjacji wiele-do-wielu konieczne jest wprowadzenie dodatkowej tabeli\"",
          "date": "30-01-2016 17:36:47"
        },
        {
          "author": "~anon@46.112.*.*",
          "comment": "Tak, ale chodzi o połączeniu tabel. A w przypadku połączenia z encją asocjacyjnej, same tabele państwo oraz rzewa nie są połączone bezpośrednio",
          "date": "07-02-2019 15:56:46"
        },
        {
          "author": "~df@91.207.*.*",
          "comment": "Poprawne:\nwiele-wiele\nWymaga tabeli asocjacyjnej",
          "date": "10-07-2020 19:34:29"
        }
      ],
      "answers": [
        {
          "answer": "<p><span>jeden - wiele</span></p>",
          "correct": false
        },
        {
          "answer": "<p><span>wiele - jeden</span></p>",
          "correct": false
        },
        {
          "answer": "<p><span>wiele- wiele</span></p>",
          "correct": false
        },
        {
          "answer": "<p><span> <span>wymagającą dodatkowej tabeli łączącej</span></span></p>",
          "correct": true
        }
      ]
    },
    {
      "question": "Klauzula \"DECLARE Dane_Osoby Osoba%ROWTYPE\" jest w PL/SQL:",
      "id": 2559,
      "comments": [
        {
          "author": "~anon@87.207.*.*",
          "comment": "to nie jest deklaracja nowego rekordu tylko zmiennej o typie rekordu dającej dostęp do kolumn podobny jak do pól obiektu np. w Javie",
          "date": "29-01-2017 14:04:54"
        },
        {
          "author": "~anon@31.178.*.*",
          "comment": "proponuję zmienić\n",
          "date": "01-07-2017 10:07:22"
        },
        {
          "author": "~Kogug@109.206.*.*",
          "comment": "potwierdzam \n\n",
          "date": "02-07-2018 22:20:12"
        },
        {
          "author": "mykhi",
          "comment": "odznaczam a)",
          "date": "02-07-2018 22:38:02"
        }
      ],
      "answers": [
        {
          "answer": "deklatracją nowego rekordu",
          "correct": false
        },
        {
          "answer": "deklaracją nowego typu zmiennej",
          "correct": false
        },
        {
          "answer": "deklaracją zmiennej wraz z definicją jej typu",
          "correct": true
        },
        {
          "answer": "deklaracją zmiennej",
          "correct": true
        }
      ]
    },
    {
      "question": "Które z mechanizmów są używane w hurtowni danych:",
      "id": 2560,
      "comments": null,
      "answers": [
        {
          "answer": "transformacja STAR,",
          "correct": true
        },
        {
          "answer": "partycjonowanie tabeli.",
          "correct": true
        },
        {
          "answer": "histogram,",
          "correct": true
        },
        {
          "answer": "agregacje,",
          "correct": true
        }
      ]
    },
    {
      "question": "Które z mechanizmów są używane w hurtowni danych:",
      "id": 2561,
      "comments": null,
      "answers": [
        {
          "answer": "indeksy bitmapowe.",
          "correct": true
        },
        {
          "answer": "instrukcja ANALYZE,",
          "correct": true
        },
        {
          "answer": "wielowymiarowość,",
          "correct": true
        },
        {
          "answer": "schemat gwiazda.",
          "correct": true
        }
      ]
    },
    {
      "question": "<span>Pakiet w PL/SQL</span>",
      "id": 2533,
      "comments": null,
      "answers": [
        {
          "answer": "<span>&nbsp;Składa się z części publicznej (specyfikacji pakietu) i prywatnej (ciała pakietu)&nbsp;</span><br><br>",
          "correct": true
        },
        {
          "answer": "<span>&nbsp;Deklaracja zmiennych może odbywać się w części publicznej pakietu &nbsp;</span><br><br>",
          "correct": true
        },
        {
          "answer": "<span>&nbsp;Deklaracja zmiennych może odbywać się w części prywatnej pakietu&nbsp;</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "<p align=\"LEFT\"><span><span><span>Opcja sprawdzania użyta przy definiowaniu perspektywy ma znaczenie przy wykonywaniu:</span></span></span></p>",
      "id": 2542,
      "comments": null,
      "answers": [
        {
          "answer": "instrukcji SELECT",
          "correct": false
        },
        {
          "answer": "instrukcje DELETE",
          "correct": false
        },
        {
          "answer": "<span> <span lang=\"en-US\">instrukcji INSERT</span></span>",
          "correct": true
        },
        {
          "answer": "<span>instrukcji UPDATE&nbsp;</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "<span>Co należy do zalet perspektyw?</span>",
      "id": 2546,
      "comments": null,
      "answers": [
        {
          "answer": "Są środkiem do realizacji niezależności fizycznej danych. &nbsp;",
          "correct": false
        },
        {
          "answer": "<span>Umożliwiają zdefiniowanie poziomu zewnętrznego bazy danych.</span>",
          "correct": true
        },
        {
          "answer": "<span>Ochraniają przed niepowołanym lub nieprawidłowym dostępem do danych.&nbsp;&nbsp;</span>",
          "correct": true
        },
        {
          "answer": "<span>Są środkiem do realizacji niezależności logicznej danych.&nbsp;</span>",
          "correct": true
        }
      ]
    },
    {
      "question": "Tabela (relacja) {Klucze - dużymi literami}. Dany schemat relacyjny Pracownik (DOWOD_OSOBISTY, Nazwisko, Adres_Prac, Nr_Działu, Nazwa_Działu), z zależnościami funkcyjnymi F = { Dowod_Osobisty -&gt; Nazwisko, Dowod_Osobisty -&gt; Adres_Prac, Dowod_Osobisty -&gt; Nr_Działu, Nr_Działu -&gt; Nazwa_Działu} jest w:",
      "id": 2610,
      "comments": [
        {
          "author": "~Mossi@94.254.*.*",
          "comment": "Wstępnie postawiłbym na odpowiedź c) \nwiedząc że DOWOD_OSOBISTY jest kluczem\n___________________________\nNazwisko, Dowod_Osobisty -> Adres_Prac - Jest to zła zależność częściowa, a jeśli taka występuje to schemat jest w Pierwszej postaci normalnej",
          "date": "06-07-2018 08:17:01"
        },
        {
          "author": "~anon@89.64.*.*",
          "comment": "a) i c) to poprawne odpowiedzi, nie jest w III postaci normalnej ponieważ Nazwa_działu zależy przechodnio od Dowod_Osobisty (poprzez Nr_działu)",
          "date": "05-02-2019 11:10:58"
        },
        {
          "author": "~heh@162.158.*.*",
          "comment": "jak na moje jest w pierwszej postaci tylko, bo w drugiej mamy mowe o przechowywaniu danych TYLKO JEDNEGO OBIEKTU, np. po co Pracownik.nazwa_działu?",
          "date": "29-06-2019 21:36:54"
        }
      ],
      "answers": [
        {
          "answer": "drugiej postaci normalnej",
          "correct": false
        },
        {
          "answer": "postaci B-C",
          "correct": false
        },
        {
          "answer": "pierwszej postaci normalnej",
          "correct": false
        },
        {
          "answer": "trzeciej postaci normalnej",
          "correct": false
        }
      ]
    },
    {
      "question": "Zdjęcie blokady założonej na tabeli następuje:",
      "id": 2611,
      "comments": [
        {
          "author": "~anon@178.235.*.*",
          "comment": "Według wykładów http://edu.pjwstk.edu.pl/wyklady/sbd/scb/w3.htm\n\n\"Zdjęcie blokady następuje przez wykonanie COMMIT lub ROLLBACK.\" \n\nWięc A i D poprawne odpowiedzi .",
          "date": "31-01-2016 20:22:44"
        },
        {
          "author": "~anon@31.178.*.*",
          "comment": "To może by tak poprawić;)",
          "date": "30-06-2017 18:33:46"
        },
        {
          "author": "~eeeeee@91.230.*.*",
          "comment": "@mykhi poprawisz?",
          "date": "30-01-2018 10:48:36"
        },
        {
          "author": "~anon@89.64.*.*",
          "comment": "Podbijam A i D",
          "date": "10-02-2019 23:35:11"
        },
        {
          "author": "mykhi",
          "comment": "gotowe",
          "date": "10-02-2019 23:41:06"
        }
      ],
      "answers": [
        {
          "answer": "po wykonaniu ROLLBACK",
          "correct": true
        },
        {
          "answer": "po zapisaniu zmiany do bazy danych",
          "correct": false
        },
        {
          "answer": "po zmianie hasła",
          "correct": false
        },
        {
          "answer": "po wykonaniu COMMIT",
          "correct": true
        }
      ]
    },
    {
      "question": "Jak dostać się z zewnątrz do procedury Zatrudnij z parametrami IdPracownika, Nazwisko, Pensja, NrDziału będącej w pakiecie ObsługaPracownika:",
      "id": 2612,
      "comments": [
        {
          "author": "~anon@94.254.*.*",
          "comment": "Nie musi być przynajmniej jedna poprawna? ",
          "date": "29-01-2016 11:08:18"
        },
        {
          "author": "~anon@178.42.*.*",
          "comment": "Wg. mnie to będzie odpowiedź B\nObsługaPracownika.Zatrudnij ....",
          "date": "29-01-2016 16:56:10"
        },
        {
          "author": "~anon@148.81.*.*",
          "comment": "Zgadzam się. B prawidłowe.",
          "date": "01-07-2017 12:20:50"
        },
        {
          "author": "~anon@91.230.*.*",
          "comment": "@mykhi poprawisz?",
          "date": "30-01-2018 11:03:59"
        },
        {
          "author": "~kogut@83.6.*.*",
          "comment": "potwierdzam b",
          "date": "04-07-2018 17:04:58"
        },
        {
          "author": "mykhi",
          "comment": "poprawie! nienawidze sesji :/",
          "date": "04-07-2018 20:18:49"
        },
        {
          "author": "~Won Tyr@89.64.*.*",
          "comment": "nadal nie poprawione\n",
          "date": "29-01-2019 21:09:40"
        },
        {
          "author": "~OCB@5.173.*.*",
          "comment": "UP",
          "date": "13-02-2019 17:29:58"
        },
        {
          "author": "~anon@162.158.*.*",
          "comment": "Nie poprawione \n",
          "date": "29-06-2019 09:08:06"
        },
        {
          "author": "~anon@89.230.*.*",
          "comment": "up",
          "date": "28-01-2020 14:07:21"
        }
      ],
      "answers": [
        {
          "answer": "nie da się do niej dostać z zewnątrz",
          "correct": false
        },
        {
          "answer": "ObsługaPracownika.Zatrudnij(1000, \"Kowalski\", 2000, 10)",
          "correct": true
        },
        {
          "answer": "Zatrudnij(1000, 'Kowalski', 2000, 10)",
          "correct": false
        },
        {
          "answer": "GOTO ObsługaPracownika EXEC Zatrudnij(1000, 'Kowalski', 2000, 10)",
          "correct": false
        }
      ]
    },
    {
      "question": "Które własności wchodzą w skład aksjomatów wykonywania transakcji:",
      "id": 2613,
      "comments": [
        {
          "author": "~anon@95.49.*.*",
          "comment": "gg",
          "date": "08-02-2016 04:49:42"
        },
        {
          "author": "~darka@89.66.*.*",
          "comment": "dla czego spójność nie",
          "date": "29-01-2017 10:42:18"
        },
        {
          "author": "~anon@87.207.*.*",
          "comment": "dla tego że nie jest spó jna",
          "date": "29-01-2017 13:32:03"
        },
        {
          "author": "~anon@148.81.*.*",
          "comment": "Aksjomaty wykonywanania transakcji to:\n1. Atomowość\n2. Spójność\n3. Izolacja\n4. Trwałość\n\n\nwięc odpowiedz d) prawidłowa",
          "date": "01-07-2017 12:02:15"
        },
        {
          "author": "~kogut@83.6.*.*",
          "comment": "potwierdzam d jest prawidłowa",
          "date": "02-07-2018 15:37:48"
        },
        {
          "author": "mykhi",
          "comment": "poprawiam",
          "date": "02-07-2018 17:04:49"
        }
      ],
      "answers": [
        {
          "answer": "skalowalność",
          "correct": false
        },
        {
          "answer": "zabezpieczenie przed nieuprawnionym dostępem",
          "correct": false
        },
        {
          "answer": "wydajność",
          "correct": false
        },
        {
          "answer": "spójność",
          "correct": true
        }
      ]
    },
    {
      "question": "Z ilu tabel powinna się składać prosta znormalizowana baza zawierająca informacje o częściach, urządzeniach i przynależności \"wiele do wielu\" między nimi:",
      "id": 2614,
      "comments": [
        {
          "author": "~anon@81.15.*.*",
          "comment": "jak dla mnie to z trzech czyli\nCzęść{idCzęści,nazwa....}\nPrzynależność{idCzęści,idUrządzenia}\nUrządzenie{idUrządzenia,nazwa...}",
          "date": "30-01-2016 11:16:33"
        },
        {
          "author": "mykhi",
          "comment": "tez tak mysle, zaznaczam.",
          "date": "30-01-2016 11:21:15"
        }
      ],
      "answers": [
        {
          "answer": "2",
          "correct": false
        },
        {
          "answer": "4",
          "correct": false
        },
        {
          "answer": "1",
          "correct": false
        },
        {
          "answer": "3",
          "correct": true
        }
      ]
    },
    {
      "question": "Która z poniższych instrukcij prawidłowo utworzy tabelę tymczasową w T-SQL",
      "id": 2938,
      "comments": [
        {
          "author": "~anon@31.178.*.*",
          "comment": "czy tu nie powinno być a, b i c?",
          "date": "01-07-2017 10:17:39"
        },
        {
          "author": "~anon@148.81.*.*",
          "comment": "dokładnie, prawidłowe odpowiedzi to : a,b,c",
          "date": "01-07-2017 11:59:55"
        },
        {
          "author": "~anon@89.70.*.*",
          "comment": "https://technet.microsoft.com/pl-pl/library/tabele-tymczasowe-i-zmienne-tablicowe-fakty-i-mity.aspx\nA B?",
          "date": "02-09-2017 23:25:19"
        },
        {
          "author": "~anon@89.64.*.*",
          "comment": "tu na pewno jest A B i C poprawne",
          "date": "02-09-2017 23:27:48"
        },
        {
          "author": "~step @94.254.*.*",
          "comment": "tak pomyłka, A B i C są poprawne",
          "date": "03-09-2017 19:31:47"
        },
        {
          "author": "~anon@89.64.*.*",
          "comment": "mykhi popraw",
          "date": "06-02-2018 23:05:31"
        },
        {
          "author": "mykhi",
          "comment": "doznaczam B i C",
          "date": "06-02-2018 23:06:23"
        },
        {
          "author": "~anon@87.206.*.*",
          "comment": "Czemu C?",
          "date": "01-09-2019 08:19:59"
        }
      ],
      "answers": [
        {
          "answer": "CREATE TABLE #Ala (Ala Int);",
          "correct": true
        },
        {
          "answer": "CREATE TABLE ##Ala (Ala Int);",
          "correct": true
        },
        {
          "answer": "SELECT ename, sal INTO #Ala FROM emp;",
          "correct": true
        },
        {
          "answer": "CREATE TABLE Ala (Ala Int);",
          "correct": false
        }
      ]
    },
    {
      "question": "W procedurze (PROCEDURE) PL/SQL",
      "id": 2939,
      "comments": null,
      "answers": [
        {
          "answer": "Deklarując parametr procedury nie podaje się jego typu",
          "correct": false
        },
        {
          "answer": "Jedynym typem parametru jest IN OUT",
          "correct": false
        },
        {
          "answer": "Deklarując typ parametru procedury nie podaje się jego rozmiaru",
          "correct": true
        },
        {
          "answer": "Nazwa procedury może zostać przeciążona",
          "correct": true
        }
      ]
    },
    {
      "question": "Która z poniższych instrukcij jest składniowo poprawna w T-SQL",
      "id": 2940,
      "comments": [
        {
          "author": "~Student@162.158.*.*",
          "comment": "IF NULL = NULL PRINT 'OK'; nie jest odpowiedzia prawidłową. ",
          "date": "28-06-2019 09:36:29"
        },
        {
          "author": "~anon@89.64.*.*",
          "comment": "nieprawda",
          "date": "05-02-2020 00:03:43"
        },
        {
          "author": "~anon@94.172.*.*",
          "comment": "kompiluje się - jest składniowo poprawna",
          "date": "05-02-2020 03:56:44"
        }
      ],
      "answers": [
        {
          "answer": "IF 1 = 1 PRINT 'OK.';",
          "correct": true
        },
        {
          "answer": "IF NULL = NULL PRINT 'OK';",
          "correct": true
        },
        {
          "answer": "IF @empno = @empno PRINT 'OK';",
          "correct": true
        },
        {
          "answer": "WHEN 1 = 1 THEN Print 'OK';",
          "correct": false
        }
      ]
    },
    {
      "question": "Zaznacz poprawne stwierdzenia dotyczące przestrzeni tabel (Oracle) oraz grup plików (MS SQL):",
      "id": 2941,
      "comments": null,
      "answers": [
        {
          "answer": "Przestrzeń tabel ma zawsze określony dokładnie jeden plik dyskowy",
          "correct": false
        },
        {
          "answer": "Grupie plików odpowiada zawsze dokładnie jeden fizyczny dysk twardy",
          "correct": false
        },
        {
          "answer": "Do przestrzeni tabel można przypisać wiele plików dyskowych",
          "correct": true
        },
        {
          "answer": "Do przestrzeni tabel można przydzielić określone tabele bazy danych",
          "correct": true
        }
      ]
    },
    {
      "question": "Błąd w PL/SQL",
      "id": 2942,
      "comments": null,
      "answers": [
        {
          "answer": "który wystąpił w bloku pomiedzy BEGIN i END jest obsługiwany w sekcji EXCEPTION tego samego bloku",
          "correct": true
        },
        {
          "answer": "który wystąpił w sekcij deklaracji bloku jest przekazywany do bloku nadrzędnego",
          "correct": true
        },
        {
          "answer": "który wystąpił w bloku pomiedzy BEGIN i END jest przekazywany do bloku nadrzędnego",
          "correct": false
        },
        {
          "answer": "który wystąpił w sekcji deklaraji bloku jest obsługiwany w sekcji EXCEPTION tego samego bloku",
          "correct": false
        }
      ]
    },
    {
      "question": "Wskazać poprawne zapytanie SQL (dialekt ORACLE) znajdujące departamenty zatrudniające powyżej trzech pracowników",
      "id": 2943,
      "comments": [
        {
          "author": "~anonim@89.72.*.*",
          "comment": "odpowiedź D jest również poprawna",
          "date": "02-09-2017 13:37:53"
        },
        {
          "author": "~anon@94.254.*.*",
          "comment": "D pokazuje departamenty które zatrudniają stanowiska pracy job>3 a nie pracowników ",
          "date": "03-09-2017 19:29:35"
        }
      ],
      "answers": [
        {
          "answer": "SELECT deptno, COUNT(*) FROM emp WHERE COUNT (*) &gt; 3 GROUP BY deptno;",
          "correct": false
        },
        {
          "answer": "SELECT deptno, COUNT(*) FROM emp GROUP BY deptno HAVING COUNT (*) &gt; 3;",
          "correct": true
        },
        {
          "answer": "SELECT deptno, COUNT(*) FROM emp GROUP BY deptno WHERE COUNT (*) &gt; 3;&nbsp;&nbsp;&nbsp;",
          "correct": false
        },
        {
          "answer": "SELECT deptno, job, COUNT(*) FROM emp GROUP BY deptno, job HAVING COUNT(*) &gt; 3;",
          "correct": false
        }
      ]
    },
    {
      "question": "Które z ponizszych sformułowań jest prawdziwe",
      "id": 2944,
      "comments": null,
      "answers": [
        {
          "answer": "Kursor umożliwia nawigację po zestawie rekordów odczytanych z bazy",
          "correct": true
        },
        {
          "answer": "Kursor umożliwia odczytanie wielu wierszy z bazy",
          "correct": true
        },
        {
          "answer": "Kursor jest buforem przechowującym rekordy odczytane z bazy",
          "correct": true
        },
        {
          "answer": "Kursor umożliwia podstawienie na zmienne wartości wszystkich pól z rekordu odczytanego z bazy",
          "correct": true
        }
      ]
    },
    {
      "question": "Dane są trzy tabele Klienci(Id_Klienta, Imie, Nazwisko), Produkty(Id_Produktu, Nazwa, Cena) oraz Zakupy(Id_Klienta, Id_Produktu, Ilosc). Wskaż poprawne zapytania SQL znajdujące imiona i nazwiska klientów, którzy zakupili co najmniej jeden produkt.",
      "id": 2945,
      "comments": null,
      "answers": [
        {
          "answer": "SELECT DISTINCT Imie, Nazwisko FROM Klienci, Zakupy;",
          "correct": false
        },
        {
          "answer": "SELECT DITINCT Imie, Nazwisko FROM Klienci LEFT OUTER JOIN Zakupy ON Klienci.Id_Klienta = Zakupy.Id_Klienta;",
          "correct": false
        },
        {
          "answer": "SELECT DISTINCT Imie, Nazwisko FROM Klienci, Produkty, WHERE Klienci.Id_Klienta = Produkty.Id_Produktu;",
          "correct": false
        },
        {
          "answer": "SELECT DISTINCT Imie, Nazwisko FROM Klienci, Zakupy , Produkty, WHERE Klienci.Id_Klienta = Zakupy.Id_Klienta AND Produkty.Id_Produktu = Zakupy.Id_Produktu;",
          "correct": true
        }
      ]
    },
    {
      "question": "Obiekt bedący generatorem jednoznacznych numerów w Oracle tworzony jest przy pomocy polecenia:",
      "id": 2946,
      "comments": null,
      "answers": [
        {
          "answer": "CREATE AUTONUMBER",
          "correct": false
        },
        {
          "answer": "CREATE SUCCESSION",
          "correct": false
        },
        {
          "answer": "CREATE SEQUENCE",
          "correct": true
        },
        {
          "answer": "CREATE AUTOCOUNTER",
          "correct": false
        }
      ]
    },
    {
      "question": "Która z poniżych instrukcji w SQL Server jest składniowo poprawna (zostanie wykonana)",
      "id": 2947,
      "comments": null,
      "answers": [
        {
          "answer": "SELECT empno FROM emp WHERE empno = empno;",
          "correct": true
        },
        {
          "answer": "SELECT 1 FROM emp WHERE 1 &lt;&gt; 1;<p></p>\n<p>&nbsp;</p>",
          "correct": true
        },
        {
          "answer": "SELECT 1 FROM emp WHERE 1 = 1;",
          "correct": true
        },
        {
          "answer": "SELECT empno FROM emp WHERE 1 = 'Ala';",
          "correct": false
        }
      ]
    },
    {
      "question": "Deklaracja zmiennej w T-SQL",
      "id": 2948,
      "comments": null,
      "answers": [
        {
          "answer": "po jednej dyrektywie DECLARE może pojawić się kilka nazw zmiennych wraz z typami danych, rozdzielonych przecinkami",
          "correct": true
        },
        {
          "answer": "może pojawić się w dowolnym miejscu bloku po dyrektywie DECLARE",
          "correct": true
        },
        {
          "answer": "może wystąpić wyłącznie w wydzielonej sekcji DECLARE",
          "correct": false
        },
        {
          "answer": "musi zawierać określenie typu danych zmiennej",
          "correct": true
        }
      ]
    },
    {
      "question": "Więzy spójności mogą być definiowane w nastepujących instrukcjach:",
      "id": 2949,
      "comments": [
        {
          "author": "~anon@89.64.*.*",
          "comment": "a alter table mozebyc?",
          "date": "06-02-2018 18:57:17"
        },
        {
          "author": "~anon@46.112.*.*",
          "comment": "Constraints can be specified when the table is created with the CREATE TABLE statement, or after the table is created with the ALTER TABLE statement.\n\nhttps://www.w3schools.com/sql/sql_constraints.asp",
          "date": "07-02-2019 16:06:03"
        }
      ],
      "answers": [
        {
          "answer": "ALTER USER",
          "correct": false
        },
        {
          "answer": "UPDATE",
          "correct": false
        },
        {
          "answer": "CREATE TABLE",
          "correct": true
        },
        {
          "answer": "DROP TABLE",
          "correct": false
        }
      ]
    },
    {
      "question": "Polecenia ROLLBACK i COMMIT dotyczą poleceń SQL",
      "id": 2950,
      "comments": null,
      "answers": [
        {
          "answer": "wszystkich poleceń SQL zmieniających zawartość tabel",
          "correct": true
        },
        {
          "answer": "tylko UPDATE, SELECT, DELETE",
          "correct": false
        },
        {
          "answer": "tylko INSERT, SELECT, DELETE",
          "correct": false
        },
        {
          "answer": "tylko INSERT, UPDATE, SELECT",
          "correct": false
        }
      ]
    },
    {
      "question": "Zaznacz poprawne stwierdzenia dotyczące wielowersyjności w bazach danych:",
      "id": 2951,
      "comments": null,
      "answers": [
        {
          "answer": "Poziom izolacji SERILIZABLE w MS SQL Server jest realizowany przy pomocy wielowersyjności.",
          "correct": false
        },
        {
          "answer": "Oracle realizuje poziom izolacji READ COMMITTED przy pomocy wielowersyjności.",
          "correct": true
        },
        {
          "answer": "Oracle oferuje poziom izolacji READ ONLY oparty ma mechanizmie wielowersyjności.",
          "correct": true
        },
        {
          "answer": "Przy zarządzaniu współbieżnością opartym na wielowersyjności&nbsp; procesy odczytujące mogą działać bez zakładania blokad.",
          "correct": true
        }
      ]
    },
    {
      "question": "Które z poniższych słów moga być nagłówkami sekcji w bloku anonimowym PL/SQL",
      "id": 2952,
      "comments": null,
      "answers": [
        {
          "answer": "BEGIN",
          "correct": true
        },
        {
          "answer": "EXCEPTION",
          "correct": true
        },
        {
          "answer": "TRY",
          "correct": false
        },
        {
          "answer": "DECLARE",
          "correct": true
        }
      ]
    },
    {
      "question": "W wyzwalaczu T-SQL można aktualizować dane:",
      "id": 2953,
      "comments": [
        {
          "author": "~anon@148.81.*.*",
          "comment": "prawidłowa odpowiedź to: Tylko w tabeli, z którą jest związany wyzwalacz",
          "date": "01-07-2017 11:44:24"
        },
        {
          "author": "~mm@89.67.*.*",
          "comment": "Nope, polecam przetestować. ",
          "date": "01-07-2017 12:00:19"
        },
        {
          "author": "~anon@89.70.*.*",
          "comment": "czyli co jest dobre ?",
          "date": "01-07-2017 12:01:50"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "to, co jest zaznaczone, odpowiedź D. inserted i deleted to tabele tylko do odczytu",
          "date": "01-07-2017 12:07:38"
        },
        {
          "author": "~anon@148.81.*.*",
          "comment": "Tabele INSERTED i DELETED są tabelami Read Only (tylko do odczytu), czyli\ningerencja w ich zawartość nie jest możliwa. Natomiast z poziomu wyzwalacza\ndostępna do modyfikacji jest ta tabela, na której wyzwalacz jest zdefiniowany.\n\nz wykładu",
          "date": "01-07-2017 12:18:14"
        },
        {
          "author": "~anon@89.67.*.*",
          "comment": "ale nie TYLKO",
          "date": "01-07-2017 12:28:01"
        },
        {
          "author": "~kogut@83.6.*.*",
          "comment": "na pewno do wszystkich tabeli ?",
          "date": "04-07-2018 14:08:34"
        }
      ],
      "answers": [
        {
          "answer": "Z poziomu wyzwalacza nie wolno zmieniać danych w żadnych tabelach",
          "correct": false
        },
        {
          "answer": "Tylko w tabelach INSERTED i DELETED",
          "correct": false
        },
        {
          "answer": "Tylko w tabeli, z którą jest związany wyzwalacz",
          "correct": false
        },
        {
          "answer": "We wszystkich tabelach, poza INSERTED i DELETED",
          "correct": true
        }
      ]
    },
    {
      "question": "Które z poniższych instrukcji może zostać użyta w bloku PL/SQL?",
      "id": 2954,
      "comments": null,
      "answers": [
        {
          "answer": "SELECT",
          "correct": true
        },
        {
          "answer": "ALTER",
          "correct": false
        },
        {
          "answer": "DROP",
          "correct": false
        },
        {
          "answer": "COMMIT",
          "correct": true
        }
      ]
    },
    {
      "question": "Które z poniższych stwierdzeń jest prawdziwe w PL/SQL?",
      "id": 2955,
      "comments": null,
      "answers": [
        {
          "answer": "W instrukcji warunkowej polecenia po THEN wykonywane są wówczas, gdy warunek przyjmuje wartość TRUE",
          "correct": true
        },
        {
          "answer": "Jeżeli w instrukcji warunkwej wartością warunku jest NULL, wówczas nie zostaną wykonane instrukcje po THEN ani po ELSE.",
          "correct": false
        },
        {
          "answer": "W instrukcji warunkowej polecenie po ELSE wykonywane są wówczas, gdy warunek przyjmuje wartość FALSE lub NULL",
          "correct": true
        },
        {
          "answer": "Jeżeli w instrukcji warunkowej wartością warunku jest NULL, wówczas zostaną wykonane instrukcje po THEN",
          "correct": false
        }
      ]
    },
    {
      "question": "Instrukacja MERGE",
      "id": 2956,
      "comments": [
        {
          "author": "~anon@89.67.*.*",
          "comment": "a co z odpowiedzią B? \nCzy odpowiednio napisany merge nie jest w stanie zastąpić dowolnego INSERT/UPDATE?",
          "date": "01-07-2017 12:06:46"
        },
        {
          "author": "~anon@89.230.*.*",
          "comment": "?",
          "date": "27-01-2020 14:22:02"
        }
      ],
      "answers": [
        {
          "answer": "Jest zaimplementowana tylko w PL/SQL",
          "correct": false
        },
        {
          "answer": "Pozwala zrezygnować z używania instrukcji INSERT i UPDATE",
          "correct": false
        },
        {
          "answer": "Opiera się na koncepji porównania rekordów w źródle danych (tabeli lub widoku) i obiekcie docelowym (tabeli lub widoku)",
          "correct": true
        },
        {
          "answer": "Jest zaimplementowana zarówno w T-SQL jak i PL/SQL",
          "correct": true
        }
      ]
    },
    {
      "question": "Wyzwalcz INSTEAD OF",
      "id": 2957,
      "comments": null,
      "answers": [
        {
          "answer": "działa identycznie jak wyzwalacz tybu BEFORE",
          "correct": false
        },
        {
          "answer": "może być stworzony, any umożliwić wykonanie instrukcji DML na perspektywie",
          "correct": true
        },
        {
          "answer": "Jest obiektem tworzonym przez polecenie CREATE",
          "correct": true
        },
        {
          "answer": "może być tworzony na perspektywach",
          "correct": true
        }
      ]
    },
    {
      "question": "Wyzwalcz INSTEAD OF",
      "id": 2958,
      "comments": null,
      "answers": [
        {
          "answer": "działa identycznie jak wyzwalacz tybu BEFORE",
          "correct": false
        },
        {
          "answer": "może być stworzony, any umożliwić wykonanie instrukcji DML na perspektywie",
          "correct": true
        },
        {
          "answer": "Jest obiektem tworzonym przez polecenie CREATE",
          "correct": true
        },
        {
          "answer": "może być tworzony na perspektywach",
          "correct": true
        }
      ]
    },
    {
      "question": "Problem niepowtarzalnego odczytu polega na tym, że:",
      "id": 2959,
      "comments": null,
      "answers": [
        {
          "answer": "Użytkownik może odczytać dane zmienione przez innego użytkownika, które nie zostały zatwierdzone przez COMMIT",
          "correct": false
        },
        {
          "answer": "W dwóch różnych transakcjach tego samego użytkownika odczyt tego samego pola daje różne wyniki",
          "correct": false
        },
        {
          "answer": "W dwóch równolegle działających tranzakcjach odczyt tego samego pola daje różne wyniki",
          "correct": false
        },
        {
          "answer": "W dwóch punktach w czasie trwania tej samej transakcji odczy tego samego pola daje różne wyniki",
          "correct": true
        }
      ]
    }
  ]
}